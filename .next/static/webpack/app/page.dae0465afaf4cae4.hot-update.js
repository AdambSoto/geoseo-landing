"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/ui/splash-cursor.tsx":
/*!*********************************************!*\
  !*** ./src/components/ui/splash-cursor.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SplashCursor: function() { return /* binding */ SplashCursor; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ SplashCursor auto */ \nvar _s = $RefreshSig$();\n\nfunction SplashCursor(param) {\n    let { // Add whatever props you like for customization\n    SIM_RESOLUTION = 128, DYE_RESOLUTION = 1440, CAPTURE_RESOLUTION = 512, DENSITY_DISSIPATION = 3.5, VELOCITY_DISSIPATION = 2, PRESSURE = 0.1, PRESSURE_ITERATIONS = 20, CURL = 3, SPLAT_RADIUS = 0.2, SPLAT_FORCE = 6000, SHADING = true, COLOR_UPDATE_SPEED = 10, BACK_COLOR = {\n        r: 0.5,\n        g: 0,\n        b: 0\n    }, TRANSPARENT = true } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        class Pointer {\n            constructor(){\n                this.id = -1;\n                this.texcoordX = 0;\n                this.texcoordY = 0;\n                this.prevTexcoordX = 0;\n                this.prevTexcoordY = 0;\n                this.deltaX = 0;\n                this.deltaY = 0;\n                this.down = false;\n                this.moved = false;\n                this.color = [\n                    0,\n                    0,\n                    0\n                ];\n            }\n        }\n        let config = {\n            SIM_RESOLUTION,\n            DYE_RESOLUTION,\n            CAPTURE_RESOLUTION,\n            DENSITY_DISSIPATION,\n            VELOCITY_DISSIPATION,\n            PRESSURE,\n            PRESSURE_ITERATIONS,\n            CURL,\n            SPLAT_RADIUS,\n            SPLAT_FORCE,\n            SHADING,\n            COLOR_UPDATE_SPEED,\n            PAUSED: false,\n            BACK_COLOR,\n            TRANSPARENT\n        };\n        let pointers = [\n            new Pointer()\n        ];\n        const { gl, ext } = getWebGLContext(canvas);\n        if (!ext.supportLinearFiltering) {\n            config.DYE_RESOLUTION = 256;\n            config.SHADING = false;\n        }\n        function getWebGLContext(canvas) {\n            const params = {\n                alpha: true,\n                depth: false,\n                stencil: false,\n                antialias: false,\n                preserveDrawingBuffer: false\n            };\n            let gl = canvas.getContext(\"webgl2\", params) || canvas.getContext(\"webgl\", params) || canvas.getContext(\"experimental-webgl\", params);\n            if (!gl) return {\n                gl: null,\n                ext: {}\n            };\n            const isWebGL2 = gl instanceof WebGL2RenderingContext;\n            let halfFloat;\n            let supportLinearFiltering;\n            if (isWebGL2) {\n                gl.getExtension(\"EXT_color_buffer_float\");\n                supportLinearFiltering = gl.getExtension(\"OES_texture_float_linear\");\n            } else {\n                halfFloat = gl.getExtension(\"OES_texture_half_float\");\n                supportLinearFiltering = gl.getExtension(\"OES_texture_half_float_linear\");\n            }\n            gl.clearColor(0.0, 0.0, 0.0, 1.0);\n            const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat && halfFloat.HALF_FLOAT_OES;\n            let formatRGBA;\n            let formatRG;\n            let formatR;\n            if (isWebGL2) {\n                formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n                formatRG = \"RG16F\" in gl && \"RG\" in gl ? getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType) : getSupportedFormat(gl, undefined, undefined, undefined);\n                formatR = \"R16F\" in gl && \"RED\" in gl ? getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType) : getSupportedFormat(gl, undefined, undefined, undefined);\n            } else {\n                formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n                formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n                formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n            }\n            return {\n                gl,\n                ext: {\n                    formatRGBA,\n                    formatRG,\n                    formatR,\n                    halfFloatTexType,\n                    supportLinearFiltering\n                }\n            };\n        }\n        function getSupportedFormat(gl, internalFormat, format, type) {\n            if (!gl) return null;\n            if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n                switch(internalFormat){\n                    case gl.R16F:\n                        return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n                    case gl.RG16F:\n                        return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n                    default:\n                        return null;\n                }\n            }\n            return {\n                internalFormat,\n                format\n            };\n        }\n        function supportRenderTextureFormat(gl, internalFormat, format, type) {\n            if (!gl) return false;\n            const texture = gl.createTexture();\n            if (!texture) return false;\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n            const fbo = gl.createFramebuffer();\n            if (!fbo) return false;\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n            return status === gl.FRAMEBUFFER_COMPLETE;\n        }\n        class Material {\n            setKeywords(keywords) {\n                if (!gl) return;\n                let hash = 0;\n                for(let i = 0; i < keywords.length; i++)hash += hashCode(keywords[i]);\n                let program = this.programs[hash];\n                if (program == null) {\n                    let fragmentShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, this.fragmentShaderSource, keywords);\n                    program = createProgram(this.vertexShader, fragmentShader);\n                    this.programs[hash] = program;\n                }\n                if (program === this.activeProgram) return;\n                this.uniforms = getUniforms(program);\n                this.activeProgram = program;\n            }\n            bind() {\n                if (!gl) return;\n                gl.useProgram(this.activeProgram);\n            }\n            constructor(vertexShader, fragmentShaderSource){\n                this.vertexShader = vertexShader;\n                this.fragmentShaderSource = fragmentShaderSource;\n                this.programs = [];\n                this.activeProgram = null;\n                this.uniforms = [];\n            }\n        }\n        class Program {\n            bind() {\n                if (!gl) return;\n                gl.useProgram(this.program);\n            }\n            constructor(vertexShader, fragmentShader){\n                this.uniforms = {};\n                this.program = createProgram(vertexShader, fragmentShader);\n                this.uniforms = getUniforms(this.program);\n            }\n        }\n        function getUniforms(program) {\n            if (!gl) return [];\n            let uniforms = {};\n            let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n            for(let i = 0; i < uniformCount; i++){\n                const uniformInfo = gl.getActiveUniform(program, i);\n                if (!uniformInfo) continue;\n                let uniformName = uniformInfo.name;\n                uniforms[uniformName] = gl.getUniformLocation(program, uniformName);\n            }\n            return uniforms;\n        }\n        function compileShader(type, source, keywords) {\n            if (!gl) return null;\n            source = addKeywords(source, keywords || []);\n            const shader = gl.createShader(type);\n            if (!shader) return null;\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) console.trace(gl.getShaderInfoLog(shader));\n            return shader;\n        }\n        function createProgram(vertexShader, fragmentShader) {\n            if (!gl || !vertexShader || !fragmentShader) return null;\n            let program = gl.createProgram();\n            if (!program) return null;\n            gl.attachShader(program, vertexShader);\n            gl.attachShader(program, fragmentShader);\n            gl.linkProgram(program);\n            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) console.trace(gl.getProgramInfoLog(program));\n            return program;\n        }\n        function addKeywords(source, keywords) {\n            if (!keywords) return source;\n            let keywordsString = \"\";\n            keywords.forEach((keyword)=>{\n                keywordsString += \"#define \" + keyword + \"\\n\";\n            });\n            return keywordsString + source;\n        }\n        const baseVertexShader = compileShader(gl ? gl.VERTEX_SHADER : 35633, \"\\n        precision highp float;\\n        attribute vec2 aPosition;\\n        varying vec2 vUv;\\n        varying vec2 vL;\\n        varying vec2 vR;\\n        varying vec2 vT;\\n        varying vec2 vB;\\n        uniform vec2 texelSize;\\n\\n        void main () {\\n            vUv = aPosition * 0.5 + 0.5;\\n            vL = vUv - vec2(texelSize.x, 0.0);\\n            vR = vUv + vec2(texelSize.x, 0.0);\\n            vT = vUv + vec2(0.0, texelSize.y);\\n            vB = vUv - vec2(0.0, texelSize.y);\\n            gl_Position = vec4(aPosition, 0.0, 1.0);\\n        }\\n      \", []);\n        const copyShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        uniform sampler2D uTexture;\\n\\n        void main () {\\n            gl_FragColor = texture2D(uTexture, vUv);\\n        }\\n      \", []);\n        const clearShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        uniform sampler2D uTexture;\\n        uniform float value;\\n\\n        void main () {\\n            gl_FragColor = value * texture2D(uTexture, vUv);\\n        }\\n     \", []);\n        const displayShaderSource = \"\\n      precision highp float;\\n      precision highp sampler2D;\\n      varying vec2 vUv;\\n      varying vec2 vL;\\n      varying vec2 vR;\\n      varying vec2 vT;\\n      varying vec2 vB;\\n      uniform sampler2D uTexture;\\n      uniform sampler2D uDithering;\\n      uniform vec2 ditherScale;\\n      uniform vec2 texelSize;\\n\\n      vec3 linearToGamma (vec3 color) {\\n          color = max(color, vec3(0));\\n          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\\n      }\\n\\n      void main () {\\n          vec3 c = texture2D(uTexture, vUv).rgb;\\n          #ifdef SHADING\\n              vec3 lc = texture2D(uTexture, vL).rgb;\\n              vec3 rc = texture2D(uTexture, vR).rgb;\\n              vec3 tc = texture2D(uTexture, vT).rgb;\\n              vec3 bc = texture2D(uTexture, vB).rgb;\\n\\n              float dx = length(rc) - length(lc);\\n              float dy = length(tc) - length(bc);\\n\\n              vec3 n = normalize(vec3(dx, dy, length(texelSize)));\\n              vec3 l = vec3(0.0, 0.0, 1.0);\\n\\n              float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\\n              c *= diffuse;\\n          #endif\\n\\n          float a = max(c.r, max(c.g, c.b));\\n          gl_FragColor = vec4(c, a);\\n      }\\n    \";\n        const splatShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision highp float;\\n        precision highp sampler2D;\\n        varying vec2 vUv;\\n        uniform sampler2D uTarget;\\n        uniform float aspectRatio;\\n        uniform vec3 color;\\n        uniform vec2 point;\\n        uniform float radius;\\n\\n        void main () {\\n            vec2 p = vUv - point.xy;\\n            p.x *= aspectRatio;\\n            vec3 splat = exp(-dot(p, p) / radius) * color;\\n            vec3 base = texture2D(uTarget, vUv).xyz;\\n            gl_FragColor = vec4(base + splat, 1.0);\\n        }\\n      \", []);\n        const advectionShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision highp float;\\n        precision highp sampler2D;\\n        varying vec2 vUv;\\n        uniform sampler2D uVelocity;\\n        uniform sampler2D uSource;\\n        uniform vec2 texelSize;\\n        uniform vec2 dyeTexelSize;\\n        uniform float dt;\\n        uniform float dissipation;\\n\\n        vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\\n            vec2 st = uv / tsize - 0.5;\\n            vec2 iuv = floor(st);\\n            vec2 fuv = fract(st);\\n\\n            vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\\n            vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\\n            vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\\n            vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\\n\\n            return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\\n        }\\n\\n        void main () {\\n            #ifdef MANUAL_FILTERING\\n                vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\\n                vec4 result = bilerp(uSource, coord, dyeTexelSize);\\n            #else\\n                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\\n                vec4 result = texture2D(uSource, coord);\\n            #endif\\n            float decay = 1.0 + dissipation * dt;\\n            gl_FragColor = result / decay;\\n        }\\n      \", ext && ext.supportLinearFiltering ? [] : [\n            \"MANUAL_FILTERING\"\n        ]);\n        const divergenceShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        varying highp vec2 vL;\\n        varying highp vec2 vR;\\n        varying highp vec2 vT;\\n        varying highp vec2 vB;\\n        uniform sampler2D uVelocity;\\n\\n        void main () {\\n            float L = texture2D(uVelocity, vL).x;\\n            float R = texture2D(uVelocity, vR).x;\\n            float T = texture2D(uVelocity, vT).y;\\n            float B = texture2D(uVelocity, vB).y;\\n\\n            vec2 C = texture2D(uVelocity, vUv).xy;\\n            if (vL.x < 0.0) { L = -C.x; }\\n            if (vR.x > 1.0) { R = -C.x; }\\n            if (vT.y > 1.0) { T = -C.y; }\\n            if (vB.y < 0.0) { B = -C.y; }\\n\\n            float div = 0.5 * (R - L + T - B);\\n            gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\\n        }\\n      \", []);\n        const curlShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        varying highp vec2 vL;\\n        varying highp vec2 vR;\\n        varying highp vec2 vT;\\n        varying highp vec2 vB;\\n        uniform sampler2D uVelocity;\\n\\n        void main () {\\n            float L = texture2D(uVelocity, vL).y;\\n            float R = texture2D(uVelocity, vR).y;\\n            float T = texture2D(uVelocity, vT).x;\\n            float B = texture2D(uVelocity, vB).x;\\n            float vorticity = R - L - T + B;\\n            gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\\n        }\\n      \", []);\n        const vorticityShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision highp float;\\n        precision highp sampler2D;\\n        varying vec2 vUv;\\n        varying vec2 vL;\\n        varying vec2 vR;\\n        varying vec2 vT;\\n        varying vec2 vB;\\n        uniform sampler2D uVelocity;\\n        uniform sampler2D uCurl;\\n        uniform float curl;\\n        uniform float dt;\\n\\n        void main () {\\n            float L = texture2D(uCurl, vL).x;\\n            float R = texture2D(uCurl, vR).x;\\n            float T = texture2D(uCurl, vT).x;\\n            float B = texture2D(uCurl, vB).x;\\n            float C = texture2D(uCurl, vUv).x;\\n\\n            vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\\n            force /= length(force) + 0.0001;\\n            force *= curl * C;\\n            force.y *= -1.0;\\n\\n            vec2 velocity = texture2D(uVelocity, vUv).xy;\\n            velocity += force * dt;\\n            velocity = min(max(velocity, -1000.0), 1000.0);\\n            gl_FragColor = vec4(velocity, 0.0, 1.0);\\n        }\\n      \", []);\n        const pressureShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        varying highp vec2 vL;\\n        varying highp vec2 vR;\\n        varying highp vec2 vT;\\n        varying highp vec2 vB;\\n        uniform sampler2D uPressure;\\n        uniform sampler2D uDivergence;\\n\\n        void main () {\\n            float L = texture2D(uPressure, vL).x;\\n            float R = texture2D(uPressure, vR).x;\\n            float T = texture2D(uPressure, vT).x;\\n            float B = texture2D(uPressure, vB).x;\\n            float C = texture2D(uPressure, vUv).x;\\n            float divergence = texture2D(uDivergence, vUv).x;\\n            float pressure = (L + R + B + T - divergence) * 0.25;\\n            gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\\n        }\\n      \", []);\n        const gradientSubtractShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        varying highp vec2 vL;\\n        varying highp vec2 vR;\\n        varying highp vec2 vT;\\n        varying highp vec2 vB;\\n        uniform sampler2D uPressure;\\n        uniform sampler2D uVelocity;\\n\\n        void main () {\\n            float L = texture2D(uPressure, vL).x;\\n            float R = texture2D(uPressure, vR).x;\\n            float T = texture2D(uPressure, vT).x;\\n            float B = texture2D(uPressure, vB).x;\\n            vec2 velocity = texture2D(uVelocity, vUv).xy;\\n            velocity.xy -= vec2(R - L, T - B);\\n            gl_FragColor = vec4(velocity, 0.0, 1.0);\\n        }\\n      \", []);\n        const blit = (()=>{\n            gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n                -1,\n                -1,\n                -1,\n                1,\n                1,\n                1,\n                1,\n                -1\n            ]), gl.STATIC_DRAW);\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([\n                0,\n                1,\n                2,\n                0,\n                2,\n                3\n            ]), gl.STATIC_DRAW);\n            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(0);\n            return function(target) {\n                let clear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n                if (target == null) {\n                    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                } else {\n                    gl.viewport(0, 0, target.width, target.height);\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n                }\n                if (clear) {\n                    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n                    gl.clear(gl.COLOR_BUFFER_BIT);\n                }\n                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n            };\n        })();\n        let dye, velocity, divergence, curl, pressure;\n        const copyProgram = new Program(baseVertexShader, copyShader);\n        const clearProgram = new Program(baseVertexShader, clearShader);\n        const splatProgram = new Program(baseVertexShader, splatShader);\n        const advectionProgram = new Program(baseVertexShader, advectionShader);\n        const divergenceProgram = new Program(baseVertexShader, divergenceShader);\n        const curlProgram = new Program(baseVertexShader, curlShader);\n        const vorticityProgram = new Program(baseVertexShader, vorticityShader);\n        const pressureProgram = new Program(baseVertexShader, pressureShader);\n        const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);\n        const displayMaterial = new Material(baseVertexShader, displayShaderSource);\n        function initFramebuffers() {\n            let simRes = getResolution(config.SIM_RESOLUTION);\n            let dyeRes = getResolution(config.DYE_RESOLUTION);\n            const texType = ext.halfFloatTexType;\n            const rgba = ext.formatRGBA;\n            const rg = ext.formatRG;\n            const r = ext.formatR;\n            const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n            gl.disable(gl.BLEND);\n            if (!dye) dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n            else dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n            if (!velocity) velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n            else velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n            divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n            curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n            pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n        }\n        function createFBO(w, h, internalFormat, format, type, param) {\n            gl.activeTexture(gl.TEXTURE0);\n            let texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n            let fbo = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            gl.viewport(0, 0, w, h);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            let texelSizeX = 1.0 / w;\n            let texelSizeY = 1.0 / h;\n            return {\n                texture,\n                fbo,\n                width: w,\n                height: h,\n                texelSizeX,\n                texelSizeY,\n                attach (id) {\n                    gl.activeTexture(gl.TEXTURE0 + id);\n                    gl.bindTexture(gl.TEXTURE_2D, texture);\n                    return id;\n                }\n            };\n        }\n        function createDoubleFBO(w, h, internalFormat, format, type, param) {\n            let fbo1 = createFBO(w, h, internalFormat, format, type, param);\n            let fbo2 = createFBO(w, h, internalFormat, format, type, param);\n            return {\n                width: w,\n                height: h,\n                texelSizeX: fbo1.texelSizeX,\n                texelSizeY: fbo1.texelSizeY,\n                get read () {\n                    return fbo1;\n                },\n                set read (value){\n                    fbo1 = value;\n                },\n                get write () {\n                    return fbo2;\n                },\n                set write (value){\n                    fbo2 = value;\n                },\n                swap () {\n                    let temp = fbo1;\n                    fbo1 = fbo2;\n                    fbo2 = temp;\n                }\n            };\n        }\n        function resizeFBO(target, w, h, internalFormat, format, type, param) {\n            let newFBO = createFBO(w, h, internalFormat, format, type, param);\n            copyProgram.bind();\n            gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n            blit(newFBO);\n            return newFBO;\n        }\n        function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {\n            if (target.width === w && target.height === h) return target;\n            target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);\n            target.write = createFBO(w, h, internalFormat, format, type, param);\n            target.width = w;\n            target.height = h;\n            target.texelSizeX = 1.0 / w;\n            target.texelSizeY = 1.0 / h;\n            return target;\n        }\n        function updateKeywords() {\n            let displayKeywords = [];\n            if (config.SHADING) displayKeywords.push(\"SHADING\");\n            displayMaterial.setKeywords(displayKeywords);\n        }\n        updateKeywords();\n        initFramebuffers();\n        let lastUpdateTime = Date.now();\n        let colorUpdateTimer = 0.0;\n        function updateFrame() {\n            const dt = calcDeltaTime();\n            if (resizeCanvas()) initFramebuffers();\n            updateColors(dt);\n            applyInputs();\n            step(dt);\n            render(null);\n            requestAnimationFrame(updateFrame);\n        }\n        function calcDeltaTime() {\n            let now = Date.now();\n            let dt = (now - lastUpdateTime) / 1000;\n            dt = Math.min(dt, 0.016666);\n            lastUpdateTime = now;\n            return dt;\n        }\n        function resizeCanvas() {\n            let width = scaleByPixelRatio(canvas.clientWidth);\n            let height = scaleByPixelRatio(canvas.clientHeight);\n            if (canvas.width !== width || canvas.height !== height) {\n                canvas.width = width;\n                canvas.height = height;\n                return true;\n            }\n            return false;\n        }\n        function updateColors(dt) {\n            colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n            if (colorUpdateTimer >= 1) {\n                colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n                pointers.forEach((p)=>{\n                    p.color = generateColor();\n                });\n            }\n        }\n        function applyInputs() {\n            pointers.forEach((p)=>{\n                if (p.moved) {\n                    p.moved = false;\n                    splatPointer(p);\n                }\n            });\n        }\n        function step(dt) {\n            gl.disable(gl.BLEND);\n            // Curl\n            curlProgram.bind();\n            gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n            blit(curl);\n            // Vorticity\n            vorticityProgram.bind();\n            gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n            gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n            gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n            gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n            blit(velocity.write);\n            velocity.swap();\n            // Divergence\n            divergenceProgram.bind();\n            gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n            blit(divergence);\n            // Clear pressure\n            clearProgram.bind();\n            gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n            gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n            blit(pressure.write);\n            pressure.swap();\n            // Pressure\n            pressureProgram.bind();\n            gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n            for(let i = 0; i < config.PRESSURE_ITERATIONS; i++){\n                gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n                blit(pressure.write);\n                pressure.swap();\n            }\n            // Gradient Subtract\n            gradienSubtractProgram.bind();\n            gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));\n            gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));\n            blit(velocity.write);\n            velocity.swap();\n            // Advection\n            advectionProgram.bind();\n            gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);\n            let velocityId = velocity.read.attach(0);\n            gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n            gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n            gl.uniform1f(advectionProgram.uniforms.dt, dt);\n            gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n            blit(velocity.write);\n            velocity.swap();\n            if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);\n            gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n            gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n            gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n            blit(dye.write);\n            dye.swap();\n        }\n        function render(target) {\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n            drawDisplay(target);\n        }\n        function drawDisplay(target) {\n            let width = target == null ? gl.drawingBufferWidth : target.width;\n            let height = target == null ? gl.drawingBufferHeight : target.height;\n            displayMaterial.bind();\n            if (config.SHADING) gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);\n            gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n            blit(target);\n        }\n        function splatPointer(pointer) {\n            let dx = pointer.deltaX * config.SPLAT_FORCE;\n            let dy = pointer.deltaY * config.SPLAT_FORCE;\n            splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n        }\n        function clickSplat(pointer) {\n            const color = generateColor();\n            color.r *= 10.0;\n            color.g *= 10.0;\n            color.b *= 10.0;\n            let dx = 10 * (Math.random() - 0.5);\n            let dy = 30 * (Math.random() - 0.5);\n            splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);\n        }\n        function splat(x, y, dx, dy, color) {\n            splatProgram.bind();\n            gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n            gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n            gl.uniform2f(splatProgram.uniforms.point, x, y);\n            gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);\n            gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));\n            blit(velocity.write);\n            velocity.swap();\n            gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n            gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n            blit(dye.write);\n            dye.swap();\n        }\n        function correctRadius(radius) {\n            let aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio > 1) radius *= aspectRatio;\n            return radius;\n        }\n        function updatePointerDownData(pointer, id, posX, posY) {\n            pointer.id = id;\n            pointer.down = true;\n            pointer.moved = false;\n            pointer.texcoordX = posX / canvas.width;\n            pointer.texcoordY = 1.0 - posY / canvas.height;\n            pointer.prevTexcoordX = pointer.texcoordX;\n            pointer.prevTexcoordY = pointer.texcoordY;\n            pointer.deltaX = 0;\n            pointer.deltaY = 0;\n            pointer.color = generateColor();\n        }\n        function updatePointerMoveData(pointer, posX, posY, color) {\n            pointer.prevTexcoordX = pointer.texcoordX;\n            pointer.prevTexcoordY = pointer.texcoordY;\n            pointer.texcoordX = posX / canvas.width;\n            pointer.texcoordY = 1.0 - posY / canvas.height;\n            pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n            pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n            pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n            pointer.color = color;\n        }\n        function updatePointerUpData(pointer) {\n            pointer.down = false;\n        }\n        function correctDeltaX(delta) {\n            let aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio < 1) delta *= aspectRatio;\n            return delta;\n        }\n        function correctDeltaY(delta) {\n            let aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio > 1) delta /= aspectRatio;\n            return delta;\n        }\n        function generateColor() {\n            let c = HSVtoRGB(Math.random(), 1.0, 1.0);\n            c.r *= 0.15;\n            c.g *= 0.15;\n            c.b *= 0.15;\n            return c;\n        }\n        function HSVtoRGB(h, s, v) {\n            let r, g, b, i, f, p, q, t;\n            i = Math.floor(h * 6);\n            f = h * 6 - i;\n            p = v * (1 - s);\n            q = v * (1 - f * s);\n            t = v * (1 - (1 - f) * s);\n            switch(i % 6){\n                case 0:\n                    r = v;\n                    g = t;\n                    b = p;\n                    break;\n                case 1:\n                    r = q;\n                    g = v;\n                    b = p;\n                    break;\n                case 2:\n                    r = p;\n                    g = v;\n                    b = t;\n                    break;\n                case 3:\n                    r = p;\n                    g = q;\n                    b = v;\n                    break;\n                case 4:\n                    r = t;\n                    g = p;\n                    b = v;\n                    break;\n                case 5:\n                    r = v;\n                    g = p;\n                    b = q;\n                    break;\n                default:\n                    break;\n            }\n            return {\n                r,\n                g,\n                b\n            };\n        }\n        function wrap(value1, min, max) {\n            const range = max - min;\n            if (range === 0) return min;\n            return (value1 - min) % range + min;\n        }\n        function getResolution(resolution) {\n            let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n            if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;\n            const min = Math.round(resolution);\n            const max = Math.round(resolution * aspectRatio);\n            if (gl.drawingBufferWidth > gl.drawingBufferHeight) return {\n                width: max,\n                height: min\n            };\n            else return {\n                width: min,\n                height: max\n            };\n        }\n        function scaleByPixelRatio(input) {\n            const pixelRatio = window.devicePixelRatio || 1;\n            return Math.floor(input * pixelRatio);\n        }\n        function hashCode(s) {\n            if (s.length === 0) return 0;\n            let hash = 0;\n            for(let i = 0; i < s.length; i++){\n                hash = (hash << 5) - hash + s.charCodeAt(i);\n                hash |= 0;\n            }\n            return hash;\n        }\n        window.addEventListener(\"mousedown\", (e)=>{\n            let pointer = pointers[0];\n            let posX = scaleByPixelRatio(e.clientX);\n            let posY = scaleByPixelRatio(e.clientY);\n            updatePointerDownData(pointer, -1, posX, posY);\n            clickSplat(pointer);\n        });\n        document.body.addEventListener(\"mousemove\", function handleFirstMouseMove(e) {\n            let pointer = pointers[0];\n            let posX = scaleByPixelRatio(e.clientX);\n            let posY = scaleByPixelRatio(e.clientY);\n            let color = generateColor();\n            updateFrame(); // start animation loop\n            updatePointerMoveData(pointer, posX, posY, color);\n            document.body.removeEventListener(\"mousemove\", handleFirstMouseMove);\n        });\n        window.addEventListener(\"mousemove\", (e)=>{\n            let pointer = pointers[0];\n            let posX = scaleByPixelRatio(e.clientX);\n            let posY = scaleByPixelRatio(e.clientY);\n            let color = pointer.color;\n            updatePointerMoveData(pointer, posX, posY, color);\n        });\n        document.body.addEventListener(\"touchstart\", function handleFirstTouchStart(e) {\n            const touches = e.targetTouches;\n            let pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                let posX = scaleByPixelRatio(touches[i].clientX);\n                let posY = scaleByPixelRatio(touches[i].clientY);\n                updateFrame(); // start animation loop\n                updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n            }\n            document.body.removeEventListener(\"touchstart\", handleFirstTouchStart);\n        });\n        window.addEventListener(\"touchstart\", (e)=>{\n            const touches = e.targetTouches;\n            let pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                let posX = scaleByPixelRatio(touches[i].clientX);\n                let posY = scaleByPixelRatio(touches[i].clientY);\n                updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n            }\n        });\n        window.addEventListener(\"touchmove\", (e)=>{\n            const touches = e.targetTouches;\n            let pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                let posX = scaleByPixelRatio(touches[i].clientX);\n                let posY = scaleByPixelRatio(touches[i].clientY);\n                updatePointerMoveData(pointer, posX, posY, pointer.color);\n            }\n        }, false);\n        window.addEventListener(\"touchend\", (e)=>{\n            const touches = e.changedTouches;\n            let pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                updatePointerUpData(pointer);\n            }\n        });\n        updateFrame();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        SIM_RESOLUTION,\n        DYE_RESOLUTION,\n        CAPTURE_RESOLUTION,\n        DENSITY_DISSIPATION,\n        VELOCITY_DISSIPATION,\n        PRESSURE,\n        PRESSURE_ITERATIONS,\n        CURL,\n        SPLAT_RADIUS,\n        SPLAT_FORCE,\n        SHADING,\n        COLOR_UPDATE_SPEED,\n        BACK_COLOR,\n        TRANSPARENT\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed top-0 left-0 z-50 pointer-events-none\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n            ref: canvasRef,\n            id: \"fluid\",\n            className: \"w-screen h-screen\"\n        }, void 0, false, {\n            fileName: \"/Users/adamsoto/Desktop/GEOSEO_LandingPage/src/components/ui/splash-cursor.tsx\",\n            lineNumber: 1309,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/adamsoto/Desktop/GEOSEO_LandingPage/src/components/ui/splash-cursor.tsx\",\n        lineNumber: 1308,\n        columnNumber: 5\n    }, this);\n}\n_s(SplashCursor, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = SplashCursor;\n\nvar _c;\n$RefreshReg$(_c, \"SplashCursor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL3NwbGFzaC1jdXJzb3IudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUMwQztBQUUxQyxTQUFTRSxhQUFhLEtBZ0JyQjtRQWhCcUIsRUFDcEIsZ0RBQWdEO0lBQ2hEQyxpQkFBaUIsR0FBRyxFQUNwQkMsaUJBQWlCLElBQUksRUFDckJDLHFCQUFxQixHQUFHLEVBQ3hCQyxzQkFBc0IsR0FBRyxFQUN6QkMsdUJBQXVCLENBQUMsRUFDeEJDLFdBQVcsR0FBRyxFQUNkQyxzQkFBc0IsRUFBRSxFQUN4QkMsT0FBTyxDQUFDLEVBQ1JDLGVBQWUsR0FBRyxFQUNsQkMsY0FBYyxJQUFJLEVBQ2xCQyxVQUFVLElBQUksRUFDZEMscUJBQXFCLEVBQUUsRUFDdkJDLGFBQWE7UUFBRUMsR0FBRztRQUFLQyxHQUFHO1FBQUdDLEdBQUc7SUFBRSxDQUFDLEVBQ25DQyxjQUFjLElBQUksRUFDbkIsR0FoQnFCOztJQWlCcEIsTUFBTUMsWUFBWW5CLDZDQUFNQSxDQUFDO0lBRXpCRCxnREFBU0EsQ0FBQztRQUNSLE1BQU1xQixTQUFTRCxVQUFVRSxPQUFPO1FBQ2hDLElBQUksQ0FBQ0QsUUFBUTtRQUViLE1BQU1FOztxQkFDSkMsS0FBSyxDQUFDO3FCQUNOQyxZQUFZO3FCQUNaQyxZQUFZO3FCQUNaQyxnQkFBZ0I7cUJBQ2hCQyxnQkFBZ0I7cUJBQ2hCQyxTQUFTO3FCQUNUQyxTQUFTO3FCQUNUQyxPQUFPO3FCQUNQQyxRQUFRO3FCQUNSQyxRQUFRO29CQUFDO29CQUFHO29CQUFHO2lCQUFFOztRQUNuQjtRQUVBLElBQUlDLFNBQVM7WUFDWC9CO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FxQixRQUFRO1lBQ1JwQjtZQUNBSTtRQUNGO1FBRUEsSUFBSWlCLFdBQVc7WUFBQyxJQUFJYjtTQUFVO1FBRTlCLE1BQU0sRUFBRWMsRUFB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MVM7WUFBV0ksSUFBRztZQUFRcVMsV0FBVTs7Ozs7Ozs7Ozs7QUFHbkQ7R0E1eENTM1Q7S0FBQUE7QUE4eENlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3VpL3NwbGFzaC1jdXJzb3IudHN4P2FhZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuXG5mdW5jdGlvbiBTcGxhc2hDdXJzb3Ioe1xuICAvLyBBZGQgd2hhdGV2ZXIgcHJvcHMgeW91IGxpa2UgZm9yIGN1c3RvbWl6YXRpb25cbiAgU0lNX1JFU09MVVRJT04gPSAxMjgsXG4gIERZRV9SRVNPTFVUSU9OID0gMTQ0MCxcbiAgQ0FQVFVSRV9SRVNPTFVUSU9OID0gNTEyLFxuICBERU5TSVRZX0RJU1NJUEFUSU9OID0gMy41LFxuICBWRUxPQ0lUWV9ESVNTSVBBVElPTiA9IDIsXG4gIFBSRVNTVVJFID0gMC4xLFxuICBQUkVTU1VSRV9JVEVSQVRJT05TID0gMjAsXG4gIENVUkwgPSAzLFxuICBTUExBVF9SQURJVVMgPSAwLjIsXG4gIFNQTEFUX0ZPUkNFID0gNjAwMCxcbiAgU0hBRElORyA9IHRydWUsXG4gIENPTE9SX1VQREFURV9TUEVFRCA9IDEwLFxuICBCQUNLX0NPTE9SID0geyByOiAwLjUsIGc6IDAsIGI6IDAgfSxcbiAgVFJBTlNQQVJFTlQgPSB0cnVlLFxufSkge1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuXG4gICAgY2xhc3MgUG9pbnRlciB7XG4gICAgICBpZCA9IC0xO1xuICAgICAgdGV4Y29vcmRYID0gMDtcbiAgICAgIHRleGNvb3JkWSA9IDA7XG4gICAgICBwcmV2VGV4Y29vcmRYID0gMDtcbiAgICAgIHByZXZUZXhjb29yZFkgPSAwO1xuICAgICAgZGVsdGFYID0gMDtcbiAgICAgIGRlbHRhWSA9IDA7XG4gICAgICBkb3duID0gZmFsc2U7XG4gICAgICBtb3ZlZCA9IGZhbHNlO1xuICAgICAgY29sb3IgPSBbMCwgMCwgMF07XG4gICAgfVxuXG4gICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgIFNJTV9SRVNPTFVUSU9OLFxuICAgICAgRFlFX1JFU09MVVRJT04sXG4gICAgICBDQVBUVVJFX1JFU09MVVRJT04sXG4gICAgICBERU5TSVRZX0RJU1NJUEFUSU9OLFxuICAgICAgVkVMT0NJVFlfRElTU0lQQVRJT04sXG4gICAgICBQUkVTU1VSRSxcbiAgICAgIFBSRVNTVVJFX0lURVJBVElPTlMsXG4gICAgICBDVVJMLFxuICAgICAgU1BMQVRfUkFESVVTLFxuICAgICAgU1BMQVRfRk9SQ0UsXG4gICAgICBTSEFESU5HLFxuICAgICAgQ09MT1JfVVBEQVRFX1NQRUVELFxuICAgICAgUEFVU0VEOiBmYWxzZSxcbiAgICAgIEJBQ0tfQ09MT1IsXG4gICAgICBUUkFOU1BBUkVOVCxcbiAgICB9O1xuXG4gICAgbGV0IHBvaW50ZXJzID0gW25ldyBQb2ludGVyKCldO1xuXG4gICAgY29uc3QgeyBnbCwgZXh0IH0gPSBnZXRXZWJHTENvbnRleHQoY2FudmFzKTtcbiAgICBpZiAoIWV4dC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nKSB7XG4gICAgICBjb25maWcuRFlFX1JFU09MVVRJT04gPSAyNTY7XG4gICAgICBjb25maWcuU0hBRElORyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlYkdMQ29udGV4dChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgICBkZXB0aDogZmFsc2UsXG4gICAgICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgICAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuICAgICAgfTtcbiAgICAgIGxldCBnbCA9XG4gICAgICAgIChjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBwYXJhbXMpIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgfCBudWxsKSB8fFxuICAgICAgICAoY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBwYXJhbXMpIGFzIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB8IG51bGwpIHx8XG4gICAgICAgIChjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBwYXJhbXMpIGFzIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB8IG51bGwpO1xuICAgICAgaWYgKCFnbCkgcmV0dXJuIHsgZ2w6IG51bGwsIGV4dDoge30gfTtcbiAgICAgIGNvbnN0IGlzV2ViR0wyID0gKGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCk7XG4gICAgICBsZXQgaGFsZkZsb2F0O1xuICAgICAgbGV0IHN1cHBvcnRMaW5lYXJGaWx0ZXJpbmc7XG4gICAgICBpZiAoaXNXZWJHTDIpIHtcbiAgICAgICAgKGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIik7XG4gICAgICAgIHN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgPSAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFsZkZsb2F0ID0gKGdsIGFzIFdlYkdMUmVuZGVyaW5nQ29udGV4dCkuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKTtcbiAgICAgICAgc3VwcG9ydExpbmVhckZpbHRlcmluZyA9IChnbCBhcyBXZWJHTFJlbmRlcmluZ0NvbnRleHQpLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXCIpO1xuICAgICAgfVxuICAgICAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAxLjApO1xuICAgICAgY29uc3QgaGFsZkZsb2F0VGV4VHlwZSA9IGlzV2ViR0wyXG4gICAgICAgID8gKGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpLkhBTEZfRkxPQVRcbiAgICAgICAgOiBoYWxmRmxvYXQgJiYgaGFsZkZsb2F0LkhBTEZfRkxPQVRfT0VTO1xuICAgICAgbGV0IGZvcm1hdFJHQkE7XG4gICAgICBsZXQgZm9ybWF0Ukc7XG4gICAgICBsZXQgZm9ybWF0UjtcblxuICAgICAgaWYgKGlzV2ViR0wyKSB7XG4gICAgICAgIGZvcm1hdFJHQkEgPSBnZXRTdXBwb3J0ZWRGb3JtYXQoXG4gICAgICAgICAgZ2wsXG4gICAgICAgICAgKGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpLlJHQkExNkYsXG4gICAgICAgICAgKGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpLlJHQkEsXG4gICAgICAgICAgaGFsZkZsb2F0VGV4VHlwZVxuICAgICAgICApO1xuICAgICAgICBmb3JtYXRSRyA9XG4gICAgICAgICAgJ1JHMTZGJyBpbiAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkgJiYgJ1JHJyBpbiAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dClcbiAgICAgICAgICAgID8gZ2V0U3VwcG9ydGVkRm9ybWF0KFxuICAgICAgICAgICAgICAgIGdsLFxuICAgICAgICAgICAgICAgIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5SRzE2RixcbiAgICAgICAgICAgICAgICAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuUkcsXG4gICAgICAgICAgICAgICAgaGFsZkZsb2F0VGV4VHlwZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IGdldFN1cHBvcnRlZEZvcm1hdChnbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgIGZvcm1hdFIgPVxuICAgICAgICAgICdSMTZGJyBpbiAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkgJiYgJ1JFRCcgaW4gKGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpXG4gICAgICAgICAgICA/IGdldFN1cHBvcnRlZEZvcm1hdChcbiAgICAgICAgICAgICAgICBnbCxcbiAgICAgICAgICAgICAgICAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuUjE2RixcbiAgICAgICAgICAgICAgICAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuUkVELFxuICAgICAgICAgICAgICAgIGhhbGZGbG9hdFRleFR5cGVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9ybWF0UkdCQSA9IGdldFN1cHBvcnRlZEZvcm1hdChnbCwgKGdsIGFzIFdlYkdMUmVuZGVyaW5nQ29udGV4dCkuUkdCQSwgKGdsIGFzIFdlYkdMUmVuZGVyaW5nQ29udGV4dCkuUkdCQSwgaGFsZkZsb2F0VGV4VHlwZSk7XG4gICAgICAgIGZvcm1hdFJHID0gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCAoZ2wgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0KS5SR0JBLCAoZ2wgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0KS5SR0JBLCBoYWxmRmxvYXRUZXhUeXBlKTtcbiAgICAgICAgZm9ybWF0UiA9IGdldFN1cHBvcnRlZEZvcm1hdChnbCwgKGdsIGFzIFdlYkdMUmVuZGVyaW5nQ29udGV4dCkuUkdCQSwgKGdsIGFzIFdlYkdMUmVuZGVyaW5nQ29udGV4dCkuUkdCQSwgaGFsZkZsb2F0VGV4VHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdsLFxuICAgICAgICBleHQ6IHtcbiAgICAgICAgICBmb3JtYXRSR0JBLFxuICAgICAgICAgIGZvcm1hdFJHLFxuICAgICAgICAgIGZvcm1hdFIsXG4gICAgICAgICAgaGFsZkZsb2F0VGV4VHlwZSxcbiAgICAgICAgICBzdXBwb3J0TGluZWFyRmlsdGVyaW5nLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0ZWRGb3JtYXQoXG4gICAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0IHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCxcbiAgICAgIGludGVybmFsRm9ybWF0OiBhbnksXG4gICAgICBmb3JtYXQ6IGFueSxcbiAgICAgIHR5cGU6IGFueVxuICAgICkge1xuICAgICAgaWYgKCFnbCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoIXN1cHBvcnRSZW5kZXJUZXh0dXJlRm9ybWF0KGdsLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlKSkge1xuICAgICAgICBzd2l0Y2ggKGludGVybmFsRm9ybWF0KSB7XG4gICAgICAgICAgY2FzZSAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuUjE2RjpcbiAgICAgICAgICAgIHJldHVybiBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5SRzE2RiwgKGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpLlJHLCB0eXBlKTtcbiAgICAgICAgICBjYXNlIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5SRzE2RjpcbiAgICAgICAgICAgIHJldHVybiBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5SR0JBMTZGLCAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuUkdCQSwgdHlwZSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgZm9ybWF0LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdXBwb3J0UmVuZGVyVGV4dHVyZUZvcm1hdChcbiAgICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LFxuICAgICAgaW50ZXJuYWxGb3JtYXQ6IGFueSxcbiAgICAgIGZvcm1hdDogYW55LFxuICAgICAgdHlwZTogYW55XG4gICAgKSB7XG4gICAgICBpZiAoIWdsKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgaWYgKCF0ZXh0dXJlKSByZXR1cm4gZmFsc2U7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICAwLFxuICAgICAgICBpbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgNCxcbiAgICAgICAgNCxcbiAgICAgICAgMCxcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgY29uc3QgZmJvID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIGlmICghZmJvKSByZXR1cm4gZmFsc2U7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZibyk7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICB0ZXh0dXJlLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgY29uc3Qgc3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XG4gICAgICByZXR1cm4gc3RhdHVzID09PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURTtcbiAgICB9XG5cbiAgICBjbGFzcyBNYXRlcmlhbCB7XG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGFueTtcbiAgICAgIGZyYWdtZW50U2hhZGVyU291cmNlOiBhbnk7XG4gICAgICBwcm9ncmFtczogYW55W107XG4gICAgICBhY3RpdmVQcm9ncmFtOiBhbnk7XG4gICAgICB1bmlmb3JtczogYW55W107XG4gICAgICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTaGFkZXI6IGFueSwgZnJhZ21lbnRTaGFkZXJTb3VyY2U6IGFueSkge1xuICAgICAgICB0aGlzLnZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlcjtcbiAgICAgICAgdGhpcy5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGZyYWdtZW50U2hhZGVyU291cmNlO1xuICAgICAgICB0aGlzLnByb2dyYW1zID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlUHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHNldEtleXdvcmRzKGtleXdvcmRzOiBhbnkpIHtcbiAgICAgICAgaWYgKCFnbCkgcmV0dXJuO1xuICAgICAgICBsZXQgaGFzaCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5d29yZHMubGVuZ3RoOyBpKyspIGhhc2ggKz0gaGFzaENvZGUoa2V5d29yZHNbaV0pO1xuICAgICAgICBsZXQgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbXNbaGFzaF07XG4gICAgICAgIGlmIChwcm9ncmFtID09IG51bGwpIHtcbiAgICAgICAgICBsZXQgZnJhZ21lbnRTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgICAgICAgZ2wgPyBnbC5GUkFHTUVOVF9TSEFERVIgOiAzNTYzMixcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRTaGFkZXJTb3VyY2UsXG4gICAgICAgICAgICBrZXl3b3Jkc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0odGhpcy52ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKTtcbiAgICAgICAgICB0aGlzLnByb2dyYW1zW2hhc2hdID0gcHJvZ3JhbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3JhbSA9PT0gdGhpcy5hY3RpdmVQcm9ncmFtKSByZXR1cm47XG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSBnZXRVbmlmb3Jtcyhwcm9ncmFtKTtcbiAgICAgICAgdGhpcy5hY3RpdmVQcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgIH1cbiAgICAgIGJpbmQoKSB7XG4gICAgICAgIGlmICghZ2wpIHJldHVybjtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLmFjdGl2ZVByb2dyYW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIFByb2dyYW0ge1xuICAgICAgdW5pZm9ybXM6IGFueTtcbiAgICAgIHByb2dyYW06IGFueTtcbiAgICAgIGNvbnN0cnVjdG9yKHZlcnRleFNoYWRlcjogYW55LCBmcmFnbWVudFNoYWRlcjogYW55KSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSB7fTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSh2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKTtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IGdldFVuaWZvcm1zKHRoaXMucHJvZ3JhbSk7XG4gICAgICB9XG4gICAgICBiaW5kKCkge1xuICAgICAgICBpZiAoIWdsKSByZXR1cm47XG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRVbmlmb3Jtcyhwcm9ncmFtOiBhbnkpOiBhbnkge1xuICAgICAgaWYgKCFnbCkgcmV0dXJuIFtdO1xuICAgICAgbGV0IHVuaWZvcm1zOiBSZWNvcmQ8c3RyaW5nLCBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB8IG51bGw+ID0ge307XG4gICAgICBsZXQgdW5pZm9ybUNvdW50ID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bmlmb3JtQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCB1bmlmb3JtSW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaSk7XG4gICAgICAgIGlmICghdW5pZm9ybUluZm8pIGNvbnRpbnVlO1xuICAgICAgICBsZXQgdW5pZm9ybU5hbWUgPSB1bmlmb3JtSW5mby5uYW1lO1xuICAgICAgICB1bmlmb3Jtc1t1bmlmb3JtTmFtZV0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuaWZvcm1zIGFzIGFueTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21waWxlU2hhZGVyKHR5cGU6IGFueSwgc291cmNlOiBhbnksIGtleXdvcmRzOiBhbnkpIHtcbiAgICAgIGlmICghZ2wpIHJldHVybiBudWxsO1xuICAgICAgc291cmNlID0gYWRkS2V5d29yZHMoc291cmNlLCBrZXl3b3JkcyB8fCBbXSk7XG4gICAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gICAgICBpZiAoIXNoYWRlcikgcmV0dXJuIG51bGw7XG4gICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpXG4gICAgICAgIGNvbnNvbGUudHJhY2UoZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSh2ZXJ0ZXhTaGFkZXI6IGFueSwgZnJhZ21lbnRTaGFkZXI6IGFueSkge1xuICAgICAgaWYgKCFnbCB8fCAhdmVydGV4U2hhZGVyIHx8ICFmcmFnbWVudFNoYWRlcikgcmV0dXJuIG51bGw7XG4gICAgICBsZXQgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgIGlmICghcHJvZ3JhbSkgcmV0dXJuIG51bGw7XG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyIGFzIFdlYkdMU2hhZGVyKTtcbiAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlciBhcyBXZWJHTFNoYWRlcik7XG4gICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpXG4gICAgICAgIGNvbnNvbGUudHJhY2UoZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkS2V5d29yZHMoc291cmNlOiBhbnksIGtleXdvcmRzOiBhbnkpIHtcbiAgICAgIGlmICgha2V5d29yZHMpIHJldHVybiBzb3VyY2U7XG4gICAgICBsZXQga2V5d29yZHNTdHJpbmcgPSBcIlwiO1xuICAgICAga2V5d29yZHMuZm9yRWFjaCgoa2V5d29yZDogYW55KSA9PiB7XG4gICAgICAgIGtleXdvcmRzU3RyaW5nICs9IFwiI2RlZmluZSBcIiArIGtleXdvcmQgKyBcIlxcblwiO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ga2V5d29yZHNTdHJpbmcgKyBzb3VyY2U7XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVZlcnRleFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbCA/IGdsLlZFUlRFWF9TSEFERVIgOiAzNTYzMyxcbiAgICAgIGBcbiAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgICAgICB2YXJ5aW5nIHZlYzIgdlQ7XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2QjtcbiAgICAgICAgdW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgdlV2ID0gYVBvc2l0aW9uICogMC41ICsgMC41O1xuICAgICAgICAgICAgdkwgPSB2VXYgLSB2ZWMyKHRleGVsU2l6ZS54LCAwLjApO1xuICAgICAgICAgICAgdlIgPSB2VXYgKyB2ZWMyKHRleGVsU2l6ZS54LCAwLjApO1xuICAgICAgICAgICAgdlQgPSB2VXYgKyB2ZWMyKDAuMCwgdGV4ZWxTaXplLnkpO1xuICAgICAgICAgICAgdkIgPSB2VXYgLSB2ZWMyKDAuMCwgdGV4ZWxTaXplLnkpO1xuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgICAgICB9XG4gICAgICBgLFxuICAgICAgW11cbiAgICApO1xuXG4gICAgY29uc3QgY29weVNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbCA/IGdsLkZSQUdNRU5UX1NIQURFUiA6IDM1NjMyLFxuICAgICAgYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpO1xuICAgICAgICB9XG4gICAgICBgLFxuICAgICAgW11cbiAgICApO1xuXG4gICAgY29uc3QgY2xlYXJTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wgPyBnbC5GUkFHTUVOVF9TSEFERVIgOiAzNTYzMixcbiAgICAgIGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdmFsdWU7XG5cbiAgICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZhbHVlICogdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpO1xuICAgICAgICB9XG4gICAgIGAsXG4gICAgICBbXVxuICAgICk7XG5cbiAgICBjb25zdCBkaXNwbGF5U2hhZGVyU291cmNlID0gYFxuICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgICB2YXJ5aW5nIHZlYzIgdlI7XG4gICAgICB2YXJ5aW5nIHZlYzIgdlQ7XG4gICAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVEaXRoZXJpbmc7XG4gICAgICB1bmlmb3JtIHZlYzIgZGl0aGVyU2NhbGU7XG4gICAgICB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xuXG4gICAgICB2ZWMzIGxpbmVhclRvR2FtbWEgKHZlYzMgY29sb3IpIHtcbiAgICAgICAgICBjb2xvciA9IG1heChjb2xvciwgdmVjMygwKSk7XG4gICAgICAgICAgcmV0dXJuIG1heCgxLjA1NSAqIHBvdyhjb2xvciwgdmVjMygwLjQxNjY2NjY2NykpIC0gMC4wNTUsIHZlYzMoMCkpO1xuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgIHZlYzMgYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KS5yZ2I7XG4gICAgICAgICAgI2lmZGVmIFNIQURJTkdcbiAgICAgICAgICAgICAgdmVjMyBsYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkwpLnJnYjtcbiAgICAgICAgICAgICAgdmVjMyByYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlIpLnJnYjtcbiAgICAgICAgICAgICAgdmVjMyB0YyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlQpLnJnYjtcbiAgICAgICAgICAgICAgdmVjMyBiYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkIpLnJnYjtcblxuICAgICAgICAgICAgICBmbG9hdCBkeCA9IGxlbmd0aChyYykgLSBsZW5ndGgobGMpO1xuICAgICAgICAgICAgICBmbG9hdCBkeSA9IGxlbmd0aCh0YykgLSBsZW5ndGgoYmMpO1xuXG4gICAgICAgICAgICAgIHZlYzMgbiA9IG5vcm1hbGl6ZSh2ZWMzKGR4LCBkeSwgbGVuZ3RoKHRleGVsU2l6ZSkpKTtcbiAgICAgICAgICAgICAgdmVjMyBsID0gdmVjMygwLjAsIDAuMCwgMS4wKTtcblxuICAgICAgICAgICAgICBmbG9hdCBkaWZmdXNlID0gY2xhbXAoZG90KG4sIGwpICsgMC43LCAwLjcsIDEuMCk7XG4gICAgICAgICAgICAgIGMgKj0gZGlmZnVzZTtcbiAgICAgICAgICAjZW5kaWZcblxuICAgICAgICAgIGZsb2F0IGEgPSBtYXgoYy5yLCBtYXgoYy5nLCBjLmIpKTtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGMsIGEpO1xuICAgICAgfVxuICAgIGA7XG5cbiAgICBjb25zdCBzcGxhdFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbCA/IGdsLkZSQUdNRU5UX1NIQURFUiA6IDM1NjMyLFxuICAgICAgYFxuICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUYXJnZXQ7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgYXNwZWN0UmF0aW87XG4gICAgICAgIHVuaWZvcm0gdmVjMyBjb2xvcjtcbiAgICAgICAgdW5pZm9ybSB2ZWMyIHBvaW50O1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgdmVjMiBwID0gdlV2IC0gcG9pbnQueHk7XG4gICAgICAgICAgICBwLnggKj0gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB2ZWMzIHNwbGF0ID0gZXhwKC1kb3QocCwgcCkgLyByYWRpdXMpICogY29sb3I7XG4gICAgICAgICAgICB2ZWMzIGJhc2UgPSB0ZXh0dXJlMkQodVRhcmdldCwgdlV2KS54eXo7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGJhc2UgKyBzcGxhdCwgMS4wKTtcbiAgICAgICAgfVxuICAgICAgYCxcbiAgICAgIFtdXG4gICAgKTtcblxuICAgIGNvbnN0IGFkdmVjdGlvblNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbCA/IGdsLkZSQUdNRU5UX1NIQURFUiA6IDM1NjMyLFxuICAgICAgYFxuICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNvdXJjZTtcbiAgICAgICAgdW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcbiAgICAgICAgdW5pZm9ybSB2ZWMyIGR5ZVRleGVsU2l6ZTtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBkdDtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBkaXNzaXBhdGlvbjtcblxuICAgICAgICB2ZWM0IGJpbGVycCAoc2FtcGxlcjJEIHNhbSwgdmVjMiB1diwgdmVjMiB0c2l6ZSkge1xuICAgICAgICAgICAgdmVjMiBzdCA9IHV2IC8gdHNpemUgLSAwLjU7XG4gICAgICAgICAgICB2ZWMyIGl1diA9IGZsb29yKHN0KTtcbiAgICAgICAgICAgIHZlYzIgZnV2ID0gZnJhY3Qoc3QpO1xuXG4gICAgICAgICAgICB2ZWM0IGEgPSB0ZXh0dXJlMkQoc2FtLCAoaXV2ICsgdmVjMigwLjUsIDAuNSkpICogdHNpemUpO1xuICAgICAgICAgICAgdmVjNCBiID0gdGV4dHVyZTJEKHNhbSwgKGl1diArIHZlYzIoMS41LCAwLjUpKSAqIHRzaXplKTtcbiAgICAgICAgICAgIHZlYzQgYyA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDAuNSwgMS41KSkgKiB0c2l6ZSk7XG4gICAgICAgICAgICB2ZWM0IGQgPSB0ZXh0dXJlMkQoc2FtLCAoaXV2ICsgdmVjMigxLjUsIDEuNSkpICogdHNpemUpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWl4KG1peChhLCBiLCBmdXYueCksIG1peChjLCBkLCBmdXYueCksIGZ1di55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgICAjaWZkZWYgTUFOVUFMX0ZJTFRFUklOR1xuICAgICAgICAgICAgICAgIHZlYzIgY29vcmQgPSB2VXYgLSBkdCAqIGJpbGVycCh1VmVsb2NpdHksIHZVdiwgdGV4ZWxTaXplKS54eSAqIHRleGVsU2l6ZTtcbiAgICAgICAgICAgICAgICB2ZWM0IHJlc3VsdCA9IGJpbGVycCh1U291cmNlLCBjb29yZCwgZHllVGV4ZWxTaXplKTtcbiAgICAgICAgICAgICNlbHNlXG4gICAgICAgICAgICAgICAgdmVjMiBjb29yZCA9IHZVdiAtIGR0ICogdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eSAqIHRleGVsU2l6ZTtcbiAgICAgICAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHRleHR1cmUyRCh1U291cmNlLCBjb29yZCk7XG4gICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAgIGZsb2F0IGRlY2F5ID0gMS4wICsgZGlzc2lwYXRpb24gKiBkdDtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHJlc3VsdCAvIGRlY2F5O1xuICAgICAgICB9XG4gICAgICBgLFxuICAgICAgZXh0ICYmIGV4dC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nID8gW10gOiBbXCJNQU5VQUxfRklMVEVSSU5HXCJdXG4gICAgKTtcblxuICAgIGNvbnN0IGRpdmVyZ2VuY2VTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wgPyBnbC5GUkFHTUVOVF9TSEFERVIgOiAzNTYzMixcbiAgICAgIGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG5cbiAgICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICAgIGZsb2F0IEwgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2TCkueDtcbiAgICAgICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2UikueDtcbiAgICAgICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VCkueTtcbiAgICAgICAgICAgIGZsb2F0IEIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2QikueTtcblxuICAgICAgICAgICAgdmVjMiBDID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eTtcbiAgICAgICAgICAgIGlmICh2TC54IDwgMC4wKSB7IEwgPSAtQy54OyB9XG4gICAgICAgICAgICBpZiAodlIueCA+IDEuMCkgeyBSID0gLUMueDsgfVxuICAgICAgICAgICAgaWYgKHZULnkgPiAxLjApIHsgVCA9IC1DLnk7IH1cbiAgICAgICAgICAgIGlmICh2Qi55IDwgMC4wKSB7IEIgPSAtQy55OyB9XG5cbiAgICAgICAgICAgIGZsb2F0IGRpdiA9IDAuNSAqIChSIC0gTCArIFQgLSBCKTtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZGl2LCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgfVxuICAgICAgYCxcbiAgICAgIFtdXG4gICAgKTtcblxuICAgIGNvbnN0IGN1cmxTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wgPyBnbC5GUkFHTUVOVF9TSEFERVIgOiAzNTYzMixcbiAgICAgIGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG5cbiAgICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICAgIGZsb2F0IEwgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2TCkueTtcbiAgICAgICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2UikueTtcbiAgICAgICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VCkueDtcbiAgICAgICAgICAgIGZsb2F0IEIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2QikueDtcbiAgICAgICAgICAgIGZsb2F0IHZvcnRpY2l0eSA9IFIgLSBMIC0gVCArIEI7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuNSAqIHZvcnRpY2l0eSwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICAgIH1cbiAgICAgIGAsXG4gICAgICBbXVxuICAgICk7XG5cbiAgICBjb25zdCB2b3J0aWNpdHlTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wgPyBnbC5GUkFHTUVOVF9TSEFERVIgOiAzNTYzMixcbiAgICAgIGBcbiAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgICAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2UjtcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZUO1xuICAgICAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdUN1cmw7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgY3VybDtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBkdDtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1Q3VybCwgdkwpLng7XG4gICAgICAgICAgICBmbG9hdCBSID0gdGV4dHVyZTJEKHVDdXJsLCB2UikueDtcbiAgICAgICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodUN1cmwsIHZUKS54O1xuICAgICAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1Q3VybCwgdkIpLng7XG4gICAgICAgICAgICBmbG9hdCBDID0gdGV4dHVyZTJEKHVDdXJsLCB2VXYpLng7XG5cbiAgICAgICAgICAgIHZlYzIgZm9yY2UgPSAwLjUgKiB2ZWMyKGFicyhUKSAtIGFicyhCKSwgYWJzKFIpIC0gYWJzKEwpKTtcbiAgICAgICAgICAgIGZvcmNlIC89IGxlbmd0aChmb3JjZSkgKyAwLjAwMDE7XG4gICAgICAgICAgICBmb3JjZSAqPSBjdXJsICogQztcbiAgICAgICAgICAgIGZvcmNlLnkgKj0gLTEuMDtcblxuICAgICAgICAgICAgdmVjMiB2ZWxvY2l0eSA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZVdikueHk7XG4gICAgICAgICAgICB2ZWxvY2l0eSArPSBmb3JjZSAqIGR0O1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBtaW4obWF4KHZlbG9jaXR5LCAtMTAwMC4wKSwgMTAwMC4wKTtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVsb2NpdHksIDAuMCwgMS4wKTtcbiAgICAgICAgfVxuICAgICAgYCxcbiAgICAgIFtdXG4gICAgKTtcblxuICAgIGNvbnN0IHByZXNzdXJlU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsID8gZ2wuRlJBR01FTlRfU0hBREVSIDogMzU2MzIsXG4gICAgICBgXG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2TDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZSO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlQ7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2QjtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVByZXNzdXJlO1xuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1RGl2ZXJnZW5jZTtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZMKS54O1xuICAgICAgICAgICAgZmxvYXQgUiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZSKS54O1xuICAgICAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZUKS54O1xuICAgICAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZCKS54O1xuICAgICAgICAgICAgZmxvYXQgQyA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZVdikueDtcbiAgICAgICAgICAgIGZsb2F0IGRpdmVyZ2VuY2UgPSB0ZXh0dXJlMkQodURpdmVyZ2VuY2UsIHZVdikueDtcbiAgICAgICAgICAgIGZsb2F0IHByZXNzdXJlID0gKEwgKyBSICsgQiArIFQgLSBkaXZlcmdlbmNlKSAqIDAuMjU7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHByZXNzdXJlLCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgfVxuICAgICAgYCxcbiAgICAgIFtdXG4gICAgKTtcblxuICAgIGNvbnN0IGdyYWRpZW50U3VidHJhY3RTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wgPyBnbC5GUkFHTUVOVF9TSEFERVIgOiAzNTYzMixcbiAgICAgIGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1UHJlc3N1cmU7XG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZMKS54O1xuICAgICAgICAgICAgZmxvYXQgUiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZSKS54O1xuICAgICAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZUKS54O1xuICAgICAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZCKS54O1xuICAgICAgICAgICAgdmVjMiB2ZWxvY2l0eSA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZVdikueHk7XG4gICAgICAgICAgICB2ZWxvY2l0eS54eSAtPSB2ZWMyKFIgLSBMLCBUIC0gQik7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlbG9jaXR5LCAwLjAsIDEuMCk7XG4gICAgICAgIH1cbiAgICAgIGAsXG4gICAgICBbXVxuICAgICk7XG5cbiAgICBjb25zdCBibGl0ID0gKCgpID0+IHtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBnbC5jcmVhdGVCdWZmZXIoKSk7XG4gICAgICBnbC5idWZmZXJEYXRhKFxuICAgICAgICBnbC5BUlJBWV9CVUZGRVIsXG4gICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAtMSwgLTEsIDEsIDEsIDEsIDEsIC0xXSksXG4gICAgICAgIGdsLlNUQVRJQ19EUkFXXG4gICAgICApO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShcbiAgICAgICAgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsXG4gICAgICAgIG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMCwgMiwgM10pLFxuICAgICAgICBnbC5TVEFUSUNfRFJBV1xuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoMCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KDApO1xuICAgICAgcmV0dXJuICh0YXJnZXQsIGNsZWFyID0gZmFsc2UpID0+IHtcbiAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRhcmdldC53aWR0aCwgdGFyZ2V0LmhlaWdodCk7XG4gICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0YXJnZXQuZmJvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xlYXIpIHtcbiAgICAgICAgICBnbC5jbGVhckNvbG9yKDAuMCwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgbGV0IGR5ZSwgdmVsb2NpdHksIGRpdmVyZ2VuY2UsIGN1cmwsIHByZXNzdXJlO1xuXG4gICAgY29uc3QgY29weVByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBjb3B5U2hhZGVyKTtcbiAgICBjb25zdCBjbGVhclByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBjbGVhclNoYWRlcik7XG4gICAgY29uc3Qgc3BsYXRQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgc3BsYXRTaGFkZXIpO1xuICAgIGNvbnN0IGFkdmVjdGlvblByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBhZHZlY3Rpb25TaGFkZXIpO1xuICAgIGNvbnN0IGRpdmVyZ2VuY2VQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgZGl2ZXJnZW5jZVNoYWRlcik7XG4gICAgY29uc3QgY3VybFByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBjdXJsU2hhZGVyKTtcbiAgICBjb25zdCB2b3J0aWNpdHlQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgdm9ydGljaXR5U2hhZGVyKTtcbiAgICBjb25zdCBwcmVzc3VyZVByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBwcmVzc3VyZVNoYWRlcik7XG4gICAgY29uc3QgZ3JhZGllblN1YnRyYWN0UHJvZ3JhbSA9IG5ldyBQcm9ncmFtKFxuICAgICAgYmFzZVZlcnRleFNoYWRlcixcbiAgICAgIGdyYWRpZW50U3VidHJhY3RTaGFkZXJcbiAgICApO1xuICAgIGNvbnN0IGRpc3BsYXlNYXRlcmlhbCA9IG5ldyBNYXRlcmlhbChiYXNlVmVydGV4U2hhZGVyLCBkaXNwbGF5U2hhZGVyU291cmNlKTtcblxuICAgIGZ1bmN0aW9uIGluaXRGcmFtZWJ1ZmZlcnMoKSB7XG4gICAgICBsZXQgc2ltUmVzID0gZ2V0UmVzb2x1dGlvbihjb25maWcuU0lNX1JFU09MVVRJT04pO1xuICAgICAgbGV0IGR5ZVJlcyA9IGdldFJlc29sdXRpb24oY29uZmlnLkRZRV9SRVNPTFVUSU9OKTtcbiAgICAgIGNvbnN0IHRleFR5cGUgPSBleHQuaGFsZkZsb2F0VGV4VHlwZTtcbiAgICAgIGNvbnN0IHJnYmEgPSBleHQuZm9ybWF0UkdCQTtcbiAgICAgIGNvbnN0IHJnID0gZXh0LmZvcm1hdFJHO1xuICAgICAgY29uc3QgciA9IGV4dC5mb3JtYXRSO1xuICAgICAgY29uc3QgZmlsdGVyaW5nID0gZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUO1xuICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG5cbiAgICAgIGlmICghZHllKVxuICAgICAgICBkeWUgPSBjcmVhdGVEb3VibGVGQk8oXG4gICAgICAgICAgZHllUmVzLndpZHRoLFxuICAgICAgICAgIGR5ZVJlcy5oZWlnaHQsXG4gICAgICAgICAgcmdiYS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgICByZ2JhLmZvcm1hdCxcbiAgICAgICAgICB0ZXhUeXBlLFxuICAgICAgICAgIGZpbHRlcmluZ1xuICAgICAgICApO1xuICAgICAgZWxzZVxuICAgICAgICBkeWUgPSByZXNpemVEb3VibGVGQk8oXG4gICAgICAgICAgZHllLFxuICAgICAgICAgIGR5ZVJlcy53aWR0aCxcbiAgICAgICAgICBkeWVSZXMuaGVpZ2h0LFxuICAgICAgICAgIHJnYmEuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgICAgcmdiYS5mb3JtYXQsXG4gICAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgICBmaWx0ZXJpbmdcbiAgICAgICAgKTtcblxuICAgICAgaWYgKCF2ZWxvY2l0eSlcbiAgICAgICAgdmVsb2NpdHkgPSBjcmVhdGVEb3VibGVGQk8oXG4gICAgICAgICAgc2ltUmVzLndpZHRoLFxuICAgICAgICAgIHNpbVJlcy5oZWlnaHQsXG4gICAgICAgICAgcmcuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgICAgcmcuZm9ybWF0LFxuICAgICAgICAgIHRleFR5cGUsXG4gICAgICAgICAgZmlsdGVyaW5nXG4gICAgICAgICk7XG4gICAgICBlbHNlXG4gICAgICAgIHZlbG9jaXR5ID0gcmVzaXplRG91YmxlRkJPKFxuICAgICAgICAgIHZlbG9jaXR5LFxuICAgICAgICAgIHNpbVJlcy53aWR0aCxcbiAgICAgICAgICBzaW1SZXMuaGVpZ2h0LFxuICAgICAgICAgIHJnLmludGVybmFsRm9ybWF0LFxuICAgICAgICAgIHJnLmZvcm1hdCxcbiAgICAgICAgICB0ZXhUeXBlLFxuICAgICAgICAgIGZpbHRlcmluZ1xuICAgICAgICApO1xuXG4gICAgICBkaXZlcmdlbmNlID0gY3JlYXRlRkJPKFxuICAgICAgICBzaW1SZXMud2lkdGgsXG4gICAgICAgIHNpbVJlcy5oZWlnaHQsXG4gICAgICAgIHIuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgIHIuZm9ybWF0LFxuICAgICAgICB0ZXhUeXBlLFxuICAgICAgICBnbC5ORUFSRVNUXG4gICAgICApO1xuICAgICAgY3VybCA9IGNyZWF0ZUZCTyhcbiAgICAgICAgc2ltUmVzLndpZHRoLFxuICAgICAgICBzaW1SZXMuaGVpZ2h0LFxuICAgICAgICByLmludGVybmFsRm9ybWF0LFxuICAgICAgICByLmZvcm1hdCxcbiAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgZ2wuTkVBUkVTVFxuICAgICAgKTtcbiAgICAgIHByZXNzdXJlID0gY3JlYXRlRG91YmxlRkJPKFxuICAgICAgICBzaW1SZXMud2lkdGgsXG4gICAgICAgIHNpbVJlcy5oZWlnaHQsXG4gICAgICAgIHIuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgIHIuZm9ybWF0LFxuICAgICAgICB0ZXhUeXBlLFxuICAgICAgICBnbC5ORUFSRVNUXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSkge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICBsZXQgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHBhcmFtKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBwYXJhbSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgMCxcbiAgICAgICAgaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgIHcsXG4gICAgICAgIGgsXG4gICAgICAgIDAsXG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcblxuICAgICAgbGV0IGZibyA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZibyk7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICB0ZXh0dXJlLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdywgaCk7XG4gICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcblxuICAgICAgbGV0IHRleGVsU2l6ZVggPSAxLjAgLyB3O1xuICAgICAgbGV0IHRleGVsU2l6ZVkgPSAxLjAgLyBoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dHVyZSxcbiAgICAgICAgZmJvLFxuICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICB0ZXhlbFNpemVYLFxuICAgICAgICB0ZXhlbFNpemVZLFxuICAgICAgICBhdHRhY2goaWQpIHtcbiAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgaWQpO1xuICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRG91YmxlRkJPKHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKSB7XG4gICAgICBsZXQgZmJvMSA9IGNyZWF0ZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSk7XG4gICAgICBsZXQgZmJvMiA9IGNyZWF0ZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICB0ZXhlbFNpemVYOiBmYm8xLnRleGVsU2l6ZVgsXG4gICAgICAgIHRleGVsU2l6ZVk6IGZibzEudGV4ZWxTaXplWSxcbiAgICAgICAgZ2V0IHJlYWQoKSB7XG4gICAgICAgICAgcmV0dXJuIGZibzE7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCByZWFkKHZhbHVlKSB7XG4gICAgICAgICAgZmJvMSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgd3JpdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIGZibzI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCB3cml0ZSh2YWx1ZSkge1xuICAgICAgICAgIGZibzIgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc3dhcCgpIHtcbiAgICAgICAgICBsZXQgdGVtcCA9IGZibzE7XG4gICAgICAgICAgZmJvMSA9IGZibzI7XG4gICAgICAgICAgZmJvMiA9IHRlbXA7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZUZCTyh0YXJnZXQsIHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKSB7XG4gICAgICBsZXQgbmV3RkJPID0gY3JlYXRlRkJPKHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKTtcbiAgICAgIGNvcHlQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGdsLnVuaWZvcm0xaShjb3B5UHJvZ3JhbS51bmlmb3Jtcy51VGV4dHVyZSwgdGFyZ2V0LmF0dGFjaCgwKSk7XG4gICAgICBibGl0KG5ld0ZCTyk7XG4gICAgICByZXR1cm4gbmV3RkJPO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZURvdWJsZUZCTyhcbiAgICAgIHRhcmdldCxcbiAgICAgIHcsXG4gICAgICBoLFxuICAgICAgaW50ZXJuYWxGb3JtYXQsXG4gICAgICBmb3JtYXQsXG4gICAgICB0eXBlLFxuICAgICAgcGFyYW1cbiAgICApIHtcbiAgICAgIGlmICh0YXJnZXQud2lkdGggPT09IHcgJiYgdGFyZ2V0LmhlaWdodCA9PT0gaCkgcmV0dXJuIHRhcmdldDtcbiAgICAgIHRhcmdldC5yZWFkID0gcmVzaXplRkJPKFxuICAgICAgICB0YXJnZXQucmVhZCxcbiAgICAgICAgdyxcbiAgICAgICAgaCxcbiAgICAgICAgaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGFyYW1cbiAgICAgICk7XG4gICAgICB0YXJnZXQud3JpdGUgPSBjcmVhdGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pO1xuICAgICAgdGFyZ2V0LndpZHRoID0gdztcbiAgICAgIHRhcmdldC5oZWlnaHQgPSBoO1xuICAgICAgdGFyZ2V0LnRleGVsU2l6ZVggPSAxLjAgLyB3O1xuICAgICAgdGFyZ2V0LnRleGVsU2l6ZVkgPSAxLjAgLyBoO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVLZXl3b3JkcygpIHtcbiAgICAgIGxldCBkaXNwbGF5S2V5d29yZHMgPSBbXTtcbiAgICAgIGlmIChjb25maWcuU0hBRElORykgZGlzcGxheUtleXdvcmRzLnB1c2goXCJTSEFESU5HXCIpO1xuICAgICAgZGlzcGxheU1hdGVyaWFsLnNldEtleXdvcmRzKGRpc3BsYXlLZXl3b3Jkcyk7XG4gICAgfVxuXG4gICAgdXBkYXRlS2V5d29yZHMoKTtcbiAgICBpbml0RnJhbWVidWZmZXJzKCk7XG4gICAgbGV0IGxhc3RVcGRhdGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgY29sb3JVcGRhdGVUaW1lciA9IDAuMDtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUZyYW1lKCkge1xuICAgICAgY29uc3QgZHQgPSBjYWxjRGVsdGFUaW1lKCk7XG4gICAgICBpZiAocmVzaXplQ2FudmFzKCkpIGluaXRGcmFtZWJ1ZmZlcnMoKTtcbiAgICAgIHVwZGF0ZUNvbG9ycyhkdCk7XG4gICAgICBhcHBseUlucHV0cygpO1xuICAgICAgc3RlcChkdCk7XG4gICAgICByZW5kZXIobnVsbCk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlRnJhbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGNEZWx0YVRpbWUoKSB7XG4gICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGxldCBkdCA9IChub3cgLSBsYXN0VXBkYXRlVGltZSkgLyAxMDAwO1xuICAgICAgZHQgPSBNYXRoLm1pbihkdCwgMC4wMTY2NjYpO1xuICAgICAgbGFzdFVwZGF0ZVRpbWUgPSBub3c7XG4gICAgICByZXR1cm4gZHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplQ2FudmFzKCkge1xuICAgICAgbGV0IHdpZHRoID0gc2NhbGVCeVBpeGVsUmF0aW8oY2FudmFzLmNsaWVudFdpZHRoKTtcbiAgICAgIGxldCBoZWlnaHQgPSBzY2FsZUJ5UGl4ZWxSYXRpbyhjYW52YXMuY2xpZW50SGVpZ2h0KTtcbiAgICAgIGlmIChjYW52YXMud2lkdGggIT09IHdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ29sb3JzKGR0KSB7XG4gICAgICBjb2xvclVwZGF0ZVRpbWVyICs9IGR0ICogY29uZmlnLkNPTE9SX1VQREFURV9TUEVFRDtcbiAgICAgIGlmIChjb2xvclVwZGF0ZVRpbWVyID49IDEpIHtcbiAgICAgICAgY29sb3JVcGRhdGVUaW1lciA9IHdyYXAoY29sb3JVcGRhdGVUaW1lciwgMCwgMSk7XG4gICAgICAgIHBvaW50ZXJzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICBwLmNvbG9yID0gZ2VuZXJhdGVDb2xvcigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseUlucHV0cygpIHtcbiAgICAgIHBvaW50ZXJzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgaWYgKHAubW92ZWQpIHtcbiAgICAgICAgICBwLm1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgc3BsYXRQb2ludGVyKHApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGVwKGR0KSB7XG4gICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICAgIC8vIEN1cmxcbiAgICAgIGN1cmxQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGdsLnVuaWZvcm0yZihcbiAgICAgICAgY3VybFByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFpKGN1cmxQcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSwgdmVsb2NpdHkucmVhZC5hdHRhY2goMCkpO1xuICAgICAgYmxpdChjdXJsKTtcblxuICAgICAgLy8gVm9ydGljaXR5XG4gICAgICB2b3J0aWNpdHlQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGdsLnVuaWZvcm0yZihcbiAgICAgICAgdm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWkoXG4gICAgICAgIHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LFxuICAgICAgICB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgwKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xaSh2b3J0aWNpdHlQcm9ncmFtLnVuaWZvcm1zLnVDdXJsLCBjdXJsLmF0dGFjaCgxKSk7XG4gICAgICBnbC51bmlmb3JtMWYodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy5jdXJsLCBjb25maWcuQ1VSTCk7XG4gICAgICBnbC51bmlmb3JtMWYodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy5kdCwgZHQpO1xuICAgICAgYmxpdCh2ZWxvY2l0eS53cml0ZSk7XG4gICAgICB2ZWxvY2l0eS5zd2FwKCk7XG5cbiAgICAgIC8vIERpdmVyZ2VuY2VcbiAgICAgIGRpdmVyZ2VuY2VQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGdsLnVuaWZvcm0yZihcbiAgICAgICAgZGl2ZXJnZW5jZVByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFpKFxuICAgICAgICBkaXZlcmdlbmNlUHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksXG4gICAgICAgIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApXG4gICAgICApO1xuICAgICAgYmxpdChkaXZlcmdlbmNlKTtcblxuICAgICAgLy8gQ2xlYXIgcHJlc3N1cmVcbiAgICAgIGNsZWFyUHJvZ3JhbS5iaW5kKCk7XG4gICAgICBnbC51bmlmb3JtMWkoY2xlYXJQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCBwcmVzc3VyZS5yZWFkLmF0dGFjaCgwKSk7XG4gICAgICBnbC51bmlmb3JtMWYoY2xlYXJQcm9ncmFtLnVuaWZvcm1zLnZhbHVlLCBjb25maWcuUFJFU1NVUkUpO1xuICAgICAgYmxpdChwcmVzc3VyZS53cml0ZSk7XG4gICAgICBwcmVzc3VyZS5zd2FwKCk7XG5cbiAgICAgIC8vIFByZXNzdXJlXG4gICAgICBwcmVzc3VyZVByb2dyYW0uYmluZCgpO1xuICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICBwcmVzc3VyZVByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFpKHByZXNzdXJlUHJvZ3JhbS51bmlmb3Jtcy51RGl2ZXJnZW5jZSwgZGl2ZXJnZW5jZS5hdHRhY2goMCkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25maWcuUFJFU1NVUkVfSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xaShcbiAgICAgICAgICBwcmVzc3VyZVByb2dyYW0udW5pZm9ybXMudVByZXNzdXJlLFxuICAgICAgICAgIHByZXNzdXJlLnJlYWQuYXR0YWNoKDEpXG4gICAgICAgICk7XG4gICAgICAgIGJsaXQocHJlc3N1cmUud3JpdGUpO1xuICAgICAgICBwcmVzc3VyZS5zd2FwKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdyYWRpZW50IFN1YnRyYWN0XG4gICAgICBncmFkaWVuU3VidHJhY3RQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGdsLnVuaWZvcm0yZihcbiAgICAgICAgZ3JhZGllblN1YnRyYWN0UHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWkoXG4gICAgICAgIGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0udW5pZm9ybXMudVByZXNzdXJlLFxuICAgICAgICBwcmVzc3VyZS5yZWFkLmF0dGFjaCgwKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xaShcbiAgICAgICAgZ3JhZGllblN1YnRyYWN0UHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksXG4gICAgICAgIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDEpXG4gICAgICApO1xuICAgICAgYmxpdCh2ZWxvY2l0eS53cml0ZSk7XG4gICAgICB2ZWxvY2l0eS5zd2FwKCk7XG5cbiAgICAgIC8vIEFkdmVjdGlvblxuICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS5iaW5kKCk7XG4gICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICAgICApO1xuICAgICAgaWYgKCFleHQuc3VwcG9ydExpbmVhckZpbHRlcmluZylcbiAgICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZHllVGV4ZWxTaXplLFxuICAgICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICAgICAgICApO1xuICAgICAgbGV0IHZlbG9jaXR5SWQgPSB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgwKTtcbiAgICAgIGdsLnVuaWZvcm0xaShhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSwgdmVsb2NpdHlJZCk7XG4gICAgICBnbC51bmlmb3JtMWkoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy51U291cmNlLCB2ZWxvY2l0eUlkKTtcbiAgICAgIGdsLnVuaWZvcm0xZihhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmR0LCBkdCk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZGlzc2lwYXRpb24sXG4gICAgICAgIGNvbmZpZy5WRUxPQ0lUWV9ESVNTSVBBVElPTlxuICAgICAgKTtcbiAgICAgIGJsaXQodmVsb2NpdHkud3JpdGUpO1xuICAgICAgdmVsb2NpdHkuc3dhcCgpO1xuXG4gICAgICBpZiAoIWV4dC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nKVxuICAgICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5keWVUZXhlbFNpemUsXG4gICAgICAgICAgZHllLnRleGVsU2l6ZVgsXG4gICAgICAgICAgZHllLnRleGVsU2l6ZVlcbiAgICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xaShcbiAgICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksXG4gICAgICAgIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFpKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVNvdXJjZSwgZHllLnJlYWQuYXR0YWNoKDEpKTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5kaXNzaXBhdGlvbixcbiAgICAgICAgY29uZmlnLkRFTlNJVFlfRElTU0lQQVRJT05cbiAgICAgICk7XG4gICAgICBibGl0KGR5ZS53cml0ZSk7XG4gICAgICBkeWUuc3dhcCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlcih0YXJnZXQpIHtcbiAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgIGRyYXdEaXNwbGF5KHRhcmdldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0Rpc3BsYXkodGFyZ2V0KSB7XG4gICAgICBsZXQgd2lkdGggPSB0YXJnZXQgPT0gbnVsbCA/IGdsLmRyYXdpbmdCdWZmZXJXaWR0aCA6IHRhcmdldC53aWR0aDtcbiAgICAgIGxldCBoZWlnaHQgPSB0YXJnZXQgPT0gbnVsbCA/IGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQgOiB0YXJnZXQuaGVpZ2h0O1xuICAgICAgZGlzcGxheU1hdGVyaWFsLmJpbmQoKTtcbiAgICAgIGlmIChjb25maWcuU0hBRElORylcbiAgICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICAgIGRpc3BsYXlNYXRlcmlhbC51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgICAgICAgMS4wIC8gd2lkdGgsXG4gICAgICAgICAgMS4wIC8gaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWkoZGlzcGxheU1hdGVyaWFsLnVuaWZvcm1zLnVUZXh0dXJlLCBkeWUucmVhZC5hdHRhY2goMCkpO1xuICAgICAgYmxpdCh0YXJnZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNwbGF0UG9pbnRlcihwb2ludGVyKSB7XG4gICAgICBsZXQgZHggPSBwb2ludGVyLmRlbHRhWCAqIGNvbmZpZy5TUExBVF9GT1JDRTtcbiAgICAgIGxldCBkeSA9IHBvaW50ZXIuZGVsdGFZICogY29uZmlnLlNQTEFUX0ZPUkNFO1xuICAgICAgc3BsYXQocG9pbnRlci50ZXhjb29yZFgsIHBvaW50ZXIudGV4Y29vcmRZLCBkeCwgZHksIHBvaW50ZXIuY29sb3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsaWNrU3BsYXQocG9pbnRlcikge1xuICAgICAgY29uc3QgY29sb3IgPSBnZW5lcmF0ZUNvbG9yKCk7XG4gICAgICBjb2xvci5yICo9IDEwLjA7XG4gICAgICBjb2xvci5nICo9IDEwLjA7XG4gICAgICBjb2xvci5iICo9IDEwLjA7XG4gICAgICBsZXQgZHggPSAxMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KTtcbiAgICAgIGxldCBkeSA9IDMwICogKE1hdGgucmFuZG9tKCkgLSAwLjUpO1xuICAgICAgc3BsYXQocG9pbnRlci50ZXhjb29yZFgsIHBvaW50ZXIudGV4Y29vcmRZLCBkeCwgZHksIGNvbG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGxhdCh4LCB5LCBkeCwgZHksIGNvbG9yKSB7XG4gICAgICBzcGxhdFByb2dyYW0uYmluZCgpO1xuICAgICAgZ2wudW5pZm9ybTFpKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy51VGFyZ2V0LCB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgwKSk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5hc3BlY3RSYXRpbyxcbiAgICAgICAgY2FudmFzLndpZHRoIC8gY2FudmFzLmhlaWdodFxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0yZihzcGxhdFByb2dyYW0udW5pZm9ybXMucG9pbnQsIHgsIHkpO1xuICAgICAgZ2wudW5pZm9ybTNmKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5jb2xvciwgZHgsIGR5LCAwLjApO1xuICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICBzcGxhdFByb2dyYW0udW5pZm9ybXMucmFkaXVzLFxuICAgICAgICBjb3JyZWN0UmFkaXVzKGNvbmZpZy5TUExBVF9SQURJVVMgLyAxMDAuMClcbiAgICAgICk7XG4gICAgICBibGl0KHZlbG9jaXR5LndyaXRlKTtcbiAgICAgIHZlbG9jaXR5LnN3YXAoKTtcblxuICAgICAgZ2wudW5pZm9ybTFpKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy51VGFyZ2V0LCBkeWUucmVhZC5hdHRhY2goMCkpO1xuICAgICAgZ2wudW5pZm9ybTNmKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5jb2xvciwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gICAgICBibGl0KGR5ZS53cml0ZSk7XG4gICAgICBkeWUuc3dhcCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvcnJlY3RSYWRpdXMocmFkaXVzKSB7XG4gICAgICBsZXQgYXNwZWN0UmF0aW8gPSBjYW52YXMud2lkdGggLyBjYW52YXMuaGVpZ2h0O1xuICAgICAgaWYgKGFzcGVjdFJhdGlvID4gMSkgcmFkaXVzICo9IGFzcGVjdFJhdGlvO1xuICAgICAgcmV0dXJuIHJhZGl1cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQb2ludGVyRG93bkRhdGEocG9pbnRlciwgaWQsIHBvc1gsIHBvc1kpIHtcbiAgICAgIHBvaW50ZXIuaWQgPSBpZDtcbiAgICAgIHBvaW50ZXIuZG93biA9IHRydWU7XG4gICAgICBwb2ludGVyLm1vdmVkID0gZmFsc2U7XG4gICAgICBwb2ludGVyLnRleGNvb3JkWCA9IHBvc1ggLyBjYW52YXMud2lkdGg7XG4gICAgICBwb2ludGVyLnRleGNvb3JkWSA9IDEuMCAtIHBvc1kgLyBjYW52YXMuaGVpZ2h0O1xuICAgICAgcG9pbnRlci5wcmV2VGV4Y29vcmRYID0gcG9pbnRlci50ZXhjb29yZFg7XG4gICAgICBwb2ludGVyLnByZXZUZXhjb29yZFkgPSBwb2ludGVyLnRleGNvb3JkWTtcbiAgICAgIHBvaW50ZXIuZGVsdGFYID0gMDtcbiAgICAgIHBvaW50ZXIuZGVsdGFZID0gMDtcbiAgICAgIHBvaW50ZXIuY29sb3IgPSBnZW5lcmF0ZUNvbG9yKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1ksIGNvbG9yKSB7XG4gICAgICBwb2ludGVyLnByZXZUZXhjb29yZFggPSBwb2ludGVyLnRleGNvb3JkWDtcbiAgICAgIHBvaW50ZXIucHJldlRleGNvb3JkWSA9IHBvaW50ZXIudGV4Y29vcmRZO1xuICAgICAgcG9pbnRlci50ZXhjb29yZFggPSBwb3NYIC8gY2FudmFzLndpZHRoO1xuICAgICAgcG9pbnRlci50ZXhjb29yZFkgPSAxLjAgLSBwb3NZIC8gY2FudmFzLmhlaWdodDtcbiAgICAgIHBvaW50ZXIuZGVsdGFYID0gY29ycmVjdERlbHRhWChwb2ludGVyLnRleGNvb3JkWCAtIHBvaW50ZXIucHJldlRleGNvb3JkWCk7XG4gICAgICBwb2ludGVyLmRlbHRhWSA9IGNvcnJlY3REZWx0YVkocG9pbnRlci50ZXhjb29yZFkgLSBwb2ludGVyLnByZXZUZXhjb29yZFkpO1xuICAgICAgcG9pbnRlci5tb3ZlZCA9XG4gICAgICAgIE1hdGguYWJzKHBvaW50ZXIuZGVsdGFYKSA+IDAgfHwgTWF0aC5hYnMocG9pbnRlci5kZWx0YVkpID4gMDtcbiAgICAgIHBvaW50ZXIuY29sb3IgPSBjb2xvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQb2ludGVyVXBEYXRhKHBvaW50ZXIpIHtcbiAgICAgIHBvaW50ZXIuZG93biA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvcnJlY3REZWx0YVgoZGVsdGEpIHtcbiAgICAgIGxldCBhc3BlY3RSYXRpbyA9IGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHQ7XG4gICAgICBpZiAoYXNwZWN0UmF0aW8gPCAxKSBkZWx0YSAqPSBhc3BlY3RSYXRpbztcbiAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3JyZWN0RGVsdGFZKGRlbHRhKSB7XG4gICAgICBsZXQgYXNwZWN0UmF0aW8gPSBjYW52YXMud2lkdGggLyBjYW52YXMuaGVpZ2h0O1xuICAgICAgaWYgKGFzcGVjdFJhdGlvID4gMSkgZGVsdGEgLz0gYXNwZWN0UmF0aW87XG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDb2xvcigpIHtcbiAgICAgIGxldCBjID0gSFNWdG9SR0IoTWF0aC5yYW5kb20oKSwgMS4wLCAxLjApO1xuICAgICAgYy5yICo9IDAuMTU7XG4gICAgICBjLmcgKj0gMC4xNTtcbiAgICAgIGMuYiAqPSAwLjE1O1xuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSFNWdG9SR0IoaCwgcywgdikge1xuICAgICAgbGV0IHIsIGcsIGIsIGksIGYsIHAsIHEsIHQ7XG4gICAgICBpID0gTWF0aC5mbG9vcihoICogNik7XG4gICAgICBmID0gaCAqIDYgLSBpO1xuICAgICAgcCA9IHYgKiAoMSAtIHMpO1xuICAgICAgcSA9IHYgKiAoMSAtIGYgKiBzKTtcbiAgICAgIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG4gICAgICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByID0gdjtcbiAgICAgICAgICBnID0gdDtcbiAgICAgICAgICBiID0gcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHIgPSBxO1xuICAgICAgICAgIGcgPSB2O1xuICAgICAgICAgIGIgPSBwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgciA9IHA7XG4gICAgICAgICAgZyA9IHY7XG4gICAgICAgICAgYiA9IHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByID0gcDtcbiAgICAgICAgICBnID0gcTtcbiAgICAgICAgICBiID0gdjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgIGcgPSBwO1xuICAgICAgICAgIGIgPSB2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgciA9IHY7XG4gICAgICAgICAgZyA9IHA7XG4gICAgICAgICAgYiA9IHE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4geyByLCBnLCBiIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuICAgICAgaWYgKHJhbmdlID09PSAwKSByZXR1cm4gbWluO1xuICAgICAgcmV0dXJuICgodmFsdWUgLSBtaW4pICUgcmFuZ2UpICsgbWluO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJlc29sdXRpb24ocmVzb2x1dGlvbikge1xuICAgICAgbGV0IGFzcGVjdFJhdGlvID0gZ2wuZHJhd2luZ0J1ZmZlcldpZHRoIC8gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodDtcbiAgICAgIGlmIChhc3BlY3RSYXRpbyA8IDEpIGFzcGVjdFJhdGlvID0gMS4wIC8gYXNwZWN0UmF0aW87XG4gICAgICBjb25zdCBtaW4gPSBNYXRoLnJvdW5kKHJlc29sdXRpb24pO1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5yb3VuZChyZXNvbHV0aW9uICogYXNwZWN0UmF0aW8pO1xuICAgICAgaWYgKGdsLmRyYXdpbmdCdWZmZXJXaWR0aCA+IGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpXG4gICAgICAgIHJldHVybiB7IHdpZHRoOiBtYXgsIGhlaWdodDogbWluIH07XG4gICAgICBlbHNlIHJldHVybiB7IHdpZHRoOiBtaW4sIGhlaWdodDogbWF4IH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbGVCeVBpeGVsUmF0aW8oaW5wdXQpIHtcbiAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoaW5wdXQgKiBwaXhlbFJhdGlvKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNoQ29kZShzKSB7XG4gICAgICBpZiAocy5sZW5ndGggPT09IDApIHJldHVybiAwO1xuICAgICAgbGV0IGhhc2ggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGhhc2ggfD0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICBsZXQgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgICAgbGV0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFgpO1xuICAgICAgbGV0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFkpO1xuICAgICAgdXBkYXRlUG9pbnRlckRvd25EYXRhKHBvaW50ZXIsIC0xLCBwb3NYLCBwb3NZKTtcbiAgICAgIGNsaWNrU3BsYXQocG9pbnRlcik7XG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcIm1vdXNlbW92ZVwiLFxuICAgICAgZnVuY3Rpb24gaGFuZGxlRmlyc3RNb3VzZU1vdmUoZSkge1xuICAgICAgICBsZXQgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgICAgICBsZXQgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKGUuY2xpZW50WCk7XG4gICAgICAgIGxldCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5jbGllbnRZKTtcbiAgICAgICAgbGV0IGNvbG9yID0gZ2VuZXJhdGVDb2xvcigpO1xuICAgICAgICB1cGRhdGVGcmFtZSgpOyAvLyBzdGFydCBhbmltYXRpb24gbG9vcFxuICAgICAgICB1cGRhdGVQb2ludGVyTW92ZURhdGEocG9pbnRlciwgcG9zWCwgcG9zWSwgY29sb3IpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgaGFuZGxlRmlyc3RNb3VzZU1vdmUpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCAoZSkgPT4ge1xuICAgICAgbGV0IHBvaW50ZXIgPSBwb2ludGVyc1swXTtcbiAgICAgIGxldCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5jbGllbnRYKTtcbiAgICAgIGxldCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5jbGllbnRZKTtcbiAgICAgIGxldCBjb2xvciA9IHBvaW50ZXIuY29sb3I7XG4gICAgICB1cGRhdGVQb2ludGVyTW92ZURhdGEocG9pbnRlciwgcG9zWCwgcG9zWSwgY29sb3IpO1xuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICBmdW5jdGlvbiBoYW5kbGVGaXJzdFRvdWNoU3RhcnQoZSkge1xuICAgICAgICBjb25zdCB0b3VjaGVzID0gZS50YXJnZXRUb3VjaGVzO1xuICAgICAgICBsZXQgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0uY2xpZW50WCk7XG4gICAgICAgICAgbGV0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFkpO1xuICAgICAgICAgIHVwZGF0ZUZyYW1lKCk7IC8vIHN0YXJ0IGFuaW1hdGlvbiBsb29wXG4gICAgICAgICAgdXBkYXRlUG9pbnRlckRvd25EYXRhKHBvaW50ZXIsIHRvdWNoZXNbaV0uaWRlbnRpZmllciwgcG9zWCwgcG9zWSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBoYW5kbGVGaXJzdFRvdWNoU3RhcnQpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHRvdWNoZXMgPSBlLnRhcmdldFRvdWNoZXM7XG4gICAgICBsZXQgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRYKTtcbiAgICAgICAgbGV0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFkpO1xuICAgICAgICB1cGRhdGVQb2ludGVyRG93bkRhdGEocG9pbnRlciwgdG91Y2hlc1tpXS5pZGVudGlmaWVyLCBwb3NYLCBwb3NZKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaG1vdmVcIixcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvdWNoZXMgPSBlLnRhcmdldFRvdWNoZXM7XG4gICAgICAgIGxldCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRYKTtcbiAgICAgICAgICBsZXQgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0uY2xpZW50WSk7XG4gICAgICAgICAgdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1ksIHBvaW50ZXIuY29sb3IpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXM7XG4gICAgICBsZXQgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVwZGF0ZVBvaW50ZXJVcERhdGEocG9pbnRlcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB1cGRhdGVGcmFtZSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW1xuICAgIFNJTV9SRVNPTFVUSU9OLFxuICAgIERZRV9SRVNPTFVUSU9OLFxuICAgIENBUFRVUkVfUkVTT0xVVElPTixcbiAgICBERU5TSVRZX0RJU1NJUEFUSU9OLFxuICAgIFZFTE9DSVRZX0RJU1NJUEFUSU9OLFxuICAgIFBSRVNTVVJFLFxuICAgIFBSRVNTVVJFX0lURVJBVElPTlMsXG4gICAgQ1VSTCxcbiAgICBTUExBVF9SQURJVVMsXG4gICAgU1BMQVRfRk9SQ0UsXG4gICAgU0hBRElORyxcbiAgICBDT0xPUl9VUERBVEVfU1BFRUQsXG4gICAgQkFDS19DT0xPUixcbiAgICBUUkFOU1BBUkVOVCxcbiAgXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZpeGVkIHRvcC0wIGxlZnQtMCB6LTUwIHBvaW50ZXItZXZlbnRzLW5vbmVcIj5cbiAgICAgIDxjYW52YXMgcmVmPXtjYW52YXNSZWZ9IGlkPVwiZmx1aWRcIiBjbGFzc05hbWU9XCJ3LXNjcmVlbiBoLXNjcmVlblwiIC8+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmV4cG9ydCB7IFNwbGFzaEN1cnNvciB9O1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsIlNwbGFzaEN1cnNvciIsIlNJTV9SRVNPTFVUSU9OIiwiRFlFX1JFU09MVVRJT04iLCJDQVBUVVJFX1JFU09MVVRJT04iLCJERU5TSVRZX0RJU1NJUEFUSU9OIiwiVkVMT0NJVFlfRElTU0lQQVRJT04iLCJQUkVTU1VSRSIsIlBSRVNTVVJFX0lURVJBVElPTlMiLCJDVVJMIiwiU1BMQVRfUkFESVVTIiwiU1BMQVRfRk9SQ0UiLCJTSEFESU5HIiwiQ09MT1JfVVBEQVRFX1NQRUVEIiwiQkFDS19DT0xPUiIsInIiLCJnIiwiYiIsIlRSQU5TUEFSRU5UIiwiY2FudmFzUmVmIiwiY2FudmFzIiwiY3VycmVudCIsIlBvaW50ZXIiLCJpZCIsInRleGNvb3JkWCIsInRleGNvb3JkWSIsInByZXZUZXhjb29yZFgiLCJwcmV2VGV4Y29vcmRZIiwiZGVsdGFYIiwiZGVsdGFZIiwiZG93biIsIm1vdmVkIiwiY29sb3IiLCJjb25maWciLCJQQVVTRUQiLCJwb2ludGVycyIsImdsIiwiZXh0IiwiZ2V0V2ViR0xDb250ZXh0Iiwic3VwcG9ydExpbmVhckZpbHRlcmluZyIsInBhcmFtcyIsImFscGhhIiwiZGVwdGgiLCJzdGVuY2lsIiwiYW50aWFsaWFzIiwicHJlc2VydmVEcmF3aW5nQnVmZmVyIiwiZ2V0Q29udGV4dCIsImlzV2ViR0wyIiwiV2ViR0wyUmVuZGVyaW5nQ29udGV4dCIsImhhbGZGbG9hdCIsImdldEV4dGVuc2lvbiIsImNsZWFyQ29sb3IiLCJoYWxmRmxvYXRUZXhUeXBlIiwiSEFMRl9GTE9BVCIsIkhBTEZfRkxPQVRfT0VTIiwiZm9ybWF0UkdCQSIsImZvcm1hdFJHIiwiZm9ybWF0UiIsImdldFN1cHBvcnRlZEZvcm1hdCIsIlJHQkExNkYiLCJSR0JBIiwiUkcxNkYiLCJSRyIsInVuZGVmaW5lZCIsIlIxNkYiLCJSRUQiLCJpbnRlcm5hbEZvcm1hdCIsImZvcm1hdCIsInR5cGUiLCJzdXBwb3J0UmVuZGVyVGV4dHVyZUZvcm1hdCIsInRleHR1cmUiLCJjcmVhdGVUZXh0dXJlIiwiYmluZFRleHR1cmUiLCJURVhUVVJFXzJEIiwidGV4UGFyYW1ldGVyaSIsIlRFWFRVUkVfTUlOX0ZJTFRFUiIsIk5FQVJFU1QiLCJURVhUVVJFX01BR19GSUxURVIiLCJURVhUVVJFX1dSQVBfUyIsIkNMQU1QX1RPX0VER0UiLCJURVhUVVJFX1dSQVBfVCIsInRleEltYWdlMkQiLCJmYm8iLCJjcmVhdGVGcmFtZWJ1ZmZlciIsImJpbmRGcmFtZWJ1ZmZlciIsIkZSQU1FQlVGRkVSIiwiZnJhbWVidWZmZXJUZXh0dXJlMkQiLCJDT0xPUl9BVFRBQ0hNRU5UMCIsInN0YXR1cyIsImNoZWNrRnJhbWVidWZmZXJTdGF0dXMiLCJGUkFNRUJVRkZFUl9DT01QTEVURSIsIk1hdGVyaWFsIiwic2V0S2V5d29yZHMiLCJrZXl3b3JkcyIsImhhc2giLCJpIiwibGVuZ3RoIiwiaGFzaENvZGUiLCJwcm9ncmFtIiwicHJvZ3JhbXMiLCJmcmFnbWVudFNoYWRlciIsImNvbXBpbGVTaGFkZXIiLCJGUkFHTUVOVF9TSEFERVIiLCJmcmFnbWVudFNoYWRlclNvdXJjZSIsImNyZWF0ZVByb2dyYW0iLCJ2ZXJ0ZXhTaGFkZXIiLCJhY3RpdmVQcm9ncmFtIiwidW5pZm9ybXMiLCJnZXRVbmlmb3JtcyIsImJpbmQiLCJ1c2VQcm9ncmFtIiwiY29uc3RydWN0b3IiLCJQcm9ncmFtIiwidW5pZm9ybUNvdW50IiwiZ2V0UHJvZ3JhbVBhcmFtZXRlciIsIkFDVElWRV9VTklGT1JNUyIsInVuaWZvcm1JbmZvIiwiZ2V0QWN0aXZlVW5pZm9ybSIsInVuaWZvcm1OYW1lIiwibmFtZSIsImdldFVuaWZvcm1Mb2NhdGlvbiIsInNvdXJjZSIsImFkZEtleXdvcmRzIiwic2hhZGVyIiwiY3JlYXRlU2hhZGVyIiwic2hhZGVyU291cmNlIiwiZ2V0U2hhZGVyUGFyYW1ldGVyIiwiQ09NUElMRV9TVEFUVVMiLCJjb25zb2xlIiwidHJhY2UiLCJnZXRTaGFkZXJJbmZvTG9nIiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJMSU5LX1NUQVRVUyIsImdldFByb2dyYW1JbmZvTG9nIiwia2V5d29yZHNTdHJpbmciLCJmb3JFYWNoIiwia2V5d29yZCIsImJhc2VWZXJ0ZXhTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwiY29weVNoYWRlciIsImNsZWFyU2hhZGVyIiwiZGlzcGxheVNoYWRlclNvdXJjZSIsInNwbGF0U2hhZGVyIiwiYWR2ZWN0aW9uU2hhZGVyIiwiZGl2ZXJnZW5jZVNoYWRlciIsImN1cmxTaGFkZXIiLCJ2b3J0aWNpdHlTaGFkZXIiLCJwcmVzc3VyZVNoYWRlciIsImdyYWRpZW50U3VidHJhY3RTaGFkZXIiLCJibGl0IiwiYmluZEJ1ZmZlciIsIkFSUkFZX0JVRkZFUiIsImNyZWF0ZUJ1ZmZlciIsImJ1ZmZlckRhdGEiLCJGbG9hdDMyQXJyYXkiLCJTVEFUSUNfRFJBVyIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwiVWludDE2QXJyYXkiLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwiRkxPQVQiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsInRhcmdldCIsImNsZWFyIiwidmlld3BvcnQiLCJkcmF3aW5nQnVmZmVyV2lkdGgiLCJkcmF3aW5nQnVmZmVySGVpZ2h0Iiwid2lkdGgiLCJoZWlnaHQiLCJDT0xPUl9CVUZGRVJfQklUIiwiZHJhd0VsZW1lbnRzIiwiVFJJQU5HTEVTIiwiVU5TSUdORURfU0hPUlQiLCJkeWUiLCJ2ZWxvY2l0eSIsImRpdmVyZ2VuY2UiLCJjdXJsIiwicHJlc3N1cmUiLCJjb3B5UHJvZ3JhbSIsImNsZWFyUHJvZ3JhbSIsInNwbGF0UHJvZ3JhbSIsImFkdmVjdGlvblByb2dyYW0iLCJkaXZlcmdlbmNlUHJvZ3JhbSIsImN1cmxQcm9ncmFtIiwidm9ydGljaXR5UHJvZ3JhbSIsInByZXNzdXJlUHJvZ3JhbSIsImdyYWRpZW5TdWJ0cmFjdFByb2dyYW0iLCJkaXNwbGF5TWF0ZXJpYWwiLCJpbml0RnJhbWVidWZmZXJzIiwic2ltUmVzIiwiZ2V0UmVzb2x1dGlvbiIsImR5ZVJlcyIsInRleFR5cGUiLCJyZ2JhIiwicmciLCJmaWx0ZXJpbmciLCJMSU5FQVIiLCJkaXNhYmxlIiwiQkxFTkQiLCJjcmVhdGVEb3VibGVGQk8iLCJyZXNpemVEb3VibGVGQk8iLCJjcmVhdGVGQk8iLCJ3IiwiaCIsInBhcmFtIiwiYWN0aXZlVGV4dHVyZSIsIlRFWFRVUkUwIiwidGV4ZWxTaXplWCIsInRleGVsU2l6ZVkiLCJhdHRhY2giLCJmYm8xIiwiZmJvMiIsInJlYWQiLCJ2YWx1ZSIsIndyaXRlIiwic3dhcCIsInRlbXAiLCJyZXNpemVGQk8iLCJuZXdGQk8iLCJ1bmlmb3JtMWkiLCJ1VGV4dHVyZSIsInVwZGF0ZUtleXdvcmRzIiwiZGlzcGxheUtleXdvcmRzIiwicHVzaCIsImxhc3RVcGRhdGVUaW1lIiwiRGF0ZSIsIm5vdyIsImNvbG9yVXBkYXRlVGltZXIiLCJ1cGRhdGVGcmFtZSIsImR0IiwiY2FsY0RlbHRhVGltZSIsInJlc2l6ZUNhbnZhcyIsInVwZGF0ZUNvbG9ycyIsImFwcGx5SW5wdXRzIiwic3RlcCIsInJlbmRlciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIk1hdGgiLCJtaW4iLCJzY2FsZUJ5UGl4ZWxSYXRpbyIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwid3JhcCIsInAiLCJnZW5lcmF0ZUNvbG9yIiwic3BsYXRQb2ludGVyIiwidW5pZm9ybTJmIiwidGV4ZWxTaXplIiwidVZlbG9jaXR5IiwidUN1cmwiLCJ1bmlmb3JtMWYiLCJ1RGl2ZXJnZW5jZSIsInVQcmVzc3VyZSIsImR5ZVRleGVsU2l6ZSIsInZlbG9jaXR5SWQiLCJ1U291cmNlIiwiZGlzc2lwYXRpb24iLCJibGVuZEZ1bmMiLCJPTkUiLCJPTkVfTUlOVVNfU1JDX0FMUEhBIiwiZW5hYmxlIiwiZHJhd0Rpc3BsYXkiLCJwb2ludGVyIiwiZHgiLCJkeSIsInNwbGF0IiwiY2xpY2tTcGxhdCIsInJhbmRvbSIsIngiLCJ5IiwidVRhcmdldCIsImFzcGVjdFJhdGlvIiwicG9pbnQiLCJ1bmlmb3JtM2YiLCJyYWRpdXMiLCJjb3JyZWN0UmFkaXVzIiwidXBkYXRlUG9pbnRlckRvd25EYXRhIiwicG9zWCIsInBvc1kiLCJ1cGRhdGVQb2ludGVyTW92ZURhdGEiLCJjb3JyZWN0RGVsdGFYIiwiY29ycmVjdERlbHRhWSIsImFicyIsInVwZGF0ZVBvaW50ZXJVcERhdGEiLCJkZWx0YSIsImMiLCJIU1Z0b1JHQiIsInMiLCJ2IiwiZiIsInEiLCJ0IiwiZmxvb3IiLCJtYXgiLCJyYW5nZSIsInJlc29sdXRpb24iLCJyb3VuZCIsImlucHV0IiwicGl4ZWxSYXRpbyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJjaGFyQ29kZUF0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJjbGllbnRYIiwiY2xpZW50WSIsImRvY3VtZW50IiwiYm9keSIsImhhbmRsZUZpcnN0TW91c2VNb3ZlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZUZpcnN0VG91Y2hTdGFydCIsInRvdWNoZXMiLCJ0YXJnZXRUb3VjaGVzIiwiaWRlbnRpZmllciIsImNoYW5nZWRUb3VjaGVzIiwiZGl2IiwiY2xhc3NOYW1lIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/splash-cursor.tsx\n"));

/***/ })

});