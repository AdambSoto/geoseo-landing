"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/ui/splash-cursor.tsx":
/*!*********************************************!*\
  !*** ./src/components/ui/splash-cursor.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SplashCursor: function() { return /* binding */ SplashCursor; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ SplashCursor auto */ \nvar _s = $RefreshSig$();\n\nfunction SplashCursor(param) {\n    let { // Add whatever props you like for customization\n    SIM_RESOLUTION = 128, DYE_RESOLUTION = 1440, CAPTURE_RESOLUTION = 512, DENSITY_DISSIPATION = 3.5, VELOCITY_DISSIPATION = 2, PRESSURE = 0.1, PRESSURE_ITERATIONS = 20, CURL = 3, SPLAT_RADIUS = 0.2, SPLAT_FORCE = 6000, SHADING = true, COLOR_UPDATE_SPEED = 10, BACK_COLOR = {\n        r: 0.5,\n        g: 0,\n        b: 0\n    }, TRANSPARENT = true } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        class Pointer {\n            constructor(){\n                this.id = -1;\n                this.texcoordX = 0;\n                this.texcoordY = 0;\n                this.prevTexcoordX = 0;\n                this.prevTexcoordY = 0;\n                this.deltaX = 0;\n                this.deltaY = 0;\n                this.down = false;\n                this.moved = false;\n                this.color = [\n                    0,\n                    0,\n                    0\n                ];\n            }\n        }\n        let config = {\n            SIM_RESOLUTION,\n            DYE_RESOLUTION,\n            CAPTURE_RESOLUTION,\n            DENSITY_DISSIPATION,\n            VELOCITY_DISSIPATION,\n            PRESSURE,\n            PRESSURE_ITERATIONS,\n            CURL,\n            SPLAT_RADIUS,\n            SPLAT_FORCE,\n            SHADING,\n            COLOR_UPDATE_SPEED,\n            PAUSED: false,\n            BACK_COLOR,\n            TRANSPARENT\n        };\n        let pointers = [\n            new Pointer()\n        ];\n        const { gl, ext } = getWebGLContext(canvas);\n        if (!ext.supportLinearFiltering) {\n            config.DYE_RESOLUTION = 256;\n            config.SHADING = false;\n        }\n        function getWebGLContext(canvas) {\n            const params = {\n                alpha: true,\n                depth: false,\n                stencil: false,\n                antialias: false,\n                preserveDrawingBuffer: false\n            };\n            let gl = canvas.getContext(\"webgl2\", params) || canvas.getContext(\"webgl\", params) || canvas.getContext(\"experimental-webgl\", params);\n            if (!gl) return {\n                gl: null,\n                ext: {}\n            };\n            const isWebGL2 = gl instanceof WebGL2RenderingContext;\n            let halfFloat;\n            let supportLinearFiltering;\n            if (isWebGL2) {\n                gl.getExtension(\"EXT_color_buffer_float\");\n                supportLinearFiltering = gl.getExtension(\"OES_texture_float_linear\");\n            } else {\n                halfFloat = gl.getExtension(\"OES_texture_half_float\");\n                supportLinearFiltering = gl.getExtension(\"OES_texture_half_float_linear\");\n            }\n            gl.clearColor(0.0, 0.0, 0.0, 1.0);\n            const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat && halfFloat.HALF_FLOAT_OES;\n            let formatRGBA;\n            let formatRG;\n            let formatR;\n            if (isWebGL2) {\n                formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n                formatRG = \"RG16F\" in gl && \"RG\" in gl ? getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType) : getSupportedFormat(gl, undefined, undefined, undefined);\n                formatR = \"R16F\" in gl && \"RED\" in gl ? getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType) : getSupportedFormat(gl, undefined, undefined, undefined);\n            } else {\n                formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n                formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n                formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n            }\n            return {\n                gl,\n                ext: {\n                    formatRGBA,\n                    formatRG,\n                    formatR,\n                    halfFloatTexType,\n                    supportLinearFiltering\n                }\n            };\n        }\n        function getSupportedFormat(gl, internalFormat, format, type) {\n            if (!gl) return null;\n            if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n                switch(internalFormat){\n                    case gl.R16F:\n                        return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n                    case gl.RG16F:\n                        return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n                    default:\n                        return null;\n                }\n            }\n            return {\n                internalFormat,\n                format\n            };\n        }\n        function supportRenderTextureFormat(gl, internalFormat, format, type) {\n            if (!gl) return false;\n            const texture = gl.createTexture();\n            if (!texture) return false;\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n            const fbo = gl.createFramebuffer();\n            if (!fbo) return false;\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n            return status === gl.FRAMEBUFFER_COMPLETE;\n        }\n        class Material {\n            setKeywords(keywords) {\n                if (!gl) return;\n                let hash = 0;\n                for(let i = 0; i < keywords.length; i++)hash += hashCode(keywords[i]);\n                let program = this.programs[hash];\n                if (program == null) {\n                    let fragmentShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, this.fragmentShaderSource, keywords);\n                    program = createProgram(this.vertexShader, fragmentShader);\n                    this.programs[hash] = program;\n                }\n                if (program === this.activeProgram) return;\n                this.uniforms = getUniforms(program);\n                this.activeProgram = program;\n            }\n            bind() {\n                if (!gl) return;\n                gl.useProgram(this.activeProgram);\n            }\n            constructor(vertexShader, fragmentShaderSource){\n                this.vertexShader = vertexShader;\n                this.fragmentShaderSource = fragmentShaderSource;\n                this.programs = [];\n                this.activeProgram = null;\n                this.uniforms = [];\n            }\n        }\n        class Program {\n            bind() {\n                if (!gl) return;\n                gl.useProgram(this.program);\n            }\n            constructor(vertexShader, fragmentShader){\n                this.uniforms = {};\n                this.program = createProgram(vertexShader, fragmentShader);\n                this.uniforms = getUniforms(this.program);\n            }\n        }\n        function getUniforms(program) {\n            if (!gl) return [];\n            let uniforms = {};\n            let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n            for(let i = 0; i < uniformCount; i++){\n                const uniformInfo = gl.getActiveUniform(program, i);\n                if (!uniformInfo) continue;\n                let uniformName = uniformInfo.name;\n                uniforms[uniformName] = gl.getUniformLocation(program, uniformName);\n            }\n            return uniforms;\n        }\n        function compileShader(type, source, keywords) {\n            if (!gl) return null;\n            source = addKeywords(source, keywords || []);\n            const shader = gl.createShader(type);\n            if (!shader) return null;\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) console.trace(gl.getShaderInfoLog(shader));\n            return shader;\n        }\n        function createProgram(vertexShader, fragmentShader) {\n            if (!gl || !vertexShader || !fragmentShader) return null;\n            let program = gl.createProgram();\n            if (!program) return null;\n            gl.attachShader(program, vertexShader);\n            gl.attachShader(program, fragmentShader);\n            gl.linkProgram(program);\n            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) console.trace(gl.getProgramInfoLog(program));\n            return program;\n        }\n        function addKeywords(source, keywords) {\n            if (!keywords) return source;\n            let keywordsString = \"\";\n            keywords.forEach((keyword)=>{\n                keywordsString += \"#define \" + keyword + \"\\n\";\n            });\n            return keywordsString + source;\n        }\n        const baseVertexShader = compileShader(gl ? gl.VERTEX_SHADER : 35633, \"\\n        precision highp float;\\n        attribute vec2 aPosition;\\n        varying vec2 vUv;\\n        varying vec2 vL;\\n        varying vec2 vR;\\n        varying vec2 vT;\\n        varying vec2 vB;\\n        uniform vec2 texelSize;\\n\\n        void main () {\\n            vUv = aPosition * 0.5 + 0.5;\\n            vL = vUv - vec2(texelSize.x, 0.0);\\n            vR = vUv + vec2(texelSize.x, 0.0);\\n            vT = vUv + vec2(0.0, texelSize.y);\\n            vB = vUv - vec2(0.0, texelSize.y);\\n            gl_Position = vec4(aPosition, 0.0, 1.0);\\n        }\\n      \", []);\n        const copyShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        uniform sampler2D uTexture;\\n\\n        void main () {\\n            gl_FragColor = texture2D(uTexture, vUv);\\n        }\\n      \", []);\n        const clearShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        uniform sampler2D uTexture;\\n        uniform float value;\\n\\n        void main () {\\n            gl_FragColor = value * texture2D(uTexture, vUv);\\n        }\\n     \", []);\n        const displayShaderSource = \"\\n      precision highp float;\\n      precision highp sampler2D;\\n      varying vec2 vUv;\\n      varying vec2 vL;\\n      varying vec2 vR;\\n      varying vec2 vT;\\n      varying vec2 vB;\\n      uniform sampler2D uTexture;\\n      uniform sampler2D uDithering;\\n      uniform vec2 ditherScale;\\n      uniform vec2 texelSize;\\n\\n      vec3 linearToGamma (vec3 color) {\\n          color = max(color, vec3(0));\\n          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\\n      }\\n\\n      void main () {\\n          vec3 c = texture2D(uTexture, vUv).rgb;\\n          #ifdef SHADING\\n              vec3 lc = texture2D(uTexture, vL).rgb;\\n              vec3 rc = texture2D(uTexture, vR).rgb;\\n              vec3 tc = texture2D(uTexture, vT).rgb;\\n              vec3 bc = texture2D(uTexture, vB).rgb;\\n\\n              float dx = length(rc) - length(lc);\\n              float dy = length(tc) - length(bc);\\n\\n              vec3 n = normalize(vec3(dx, dy, length(texelSize)));\\n              vec3 l = vec3(0.0, 0.0, 1.0);\\n\\n              float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\\n              c *= diffuse;\\n          #endif\\n\\n          float a = max(c.r, max(c.g, c.b));\\n          gl_FragColor = vec4(c, a);\\n      }\\n    \";\n        const splatShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision highp float;\\n        precision highp sampler2D;\\n        varying vec2 vUv;\\n        uniform sampler2D uTarget;\\n        uniform float aspectRatio;\\n        uniform vec3 color;\\n        uniform vec2 point;\\n        uniform float radius;\\n\\n        void main () {\\n            vec2 p = vUv - point.xy;\\n            p.x *= aspectRatio;\\n            vec3 splat = exp(-dot(p, p) / radius) * color;\\n            vec3 base = texture2D(uTarget, vUv).xyz;\\n            gl_FragColor = vec4(base + splat, 1.0);\\n        }\\n      \", []);\n        const advectionShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision highp float;\\n        precision highp sampler2D;\\n        varying vec2 vUv;\\n        uniform sampler2D uVelocity;\\n        uniform sampler2D uSource;\\n        uniform vec2 texelSize;\\n        uniform vec2 dyeTexelSize;\\n        uniform float dt;\\n        uniform float dissipation;\\n\\n        vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\\n            vec2 st = uv / tsize - 0.5;\\n            vec2 iuv = floor(st);\\n            vec2 fuv = fract(st);\\n\\n            vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\\n            vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\\n            vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\\n            vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\\n\\n            return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\\n        }\\n\\n        void main () {\\n            #ifdef MANUAL_FILTERING\\n                vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\\n                vec4 result = bilerp(uSource, coord, dyeTexelSize);\\n            #else\\n                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\\n                vec4 result = texture2D(uSource, coord);\\n            #endif\\n            float decay = 1.0 + dissipation * dt;\\n            gl_FragColor = result / decay;\\n        }\\n      \", ext && ext.supportLinearFiltering ? [] : [\n            \"MANUAL_FILTERING\"\n        ]);\n        const divergenceShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        varying highp vec2 vL;\\n        varying highp vec2 vR;\\n        varying highp vec2 vT;\\n        varying highp vec2 vB;\\n        uniform sampler2D uVelocity;\\n\\n        void main () {\\n            float L = texture2D(uVelocity, vL).x;\\n            float R = texture2D(uVelocity, vR).x;\\n            float T = texture2D(uVelocity, vT).y;\\n            float B = texture2D(uVelocity, vB).y;\\n\\n            vec2 C = texture2D(uVelocity, vUv).xy;\\n            if (vL.x < 0.0) { L = -C.x; }\\n            if (vR.x > 1.0) { R = -C.x; }\\n            if (vT.y > 1.0) { T = -C.y; }\\n            if (vB.y < 0.0) { B = -C.y; }\\n\\n            float div = 0.5 * (R - L + T - B);\\n            gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\\n        }\\n      \", []);\n        const curlShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        varying highp vec2 vL;\\n        varying highp vec2 vR;\\n        varying highp vec2 vT;\\n        varying highp vec2 vB;\\n        uniform sampler2D uVelocity;\\n\\n        void main () {\\n            float L = texture2D(uVelocity, vL).y;\\n            float R = texture2D(uVelocity, vR).y;\\n            float T = texture2D(uVelocity, vT).x;\\n            float B = texture2D(uVelocity, vB).x;\\n            float vorticity = R - L - T + B;\\n            gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\\n        }\\n      \", []);\n        const vorticityShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision highp float;\\n        precision highp sampler2D;\\n        varying vec2 vUv;\\n        varying vec2 vL;\\n        varying vec2 vR;\\n        varying vec2 vT;\\n        varying vec2 vB;\\n        uniform sampler2D uVelocity;\\n        uniform sampler2D uCurl;\\n        uniform float curl;\\n        uniform float dt;\\n\\n        void main () {\\n            float L = texture2D(uCurl, vL).x;\\n            float R = texture2D(uCurl, vR).x;\\n            float T = texture2D(uCurl, vT).x;\\n            float B = texture2D(uCurl, vB).x;\\n            float C = texture2D(uCurl, vUv).x;\\n\\n            vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\\n            force /= length(force) + 0.0001;\\n            force *= curl * C;\\n            force.y *= -1.0;\\n\\n            vec2 velocity = texture2D(uVelocity, vUv).xy;\\n            velocity += force * dt;\\n            velocity = min(max(velocity, -1000.0), 1000.0);\\n            gl_FragColor = vec4(velocity, 0.0, 1.0);\\n        }\\n      \", []);\n        const pressureShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        varying highp vec2 vL;\\n        varying highp vec2 vR;\\n        varying highp vec2 vT;\\n        varying highp vec2 vB;\\n        uniform sampler2D uPressure;\\n        uniform sampler2D uDivergence;\\n\\n        void main () {\\n            float L = texture2D(uPressure, vL).x;\\n            float R = texture2D(uPressure, vR).x;\\n            float T = texture2D(uPressure, vT).x;\\n            float B = texture2D(uPressure, vB).x;\\n            float C = texture2D(uPressure, vUv).x;\\n            float divergence = texture2D(uDivergence, vUv).x;\\n            float pressure = (L + R + B + T - divergence) * 0.25;\\n            gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\\n        }\\n      \", []);\n        const gradientSubtractShader = compileShader(gl ? gl.FRAGMENT_SHADER : 35632, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        varying highp vec2 vL;\\n        varying highp vec2 vR;\\n        varying highp vec2 vT;\\n        varying highp vec2 vB;\\n        uniform sampler2D uPressure;\\n        uniform sampler2D uVelocity;\\n\\n        void main () {\\n            float L = texture2D(uPressure, vL).x;\\n            float R = texture2D(uPressure, vR).x;\\n            float T = texture2D(uPressure, vT).x;\\n            float B = texture2D(uPressure, vB).x;\\n            vec2 velocity = texture2D(uVelocity, vUv).xy;\\n            velocity.xy -= vec2(R - L, T - B);\\n            gl_FragColor = vec4(velocity, 0.0, 1.0);\\n        }\\n      \", []);\n        const blit = (()=>{\n            if (!gl) throw new Error(\"WebGL context not available\");\n            gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n                -1,\n                -1,\n                -1,\n                1,\n                1,\n                1,\n                1,\n                -1\n            ]), gl.STATIC_DRAW);\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([\n                0,\n                1,\n                2,\n                0,\n                2,\n                3\n            ]), gl.STATIC_DRAW);\n            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(0);\n            return function(target) {\n                let clear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n                if (!gl) return;\n                if (target == null) {\n                    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                } else {\n                    gl.viewport(0, 0, target.width, target.height);\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n                }\n                if (clear) {\n                    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n                    gl.clear(gl.COLOR_BUFFER_BIT);\n                }\n                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n            };\n        })();\n        let dye, velocity, divergence, curl, pressure;\n        const copyProgram = new Program(baseVertexShader, copyShader);\n        const clearProgram = new Program(baseVertexShader, clearShader);\n        const splatProgram = new Program(baseVertexShader, splatShader);\n        const advectionProgram = new Program(baseVertexShader, advectionShader);\n        const divergenceProgram = new Program(baseVertexShader, divergenceShader);\n        const curlProgram = new Program(baseVertexShader, curlShader);\n        const vorticityProgram = new Program(baseVertexShader, vorticityShader);\n        const pressureProgram = new Program(baseVertexShader, pressureShader);\n        const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);\n        const displayMaterial = new Material(baseVertexShader, displayShaderSource);\n        function initFramebuffers() {\n            if (!gl) return;\n            let simRes = getResolution(config.SIM_RESOLUTION);\n            let dyeRes = getResolution(config.DYE_RESOLUTION);\n            const texType = ext.halfFloatTexType;\n            const rgba = ext.formatRGBA;\n            const rg = ext.formatRG;\n            const r = ext.formatR;\n            const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n            gl.disable(gl.BLEND);\n            if (rgba && !dye) dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n            else if (rgba) dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n            if (rg && !velocity) velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n            else if (rg) velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n            if (r) {\n                divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n                curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n                pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n            }\n        }\n        function createFBO(w, h, internalFormat, format, type, param) {\n            if (!gl) throw new Error(\"WebGL context not available\");\n            gl.activeTexture(gl.TEXTURE0);\n            let texture = gl.createTexture();\n            if (!texture) throw new Error(\"Failed to create texture\");\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n            let fbo = gl.createFramebuffer();\n            if (!fbo) throw new Error(\"Failed to create framebuffer\");\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            gl.viewport(0, 0, w, h);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            let texelSizeX = 1.0 / w;\n            let texelSizeY = 1.0 / h;\n            return {\n                texture,\n                fbo,\n                width: w,\n                height: h,\n                texelSizeX,\n                texelSizeY,\n                attach (id) {\n                    if (!gl) return id;\n                    gl.activeTexture(gl.TEXTURE0 + id);\n                    gl.bindTexture(gl.TEXTURE_2D, texture);\n                    return id;\n                }\n            };\n        }\n        function createDoubleFBO(w, h, internalFormat, format, type, param) {\n            if (!gl) throw new Error(\"WebGL context not available\");\n            let fbo1 = createFBO(w, h, internalFormat, format, type, param);\n            let fbo2 = createFBO(w, h, internalFormat, format, type, param);\n            return {\n                width: w,\n                height: h,\n                texelSizeX: fbo1.texelSizeX,\n                texelSizeY: fbo1.texelSizeY,\n                get read () {\n                    return fbo1;\n                },\n                set read (value){\n                    fbo1 = value;\n                },\n                get write () {\n                    return fbo2;\n                },\n                set write (value){\n                    fbo2 = value;\n                },\n                swap () {\n                    let temp = fbo1;\n                    fbo1 = fbo2;\n                    fbo2 = temp;\n                }\n            };\n        }\n        function resizeFBO(target, w, h, internalFormat, format, type, param) {\n            let newFBO = createFBO(w, h, internalFormat, format, type, param);\n            copyProgram.bind();\n            gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n            blit(newFBO);\n            return newFBO;\n        }\n        function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {\n            if (target.width === w && target.height === h) return target;\n            target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);\n            target.write = createFBO(w, h, internalFormat, format, type, param);\n            target.width = w;\n            target.height = h;\n            target.texelSizeX = 1.0 / w;\n            target.texelSizeY = 1.0 / h;\n            return target;\n        }\n        function updateKeywords() {\n            let displayKeywords = [];\n            if (config.SHADING) displayKeywords.push(\"SHADING\");\n            displayMaterial.setKeywords(displayKeywords);\n        }\n        updateKeywords();\n        initFramebuffers();\n        let lastUpdateTime = Date.now();\n        let colorUpdateTimer = 0.0;\n        function updateFrame() {\n            const dt = calcDeltaTime();\n            if (resizeCanvas()) initFramebuffers();\n            updateColors(dt);\n            applyInputs();\n            step(dt);\n            render(null);\n            requestAnimationFrame(updateFrame);\n        }\n        function calcDeltaTime() {\n            let now = Date.now();\n            let dt = (now - lastUpdateTime) / 1000;\n            dt = Math.min(dt, 0.016666);\n            lastUpdateTime = now;\n            return dt;\n        }\n        function resizeCanvas() {\n            let width = scaleByPixelRatio(canvas.clientWidth);\n            let height = scaleByPixelRatio(canvas.clientHeight);\n            if (canvas.width !== width || canvas.height !== height) {\n                canvas.width = width;\n                canvas.height = height;\n                return true;\n            }\n            return false;\n        }\n        function updateColors(dt) {\n            colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n            if (colorUpdateTimer >= 1) {\n                colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n                pointers.forEach((p)=>{\n                    p.color = generateColor();\n                });\n            }\n        }\n        function applyInputs() {\n            pointers.forEach((p)=>{\n                if (p.moved) {\n                    p.moved = false;\n                    splatPointer(p);\n                }\n            });\n        }\n        function step(dt) {\n            gl.disable(gl.BLEND);\n            // Curl\n            curlProgram.bind();\n            gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n            blit(curl);\n            // Vorticity\n            vorticityProgram.bind();\n            gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n            gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n            gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n            gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n            blit(velocity.write);\n            velocity.swap();\n            // Divergence\n            divergenceProgram.bind();\n            gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n            blit(divergence);\n            // Clear pressure\n            clearProgram.bind();\n            gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n            gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n            blit(pressure.write);\n            pressure.swap();\n            // Pressure\n            pressureProgram.bind();\n            gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n            for(let i = 0; i < config.PRESSURE_ITERATIONS; i++){\n                gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n                blit(pressure.write);\n                pressure.swap();\n            }\n            // Gradient Subtract\n            gradienSubtractProgram.bind();\n            gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));\n            gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));\n            blit(velocity.write);\n            velocity.swap();\n            // Advection\n            advectionProgram.bind();\n            gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);\n            let velocityId = velocity.read.attach(0);\n            gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n            gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n            gl.uniform1f(advectionProgram.uniforms.dt, dt);\n            gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n            blit(velocity.write);\n            velocity.swap();\n            if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);\n            gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n            gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n            gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n            blit(dye.write);\n            dye.swap();\n        }\n        function render(target) {\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n            drawDisplay(target);\n        }\n        function drawDisplay(target) {\n            let width = target == null ? gl.drawingBufferWidth : target.width;\n            let height = target == null ? gl.drawingBufferHeight : target.height;\n            displayMaterial.bind();\n            if (config.SHADING) gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);\n            gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n            blit(target);\n        }\n        function splatPointer(pointer) {\n            let dx = pointer.deltaX * config.SPLAT_FORCE;\n            let dy = pointer.deltaY * config.SPLAT_FORCE;\n            splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n        }\n        function clickSplat(pointer) {\n            const color = generateColor();\n            color.r *= 10.0;\n            color.g *= 10.0;\n            color.b *= 10.0;\n            let dx = 10 * (Math.random() - 0.5);\n            let dy = 30 * (Math.random() - 0.5);\n            splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);\n        }\n        function splat(x, y, dx, dy, color) {\n            splatProgram.bind();\n            gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n            gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n            gl.uniform2f(splatProgram.uniforms.point, x, y);\n            gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);\n            gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));\n            blit(velocity.write);\n            velocity.swap();\n            gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n            gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n            blit(dye.write);\n            dye.swap();\n        }\n        function correctRadius(radius) {\n            let aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio > 1) radius *= aspectRatio;\n            return radius;\n        }\n        function updatePointerDownData(pointer, id, posX, posY) {\n            pointer.id = id;\n            pointer.down = true;\n            pointer.moved = false;\n            pointer.texcoordX = posX / canvas.width;\n            pointer.texcoordY = 1.0 - posY / canvas.height;\n            pointer.prevTexcoordX = pointer.texcoordX;\n            pointer.prevTexcoordY = pointer.texcoordY;\n            pointer.deltaX = 0;\n            pointer.deltaY = 0;\n            pointer.color = generateColor();\n        }\n        function updatePointerMoveData(pointer, posX, posY, color) {\n            pointer.prevTexcoordX = pointer.texcoordX;\n            pointer.prevTexcoordY = pointer.texcoordY;\n            pointer.texcoordX = posX / canvas.width;\n            pointer.texcoordY = 1.0 - posY / canvas.height;\n            pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n            pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n            pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n            pointer.color = color;\n        }\n        function updatePointerUpData(pointer) {\n            pointer.down = false;\n        }\n        function correctDeltaX(delta) {\n            let aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio < 1) delta *= aspectRatio;\n            return delta;\n        }\n        function correctDeltaY(delta) {\n            let aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio > 1) delta /= aspectRatio;\n            return delta;\n        }\n        function generateColor() {\n            let c = HSVtoRGB(Math.random(), 1.0, 1.0);\n            c.r *= 0.15;\n            c.g *= 0.15;\n            c.b *= 0.15;\n            return c;\n        }\n        function HSVtoRGB(h, s, v) {\n            let r, g, b, i, f, p, q, t;\n            i = Math.floor(h * 6);\n            f = h * 6 - i;\n            p = v * (1 - s);\n            q = v * (1 - f * s);\n            t = v * (1 - (1 - f) * s);\n            switch(i % 6){\n                case 0:\n                    r = v;\n                    g = t;\n                    b = p;\n                    break;\n                case 1:\n                    r = q;\n                    g = v;\n                    b = p;\n                    break;\n                case 2:\n                    r = p;\n                    g = v;\n                    b = t;\n                    break;\n                case 3:\n                    r = p;\n                    g = q;\n                    b = v;\n                    break;\n                case 4:\n                    r = t;\n                    g = p;\n                    b = v;\n                    break;\n                case 5:\n                    r = v;\n                    g = p;\n                    b = q;\n                    break;\n                default:\n                    break;\n            }\n            return {\n                r,\n                g,\n                b\n            };\n        }\n        function wrap(value1, min, max) {\n            const range = max - min;\n            if (range === 0) return min;\n            return (value1 - min) % range + min;\n        }\n        function getResolution(resolution) {\n            let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n            if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;\n            const min = Math.round(resolution);\n            const max = Math.round(resolution * aspectRatio);\n            if (gl.drawingBufferWidth > gl.drawingBufferHeight) return {\n                width: max,\n                height: min\n            };\n            else return {\n                width: min,\n                height: max\n            };\n        }\n        function scaleByPixelRatio(input) {\n            const pixelRatio = window.devicePixelRatio || 1;\n            return Math.floor(input * pixelRatio);\n        }\n        function hashCode(s) {\n            if (s.length === 0) return 0;\n            let hash = 0;\n            for(let i = 0; i < s.length; i++){\n                hash = (hash << 5) - hash + s.charCodeAt(i);\n                hash |= 0;\n            }\n            return hash;\n        }\n        window.addEventListener(\"mousedown\", (e)=>{\n            let pointer = pointers[0];\n            let posX = scaleByPixelRatio(e.clientX);\n            let posY = scaleByPixelRatio(e.clientY);\n            updatePointerDownData(pointer, -1, posX, posY);\n            clickSplat(pointer);\n        });\n        document.body.addEventListener(\"mousemove\", function handleFirstMouseMove(e) {\n            let pointer = pointers[0];\n            let posX = scaleByPixelRatio(e.clientX);\n            let posY = scaleByPixelRatio(e.clientY);\n            let color = generateColor();\n            updateFrame(); // start animation loop\n            updatePointerMoveData(pointer, posX, posY, color);\n            document.body.removeEventListener(\"mousemove\", handleFirstMouseMove);\n        });\n        window.addEventListener(\"mousemove\", (e)=>{\n            let pointer = pointers[0];\n            let posX = scaleByPixelRatio(e.clientX);\n            let posY = scaleByPixelRatio(e.clientY);\n            let color = pointer.color;\n            updatePointerMoveData(pointer, posX, posY, color);\n        });\n        document.body.addEventListener(\"touchstart\", function handleFirstTouchStart(e) {\n            const touches = e.targetTouches;\n            let pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                let posX = scaleByPixelRatio(touches[i].clientX);\n                let posY = scaleByPixelRatio(touches[i].clientY);\n                updateFrame(); // start animation loop\n                updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n            }\n            document.body.removeEventListener(\"touchstart\", handleFirstTouchStart);\n        });\n        window.addEventListener(\"touchstart\", (e)=>{\n            const touches = e.targetTouches;\n            let pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                let posX = scaleByPixelRatio(touches[i].clientX);\n                let posY = scaleByPixelRatio(touches[i].clientY);\n                updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n            }\n        });\n        window.addEventListener(\"touchmove\", (e)=>{\n            const touches = e.targetTouches;\n            let pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                let posX = scaleByPixelRatio(touches[i].clientX);\n                let posY = scaleByPixelRatio(touches[i].clientY);\n                updatePointerMoveData(pointer, posX, posY, pointer.color);\n            }\n        }, false);\n        window.addEventListener(\"touchend\", (e)=>{\n            const touches = e.changedTouches;\n            let pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                updatePointerUpData(pointer);\n            }\n        });\n        updateFrame();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        SIM_RESOLUTION,\n        DYE_RESOLUTION,\n        CAPTURE_RESOLUTION,\n        DENSITY_DISSIPATION,\n        VELOCITY_DISSIPATION,\n        PRESSURE,\n        PRESSURE_ITERATIONS,\n        CURL,\n        SPLAT_RADIUS,\n        SPLAT_FORCE,\n        SHADING,\n        COLOR_UPDATE_SPEED,\n        BACK_COLOR,\n        TRANSPARENT\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed top-0 left-0 z-50 pointer-events-none\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n            ref: canvasRef,\n            id: \"fluid\",\n            className: \"w-screen h-screen\"\n        }, void 0, false, {\n            fileName: \"/Users/adamsoto/Desktop/GEOSEO_LandingPage/src/components/ui/splash-cursor.tsx\",\n            lineNumber: 1319,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/adamsoto/Desktop/GEOSEO_LandingPage/src/components/ui/splash-cursor.tsx\",\n        lineNumber: 1318,\n        columnNumber: 5\n    }, this);\n}\n_s(SplashCursor, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = SplashCursor;\n\nvar _c;\n$RefreshReg$(_c, \"SplashCursor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL3NwbGFzaC1jdXJzb3IudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUMwQztBQUUxQyxTQUFTRSxhQUFhLEtBZ0JyQjtRQWhCcUIsRUFDcEIsZ0RBQWdEO0lBQ2hEQyxpQkFBaUIsR0FBRyxFQUNwQkMsaUJBQWlCLElBQUksRUFDckJDLHFCQUFxQixHQUFHLEVBQ3hCQyxzQkFBc0IsR0FBRyxFQUN6QkMsdUJBQXVCLENBQUMsRUFDeEJDLFdBQVcsR0FBRyxFQUNkQyxzQkFBc0IsRUFBRSxFQUN4QkMsT0FBTyxDQUFDLEVBQ1JDLGVBQWUsR0FBRyxFQUNsQkMsY0FBYyxJQUFJLEVBQ2xCQyxVQUFVLElBQUksRUFDZEMscUJBQXFCLEVBQUUsRUFDdkJDLGFBQWE7UUFBRUMsR0FBRztRQUFLQyxHQUFHO1FBQUdDLEdBQUc7SUFBRSxDQUFDLEVBQ25DQyxjQUFjLElBQUksRUFDbkIsR0FoQnFCOztJQWlCcEIsTUFBTUMsWUFBWW5CLDZDQUFNQSxDQUFDO0lBRXpCRCxnREFBU0EsQ0FBQztRQUNSLE1BQU1xQixTQUFTRCxVQUFVRSxPQUFPO1FBQ2hDLElBQUksQ0FBQ0QsUUFBUTtRQUViLE1BQU1FOztxQkFDSkMsS0FBSyxDQUFDO3FCQUNOQyxZQUFZO3FCQUNaQyxZQUFZO3FCQUNaQyxnQkFBZ0I7cUJBQ2hCQyxnQkFBZ0I7cUJBQ2hCQyxTQUFTO3FCQUNUQyxTQUFTO3FCQUNUQyxPQUFPO3FCQUNQQyxRQUFRO3FCQUNSQyxRQUFRO29CQUFDO29CQUFHO29CQUFHO2lCQUFFOztRQUNuQjtRQUVBLElBQUlDLFNBQVM7WUFDWC9CO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FxQixRQUFRO1lBQ1JwQjtZQUNBSTtRQUNGO1FBRUEsSUFBSWlCLFdBQVc7WUFBQyxJQUFJYjtTQUFVO1FBRTlCLE1BQU0sRUFBRWMsRUFB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WSxDQUFDQztZQUNuQyxNQUFNUSxVQUFVUixFQUFFVyxjQUFjO1lBQ2hDLElBQUlwRCxVQUFVcE8sUUFBUSxDQUFDLEVBQUU7WUFDekIsSUFBSyxJQUFJNEQsSUFBSSxHQUFHQSxJQUFJeU4sUUFBUXhOLE1BQU0sRUFBRUQsSUFBSztnQkFDdkM2TCxvQkFBb0JyQjtZQUN0QjtRQUNGO1FBRUFsQztJQUNBLHVEQUF1RDtJQUN6RCxHQUFHO1FBQ0RuTztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBSTtLQUNEO0lBRUQscUJBQ0UsOERBQUMwUztRQUFJQyxXQUFVO2tCQUNiLDRFQUFDelM7WUFBTzBTLEtBQUszUztZQUFXSSxJQUFHO1lBQVFzUyxXQUFVOzs7Ozs7Ozs7OztBQUduRDtHQXR5Q1M1VDtLQUFBQTtBQXd5Q2UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvc3BsYXNoLWN1cnNvci50c3g/YWFkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5cbmZ1bmN0aW9uIFNwbGFzaEN1cnNvcih7XG4gIC8vIEFkZCB3aGF0ZXZlciBwcm9wcyB5b3UgbGlrZSBmb3IgY3VzdG9taXphdGlvblxuICBTSU1fUkVTT0xVVElPTiA9IDEyOCxcbiAgRFlFX1JFU09MVVRJT04gPSAxNDQwLFxuICBDQVBUVVJFX1JFU09MVVRJT04gPSA1MTIsXG4gIERFTlNJVFlfRElTU0lQQVRJT04gPSAzLjUsXG4gIFZFTE9DSVRZX0RJU1NJUEFUSU9OID0gMixcbiAgUFJFU1NVUkUgPSAwLjEsXG4gIFBSRVNTVVJFX0lURVJBVElPTlMgPSAyMCxcbiAgQ1VSTCA9IDMsXG4gIFNQTEFUX1JBRElVUyA9IDAuMixcbiAgU1BMQVRfRk9SQ0UgPSA2MDAwLFxuICBTSEFESU5HID0gdHJ1ZSxcbiAgQ09MT1JfVVBEQVRFX1NQRUVEID0gMTAsXG4gIEJBQ0tfQ09MT1IgPSB7IHI6IDAuNSwgZzogMCwgYjogMCB9LFxuICBUUkFOU1BBUkVOVCA9IHRydWUsXG59KSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSByZXR1cm47XG5cbiAgICBjbGFzcyBQb2ludGVyIHtcbiAgICAgIGlkID0gLTE7XG4gICAgICB0ZXhjb29yZFggPSAwO1xuICAgICAgdGV4Y29vcmRZID0gMDtcbiAgICAgIHByZXZUZXhjb29yZFggPSAwO1xuICAgICAgcHJldlRleGNvb3JkWSA9IDA7XG4gICAgICBkZWx0YVggPSAwO1xuICAgICAgZGVsdGFZID0gMDtcbiAgICAgIGRvd24gPSBmYWxzZTtcbiAgICAgIG1vdmVkID0gZmFsc2U7XG4gICAgICBjb2xvciA9IFswLCAwLCAwXTtcbiAgICB9XG5cbiAgICBsZXQgY29uZmlnID0ge1xuICAgICAgU0lNX1JFU09MVVRJT04sXG4gICAgICBEWUVfUkVTT0xVVElPTixcbiAgICAgIENBUFRVUkVfUkVTT0xVVElPTixcbiAgICAgIERFTlNJVFlfRElTU0lQQVRJT04sXG4gICAgICBWRUxPQ0lUWV9ESVNTSVBBVElPTixcbiAgICAgIFBSRVNTVVJFLFxuICAgICAgUFJFU1NVUkVfSVRFUkFUSU9OUyxcbiAgICAgIENVUkwsXG4gICAgICBTUExBVF9SQURJVVMsXG4gICAgICBTUExBVF9GT1JDRSxcbiAgICAgIFNIQURJTkcsXG4gICAgICBDT0xPUl9VUERBVEVfU1BFRUQsXG4gICAgICBQQVVTRUQ6IGZhbHNlLFxuICAgICAgQkFDS19DT0xPUixcbiAgICAgIFRSQU5TUEFSRU5ULFxuICAgIH07XG5cbiAgICBsZXQgcG9pbnRlcnMgPSBbbmV3IFBvaW50ZXIoKV07XG5cbiAgICBjb25zdCB7IGdsLCBleHQgfSA9IGdldFdlYkdMQ29udGV4dChjYW52YXMpO1xuICAgIGlmICghZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcpIHtcbiAgICAgIGNvbmZpZy5EWUVfUkVTT0xVVElPTiA9IDI1NjtcbiAgICAgIGNvbmZpZy5TSEFESU5HID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2ViR0xDb250ZXh0KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgYWxwaGE6IHRydWUsXG4gICAgICAgIGRlcHRoOiBmYWxzZSxcbiAgICAgICAgc3RlbmNpbDogZmFsc2UsXG4gICAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgICB9O1xuICAgICAgbGV0IGdsID1cbiAgICAgICAgKGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIHBhcmFtcykgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCB8IG51bGwpIHx8XG4gICAgICAgIChjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIHBhcmFtcykgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHwgbnVsbCkgfHxcbiAgICAgICAgKGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIHBhcmFtcykgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHwgbnVsbCk7XG4gICAgICBpZiAoIWdsKSByZXR1cm4geyBnbDogbnVsbCwgZXh0OiB7fSB9O1xuICAgICAgY29uc3QgaXNXZWJHTDIgPSAoZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KTtcbiAgICAgIGxldCBoYWxmRmxvYXQ7XG4gICAgICBsZXQgc3VwcG9ydExpbmVhckZpbHRlcmluZztcbiAgICAgIGlmIChpc1dlYkdMMikge1xuICAgICAgICAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKTtcbiAgICAgICAgc3VwcG9ydExpbmVhckZpbHRlcmluZyA9IChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYWxmRmxvYXQgPSAoZ2wgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0KS5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpO1xuICAgICAgICBzdXBwb3J0TGluZWFyRmlsdGVyaW5nID0gKGdsIGFzIFdlYkdMUmVuZGVyaW5nQ29udGV4dCkuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXJcIik7XG4gICAgICB9XG4gICAgICBnbC5jbGVhckNvbG9yKDAuMCwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICBjb25zdCBoYWxmRmxvYXRUZXhUeXBlID0gaXNXZWJHTDJcbiAgICAgICAgPyAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuSEFMRl9GTE9BVFxuICAgICAgICA6IGhhbGZGbG9hdCAmJiBoYWxmRmxvYXQuSEFMRl9GTE9BVF9PRVM7XG4gICAgICBsZXQgZm9ybWF0UkdCQTtcbiAgICAgIGxldCBmb3JtYXRSRztcbiAgICAgIGxldCBmb3JtYXRSO1xuXG4gICAgICBpZiAoaXNXZWJHTDIpIHtcbiAgICAgICAgZm9ybWF0UkdCQSA9IGdldFN1cHBvcnRlZEZvcm1hdChcbiAgICAgICAgICBnbCxcbiAgICAgICAgICAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuUkdCQTE2RixcbiAgICAgICAgICAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuUkdCQSxcbiAgICAgICAgICBoYWxmRmxvYXRUZXhUeXBlXG4gICAgICAgICk7XG4gICAgICAgIGZvcm1hdFJHID1cbiAgICAgICAgICAnUkcxNkYnIGluIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSAmJiAnUkcnIGluIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KVxuICAgICAgICAgICAgPyBnZXRTdXBwb3J0ZWRGb3JtYXQoXG4gICAgICAgICAgICAgICAgZ2wsXG4gICAgICAgICAgICAgICAgKGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpLlJHMTZGLFxuICAgICAgICAgICAgICAgIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5SRyxcbiAgICAgICAgICAgICAgICBoYWxmRmxvYXRUZXhUeXBlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgZm9ybWF0UiA9XG4gICAgICAgICAgJ1IxNkYnIGluIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSAmJiAnUkVEJyBpbiAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dClcbiAgICAgICAgICAgID8gZ2V0U3VwcG9ydGVkRm9ybWF0KFxuICAgICAgICAgICAgICAgIGdsLFxuICAgICAgICAgICAgICAgIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5SMTZGLFxuICAgICAgICAgICAgICAgIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5SRUQsXG4gICAgICAgICAgICAgICAgaGFsZkZsb2F0VGV4VHlwZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IGdldFN1cHBvcnRlZEZvcm1hdChnbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtYXRSR0JBID0gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCAoZ2wgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0KS5SR0JBLCAoZ2wgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0KS5SR0JBLCBoYWxmRmxvYXRUZXhUeXBlKTtcbiAgICAgICAgZm9ybWF0UkcgPSBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIChnbCBhcyBXZWJHTFJlbmRlcmluZ0NvbnRleHQpLlJHQkEsIChnbCBhcyBXZWJHTFJlbmRlcmluZ0NvbnRleHQpLlJHQkEsIGhhbGZGbG9hdFRleFR5cGUpO1xuICAgICAgICBmb3JtYXRSID0gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCAoZ2wgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0KS5SR0JBLCAoZ2wgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0KS5SR0JBLCBoYWxmRmxvYXRUZXhUeXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2wsXG4gICAgICAgIGV4dDoge1xuICAgICAgICAgIGZvcm1hdFJHQkEsXG4gICAgICAgICAgZm9ybWF0UkcsXG4gICAgICAgICAgZm9ybWF0UixcbiAgICAgICAgICBoYWxmRmxvYXRUZXhUeXBlLFxuICAgICAgICAgIHN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN1cHBvcnRlZEZvcm1hdChcbiAgICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LFxuICAgICAgaW50ZXJuYWxGb3JtYXQ6IGFueSxcbiAgICAgIGZvcm1hdDogYW55LFxuICAgICAgdHlwZTogYW55XG4gICAgKSB7XG4gICAgICBpZiAoIWdsKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmICghc3VwcG9ydFJlbmRlclRleHR1cmVGb3JtYXQoZ2wsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUpKSB7XG4gICAgICAgIHN3aXRjaCAoaW50ZXJuYWxGb3JtYXQpIHtcbiAgICAgICAgICBjYXNlIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5SMTZGOlxuICAgICAgICAgICAgcmV0dXJuIGdldFN1cHBvcnRlZEZvcm1hdChnbCwgKGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpLlJHMTZGLCAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuUkcsIHR5cGUpO1xuICAgICAgICAgIGNhc2UgKGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpLlJHMTZGOlxuICAgICAgICAgICAgcmV0dXJuIGdldFN1cHBvcnRlZEZvcm1hdChnbCwgKGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpLlJHQkExNkYsIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5SR0JBLCB0eXBlKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGludGVybmFsRm9ybWF0LFxuICAgICAgICBmb3JtYXQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1cHBvcnRSZW5kZXJUZXh0dXJlRm9ybWF0KFxuICAgICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsXG4gICAgICBpbnRlcm5hbEZvcm1hdDogYW55LFxuICAgICAgZm9ybWF0OiBhbnksXG4gICAgICB0eXBlOiBhbnlcbiAgICApIHtcbiAgICAgIGlmICghZ2wpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBpZiAoIXRleHR1cmUpIHJldHVybiBmYWxzZTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIDAsXG4gICAgICAgIGludGVybmFsRm9ybWF0LFxuICAgICAgICA0LFxuICAgICAgICA0LFxuICAgICAgICAwLFxuICAgICAgICBmb3JtYXQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgICBjb25zdCBmYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgaWYgKCFmYm8pIHJldHVybiBmYWxzZTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmJvKTtcbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICBnbC5GUkFNRUJVRkZFUixcbiAgICAgICAgZ2wuQ09MT1JfQVRUQUNITUVOVDAsXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIHRleHR1cmUsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBjb25zdCBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcbiAgICAgIHJldHVybiBzdGF0dXMgPT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFO1xuICAgIH1cblxuICAgIGNsYXNzIE1hdGVyaWFsIHtcbiAgICAgIHZlcnRleFNoYWRlcjogYW55O1xuICAgICAgZnJhZ21lbnRTaGFkZXJTb3VyY2U6IGFueTtcbiAgICAgIHByb2dyYW1zOiBhbnlbXTtcbiAgICAgIGFjdGl2ZVByb2dyYW06IGFueTtcbiAgICAgIHVuaWZvcm1zOiBhbnlbXTtcbiAgICAgIGNvbnN0cnVjdG9yKHZlcnRleFNoYWRlcjogYW55LCBmcmFnbWVudFNoYWRlclNvdXJjZTogYW55KSB7XG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyO1xuICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyU291cmNlID0gZnJhZ21lbnRTaGFkZXJTb3VyY2U7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVQcm9ncmFtID0gbnVsbDtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IFtdO1xuICAgICAgfVxuICAgICAgc2V0S2V5d29yZHMoa2V5d29yZHM6IGFueSkge1xuICAgICAgICBpZiAoIWdsKSByZXR1cm47XG4gICAgICAgIGxldCBoYXNoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXl3b3Jkcy5sZW5ndGg7IGkrKykgaGFzaCArPSBoYXNoQ29kZShrZXl3b3Jkc1tpXSk7XG4gICAgICAgIGxldCBwcm9ncmFtID0gdGhpcy5wcm9ncmFtc1toYXNoXTtcbiAgICAgICAgaWYgKHByb2dyYW0gPT0gbnVsbCkge1xuICAgICAgICAgIGxldCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICAgICAgICBnbCA/IGdsLkZSQUdNRU5UX1NIQURFUiA6IDM1NjMyLFxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFNoYWRlclNvdXJjZSxcbiAgICAgICAgICAgIGtleXdvcmRzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSh0aGlzLnZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgICAgIHRoaXMucHJvZ3JhbXNbaGFzaF0gPSBwcm9ncmFtO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmFtID09PSB0aGlzLmFjdGl2ZVByb2dyYW0pIHJldHVybjtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IGdldFVuaWZvcm1zKHByb2dyYW0pO1xuICAgICAgICB0aGlzLmFjdGl2ZVByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgfVxuICAgICAgYmluZCgpIHtcbiAgICAgICAgaWYgKCFnbCkgcmV0dXJuO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMuYWN0aXZlUHJvZ3JhbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgUHJvZ3JhbSB7XG4gICAgICB1bmlmb3JtczogYW55O1xuICAgICAgcHJvZ3JhbTogYW55O1xuICAgICAgY29uc3RydWN0b3IodmVydGV4U2hhZGVyOiBhbnksIGZyYWdtZW50U2hhZGVyOiBhbnkpIHtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHt9O1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgICB0aGlzLnVuaWZvcm1zID0gZ2V0VW5pZm9ybXModGhpcy5wcm9ncmFtKTtcbiAgICAgIH1cbiAgICAgIGJpbmQoKSB7XG4gICAgICAgIGlmICghZ2wpIHJldHVybjtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFVuaWZvcm1zKHByb2dyYW06IGFueSk6IGFueSB7XG4gICAgICBpZiAoIWdsKSByZXR1cm4gW107XG4gICAgICBsZXQgdW5pZm9ybXM6IFJlY29yZDxzdHJpbmcsIFdlYkdMVW5pZm9ybUxvY2F0aW9uIHwgbnVsbD4gPSB7fTtcbiAgICAgIGxldCB1bmlmb3JtQ291bnQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuaWZvcm1Db3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1JbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKTtcbiAgICAgICAgaWYgKCF1bmlmb3JtSW5mbykgY29udGludWU7XG4gICAgICAgIGxldCB1bmlmb3JtTmFtZSA9IHVuaWZvcm1JbmZvLm5hbWU7XG4gICAgICAgIHVuaWZvcm1zW3VuaWZvcm1OYW1lXSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5pZm9ybXMgYXMgYW55O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIodHlwZTogYW55LCBzb3VyY2U6IGFueSwga2V5d29yZHM6IGFueSkge1xuICAgICAgaWYgKCFnbCkgcmV0dXJuIG51bGw7XG4gICAgICBzb3VyY2UgPSBhZGRLZXl3b3Jkcyhzb3VyY2UsIGtleXdvcmRzIHx8IFtdKTtcbiAgICAgIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICAgIGlmICghc2hhZGVyKSByZXR1cm4gbnVsbDtcbiAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XG4gICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSlcbiAgICAgICAgY29uc29sZS50cmFjZShnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtKHZlcnRleFNoYWRlcjogYW55LCBmcmFnbWVudFNoYWRlcjogYW55KSB7XG4gICAgICBpZiAoIWdsIHx8ICF2ZXJ0ZXhTaGFkZXIgfHwgIWZyYWdtZW50U2hhZGVyKSByZXR1cm4gbnVsbDtcbiAgICAgIGxldCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgaWYgKCFwcm9ncmFtKSByZXR1cm4gbnVsbDtcbiAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIgYXMgV2ViR0xTaGFkZXIpO1xuICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyIGFzIFdlYkdMU2hhZGVyKTtcbiAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSlcbiAgICAgICAgY29uc29sZS50cmFjZShnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRLZXl3b3Jkcyhzb3VyY2U6IGFueSwga2V5d29yZHM6IGFueSkge1xuICAgICAgaWYgKCFrZXl3b3JkcykgcmV0dXJuIHNvdXJjZTtcbiAgICAgIGxldCBrZXl3b3Jkc1N0cmluZyA9IFwiXCI7XG4gICAgICBrZXl3b3Jkcy5mb3JFYWNoKChrZXl3b3JkOiBhbnkpID0+IHtcbiAgICAgICAga2V5d29yZHNTdHJpbmcgKz0gXCIjZGVmaW5lIFwiICsga2V5d29yZCArIFwiXFxuXCI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBrZXl3b3Jkc1N0cmluZyArIHNvdXJjZTtcbiAgICB9XG5cbiAgICBjb25zdCBiYXNlVmVydGV4U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsID8gZ2wuVkVSVEVYX1NIQURFUiA6IDM1NjMzLFxuICAgICAgYFxuICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZMO1xuICAgICAgICB2YXJ5aW5nIHZlYzIgdlI7XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZCO1xuICAgICAgICB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xuXG4gICAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgICB2VXYgPSBhUG9zaXRpb24gKiAwLjUgKyAwLjU7XG4gICAgICAgICAgICB2TCA9IHZVdiAtIHZlYzIodGV4ZWxTaXplLngsIDAuMCk7XG4gICAgICAgICAgICB2UiA9IHZVdiArIHZlYzIodGV4ZWxTaXplLngsIDAuMCk7XG4gICAgICAgICAgICB2VCA9IHZVdiArIHZlYzIoMC4wLCB0ZXhlbFNpemUueSk7XG4gICAgICAgICAgICB2QiA9IHZVdiAtIHZlYzIoMC4wLCB0ZXhlbFNpemUueSk7XG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uLCAwLjAsIDEuMCk7XG4gICAgICAgIH1cbiAgICAgIGAsXG4gICAgICBbXVxuICAgICk7XG5cbiAgICBjb25zdCBjb3B5U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsID8gZ2wuRlJBR01FTlRfU0hBREVSIDogMzU2MzIsXG4gICAgICBgXG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuXG4gICAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZVdik7XG4gICAgICAgIH1cbiAgICAgIGAsXG4gICAgICBbXVxuICAgICk7XG5cbiAgICBjb25zdCBjbGVhclNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbCA/IGdsLkZSQUdNRU5UX1NIQURFUiA6IDM1NjMyLFxuICAgICAgYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB2YWx1ZTtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmFsdWUgKiB0ZXh0dXJlMkQodVRleHR1cmUsIHZVdik7XG4gICAgICAgIH1cbiAgICAgYCxcbiAgICAgIFtdXG4gICAgKTtcblxuICAgIGNvbnN0IGRpc3BsYXlTaGFkZXJTb3VyY2UgPSBgXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2UjtcbiAgICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2QjtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdURpdGhlcmluZztcbiAgICAgIHVuaWZvcm0gdmVjMiBkaXRoZXJTY2FsZTtcbiAgICAgIHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XG5cbiAgICAgIHZlYzMgbGluZWFyVG9HYW1tYSAodmVjMyBjb2xvcikge1xuICAgICAgICAgIGNvbG9yID0gbWF4KGNvbG9yLCB2ZWMzKDApKTtcbiAgICAgICAgICByZXR1cm4gbWF4KDEuMDU1ICogcG93KGNvbG9yLCB2ZWMzKDAuNDE2NjY2NjY3KSkgLSAwLjA1NSwgdmVjMygwKSk7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgdmVjMyBjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpLnJnYjtcbiAgICAgICAgICAjaWZkZWYgU0hBRElOR1xuICAgICAgICAgICAgICB2ZWMzIGxjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2TCkucmdiO1xuICAgICAgICAgICAgICB2ZWMzIHJjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2UikucmdiO1xuICAgICAgICAgICAgICB2ZWMzIHRjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VCkucmdiO1xuICAgICAgICAgICAgICB2ZWMzIGJjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2QikucmdiO1xuXG4gICAgICAgICAgICAgIGZsb2F0IGR4ID0gbGVuZ3RoKHJjKSAtIGxlbmd0aChsYyk7XG4gICAgICAgICAgICAgIGZsb2F0IGR5ID0gbGVuZ3RoKHRjKSAtIGxlbmd0aChiYyk7XG5cbiAgICAgICAgICAgICAgdmVjMyBuID0gbm9ybWFsaXplKHZlYzMoZHgsIGR5LCBsZW5ndGgodGV4ZWxTaXplKSkpO1xuICAgICAgICAgICAgICB2ZWMzIGwgPSB2ZWMzKDAuMCwgMC4wLCAxLjApO1xuXG4gICAgICAgICAgICAgIGZsb2F0IGRpZmZ1c2UgPSBjbGFtcChkb3QobiwgbCkgKyAwLjcsIDAuNywgMS4wKTtcbiAgICAgICAgICAgICAgYyAqPSBkaWZmdXNlO1xuICAgICAgICAgICNlbmRpZlxuXG4gICAgICAgICAgZmxvYXQgYSA9IG1heChjLnIsIG1heChjLmcsIGMuYikpO1xuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoYywgYSk7XG4gICAgICB9XG4gICAgYDtcblxuICAgIGNvbnN0IHNwbGF0U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsID8gZ2wuRlJBR01FTlRfU0hBREVSIDogMzU2MzIsXG4gICAgICBgXG4gICAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRhcmdldDtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBhc3BlY3RSYXRpbztcbiAgICAgICAgdW5pZm9ybSB2ZWMzIGNvbG9yO1xuICAgICAgICB1bmlmb3JtIHZlYzIgcG9pbnQ7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgcmFkaXVzO1xuXG4gICAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgICB2ZWMyIHAgPSB2VXYgLSBwb2ludC54eTtcbiAgICAgICAgICAgIHAueCAqPSBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIHZlYzMgc3BsYXQgPSBleHAoLWRvdChwLCBwKSAvIHJhZGl1cykgKiBjb2xvcjtcbiAgICAgICAgICAgIHZlYzMgYmFzZSA9IHRleHR1cmUyRCh1VGFyZ2V0LCB2VXYpLnh5ejtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoYmFzZSArIHNwbGF0LCAxLjApO1xuICAgICAgICB9XG4gICAgICBgLFxuICAgICAgW11cbiAgICApO1xuXG4gICAgY29uc3QgYWR2ZWN0aW9uU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsID8gZ2wuRlJBR01FTlRfU0hBREVSIDogMzU2MzIsXG4gICAgICBgXG4gICAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVZlbG9jaXR5O1xuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U291cmNlO1xuICAgICAgICB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xuICAgICAgICB1bmlmb3JtIHZlYzIgZHllVGV4ZWxTaXplO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IGR0O1xuICAgICAgICB1bmlmb3JtIGZsb2F0IGRpc3NpcGF0aW9uO1xuXG4gICAgICAgIHZlYzQgYmlsZXJwIChzYW1wbGVyMkQgc2FtLCB2ZWMyIHV2LCB2ZWMyIHRzaXplKSB7XG4gICAgICAgICAgICB2ZWMyIHN0ID0gdXYgLyB0c2l6ZSAtIDAuNTtcbiAgICAgICAgICAgIHZlYzIgaXV2ID0gZmxvb3Ioc3QpO1xuICAgICAgICAgICAgdmVjMiBmdXYgPSBmcmFjdChzdCk7XG5cbiAgICAgICAgICAgIHZlYzQgYSA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDAuNSwgMC41KSkgKiB0c2l6ZSk7XG4gICAgICAgICAgICB2ZWM0IGIgPSB0ZXh0dXJlMkQoc2FtLCAoaXV2ICsgdmVjMigxLjUsIDAuNSkpICogdHNpemUpO1xuICAgICAgICAgICAgdmVjNCBjID0gdGV4dHVyZTJEKHNhbSwgKGl1diArIHZlYzIoMC41LCAxLjUpKSAqIHRzaXplKTtcbiAgICAgICAgICAgIHZlYzQgZCA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDEuNSwgMS41KSkgKiB0c2l6ZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBtaXgobWl4KGEsIGIsIGZ1di54KSwgbWl4KGMsIGQsIGZ1di54KSwgZnV2LnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICAgICNpZmRlZiBNQU5VQUxfRklMVEVSSU5HXG4gICAgICAgICAgICAgICAgdmVjMiBjb29yZCA9IHZVdiAtIGR0ICogYmlsZXJwKHVWZWxvY2l0eSwgdlV2LCB0ZXhlbFNpemUpLnh5ICogdGV4ZWxTaXplO1xuICAgICAgICAgICAgICAgIHZlYzQgcmVzdWx0ID0gYmlsZXJwKHVTb3VyY2UsIGNvb3JkLCBkeWVUZXhlbFNpemUpO1xuICAgICAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgICAgICB2ZWMyIGNvb3JkID0gdlV2IC0gZHQgKiB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VXYpLnh5ICogdGV4ZWxTaXplO1xuICAgICAgICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdGV4dHVyZTJEKHVTb3VyY2UsIGNvb3JkKTtcbiAgICAgICAgICAgICNlbmRpZlxuICAgICAgICAgICAgZmxvYXQgZGVjYXkgPSAxLjAgKyBkaXNzaXBhdGlvbiAqIGR0O1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gcmVzdWx0IC8gZGVjYXk7XG4gICAgICAgIH1cbiAgICAgIGAsXG4gICAgICBleHQgJiYgZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgPyBbXSA6IFtcIk1BTlVBTF9GSUxURVJJTkdcIl1cbiAgICApO1xuXG4gICAgY29uc3QgZGl2ZXJnZW5jZVNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbCA/IGdsLkZSQUdNRU5UX1NIQURFUiA6IDM1NjMyLFxuICAgICAgYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkw7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2UjtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkI7XG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZMKS54O1xuICAgICAgICAgICAgZmxvYXQgUiA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZSKS54O1xuICAgICAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZUKS55O1xuICAgICAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZCKS55O1xuXG4gICAgICAgICAgICB2ZWMyIEMgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VXYpLnh5O1xuICAgICAgICAgICAgaWYgKHZMLnggPCAwLjApIHsgTCA9IC1DLng7IH1cbiAgICAgICAgICAgIGlmICh2Ui54ID4gMS4wKSB7IFIgPSAtQy54OyB9XG4gICAgICAgICAgICBpZiAodlQueSA+IDEuMCkgeyBUID0gLUMueTsgfVxuICAgICAgICAgICAgaWYgKHZCLnkgPCAwLjApIHsgQiA9IC1DLnk7IH1cblxuICAgICAgICAgICAgZmxvYXQgZGl2ID0gMC41ICogKFIgLSBMICsgVCAtIEIpO1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChkaXYsIDAuMCwgMC4wLCAxLjApO1xuICAgICAgICB9XG4gICAgICBgLFxuICAgICAgW11cbiAgICApO1xuXG4gICAgY29uc3QgY3VybFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbCA/IGdsLkZSQUdNRU5UX1NIQURFUiA6IDM1NjMyLFxuICAgICAgYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkw7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2UjtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkI7XG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZMKS55O1xuICAgICAgICAgICAgZmxvYXQgUiA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZSKS55O1xuICAgICAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZUKS54O1xuICAgICAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZCKS54O1xuICAgICAgICAgICAgZmxvYXQgdm9ydGljaXR5ID0gUiAtIEwgLSBUICsgQjtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC41ICogdm9ydGljaXR5LCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgfVxuICAgICAgYCxcbiAgICAgIFtdXG4gICAgKTtcblxuICAgIGNvbnN0IHZvcnRpY2l0eVNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbCA/IGdsLkZSQUdNRU5UX1NIQURFUiA6IDM1NjMyLFxuICAgICAgYFxuICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgICAgICB2YXJ5aW5nIHZlYzIgdlQ7XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2QjtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVZlbG9jaXR5O1xuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1Q3VybDtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBjdXJsO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IGR0O1xuXG4gICAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgICBmbG9hdCBMID0gdGV4dHVyZTJEKHVDdXJsLCB2TCkueDtcbiAgICAgICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodUN1cmwsIHZSKS54O1xuICAgICAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1Q3VybCwgdlQpLng7XG4gICAgICAgICAgICBmbG9hdCBCID0gdGV4dHVyZTJEKHVDdXJsLCB2QikueDtcbiAgICAgICAgICAgIGZsb2F0IEMgPSB0ZXh0dXJlMkQodUN1cmwsIHZVdikueDtcblxuICAgICAgICAgICAgdmVjMiBmb3JjZSA9IDAuNSAqIHZlYzIoYWJzKFQpIC0gYWJzKEIpLCBhYnMoUikgLSBhYnMoTCkpO1xuICAgICAgICAgICAgZm9yY2UgLz0gbGVuZ3RoKGZvcmNlKSArIDAuMDAwMTtcbiAgICAgICAgICAgIGZvcmNlICo9IGN1cmwgKiBDO1xuICAgICAgICAgICAgZm9yY2UueSAqPSAtMS4wO1xuXG4gICAgICAgICAgICB2ZWMyIHZlbG9jaXR5ID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eTtcbiAgICAgICAgICAgIHZlbG9jaXR5ICs9IGZvcmNlICogZHQ7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IG1pbihtYXgodmVsb2NpdHksIC0xMDAwLjApLCAxMDAwLjApO1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWxvY2l0eSwgMC4wLCAxLjApO1xuICAgICAgICB9XG4gICAgICBgLFxuICAgICAgW11cbiAgICApO1xuXG4gICAgY29uc3QgcHJlc3N1cmVTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wgPyBnbC5GUkFHTUVOVF9TSEFERVIgOiAzNTYzMixcbiAgICAgIGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1UHJlc3N1cmU7XG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVEaXZlcmdlbmNlO1xuXG4gICAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgICBmbG9hdCBMID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdkwpLng7XG4gICAgICAgICAgICBmbG9hdCBSID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdlIpLng7XG4gICAgICAgICAgICBmbG9hdCBUID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdlQpLng7XG4gICAgICAgICAgICBmbG9hdCBCID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdkIpLng7XG4gICAgICAgICAgICBmbG9hdCBDID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdlV2KS54O1xuICAgICAgICAgICAgZmxvYXQgZGl2ZXJnZW5jZSA9IHRleHR1cmUyRCh1RGl2ZXJnZW5jZSwgdlV2KS54O1xuICAgICAgICAgICAgZmxvYXQgcHJlc3N1cmUgPSAoTCArIFIgKyBCICsgVCAtIGRpdmVyZ2VuY2UpICogMC4yNTtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQocHJlc3N1cmUsIDAuMCwgMC4wLCAxLjApO1xuICAgICAgICB9XG4gICAgICBgLFxuICAgICAgW11cbiAgICApO1xuXG4gICAgY29uc3QgZ3JhZGllbnRTdWJ0cmFjdFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbCA/IGdsLkZSQUdNRU5UX1NIQURFUiA6IDM1NjMyLFxuICAgICAgYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkw7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2UjtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkI7XG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVQcmVzc3VyZTtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVZlbG9jaXR5O1xuXG4gICAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgICBmbG9hdCBMID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdkwpLng7XG4gICAgICAgICAgICBmbG9hdCBSID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdlIpLng7XG4gICAgICAgICAgICBmbG9hdCBUID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdlQpLng7XG4gICAgICAgICAgICBmbG9hdCBCID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdkIpLng7XG4gICAgICAgICAgICB2ZWMyIHZlbG9jaXR5ID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eTtcbiAgICAgICAgICAgIHZlbG9jaXR5Lnh5IC09IHZlYzIoUiAtIEwsIFQgLSBCKTtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVsb2NpdHksIDAuMCwgMS4wKTtcbiAgICAgICAgfVxuICAgICAgYCxcbiAgICAgIFtdXG4gICAgKTtcblxuICAgIGNvbnN0IGJsaXQgPSAoKCkgPT4ge1xuICAgICAgaWYgKCFnbCkgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBjb250ZXh0IG5vdCBhdmFpbGFibGUnKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBnbC5jcmVhdGVCdWZmZXIoKSk7XG4gICAgICBnbC5idWZmZXJEYXRhKFxuICAgICAgICBnbC5BUlJBWV9CVUZGRVIsXG4gICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAtMSwgLTEsIDEsIDEsIDEsIDEsIC0xXSksXG4gICAgICAgIGdsLlNUQVRJQ19EUkFXXG4gICAgICApO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShcbiAgICAgICAgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsXG4gICAgICAgIG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMCwgMiwgM10pLFxuICAgICAgICBnbC5TVEFUSUNfRFJBV1xuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoMCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KDApO1xuICAgICAgcmV0dXJuICh0YXJnZXQ6IGFueSwgY2xlYXIgPSBmYWxzZSkgPT4ge1xuICAgICAgICBpZiAoIWdsKSByZXR1cm47XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG4gICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHQpO1xuICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGFyZ2V0LmZibyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsZWFyKSB7XG4gICAgICAgICAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAxLjApO1xuICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICB9XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIGxldCBkeWU6IGFueSwgdmVsb2NpdHk6IGFueSwgZGl2ZXJnZW5jZTogYW55LCBjdXJsOiBhbnksIHByZXNzdXJlOiBhbnk7XG5cbiAgICBjb25zdCBjb3B5UHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGNvcHlTaGFkZXIpO1xuICAgIGNvbnN0IGNsZWFyUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGNsZWFyU2hhZGVyKTtcbiAgICBjb25zdCBzcGxhdFByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBzcGxhdFNoYWRlcik7XG4gICAgY29uc3QgYWR2ZWN0aW9uUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGFkdmVjdGlvblNoYWRlcik7XG4gICAgY29uc3QgZGl2ZXJnZW5jZVByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBkaXZlcmdlbmNlU2hhZGVyKTtcbiAgICBjb25zdCBjdXJsUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGN1cmxTaGFkZXIpO1xuICAgIGNvbnN0IHZvcnRpY2l0eVByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCB2b3J0aWNpdHlTaGFkZXIpO1xuICAgIGNvbnN0IHByZXNzdXJlUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIHByZXNzdXJlU2hhZGVyKTtcbiAgICBjb25zdCBncmFkaWVuU3VidHJhY3RQcm9ncmFtID0gbmV3IFByb2dyYW0oXG4gICAgICBiYXNlVmVydGV4U2hhZGVyLFxuICAgICAgZ3JhZGllbnRTdWJ0cmFjdFNoYWRlclxuICAgICk7XG4gICAgY29uc3QgZGlzcGxheU1hdGVyaWFsID0gbmV3IE1hdGVyaWFsKGJhc2VWZXJ0ZXhTaGFkZXIsIGRpc3BsYXlTaGFkZXJTb3VyY2UpO1xuXG4gICAgZnVuY3Rpb24gaW5pdEZyYW1lYnVmZmVycygpIHtcbiAgICAgIGlmICghZ2wpIHJldHVybjtcbiAgICAgIGxldCBzaW1SZXMgPSBnZXRSZXNvbHV0aW9uKGNvbmZpZy5TSU1fUkVTT0xVVElPTik7XG4gICAgICBsZXQgZHllUmVzID0gZ2V0UmVzb2x1dGlvbihjb25maWcuRFlFX1JFU09MVVRJT04pO1xuICAgICAgY29uc3QgdGV4VHlwZSA9IGV4dC5oYWxmRmxvYXRUZXhUeXBlO1xuICAgICAgY29uc3QgcmdiYSA9IGV4dC5mb3JtYXRSR0JBO1xuICAgICAgY29uc3QgcmcgPSBleHQuZm9ybWF0Ukc7XG4gICAgICBjb25zdCByID0gZXh0LmZvcm1hdFI7XG4gICAgICBjb25zdCBmaWx0ZXJpbmcgPSBleHQuc3VwcG9ydExpbmVhckZpbHRlcmluZyA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1Q7XG4gICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuICAgICAgaWYgKHJnYmEgJiYgIWR5ZSlcbiAgICAgICAgZHllID0gY3JlYXRlRG91YmxlRkJPKFxuICAgICAgICAgIGR5ZVJlcy53aWR0aCxcbiAgICAgICAgICBkeWVSZXMuaGVpZ2h0LFxuICAgICAgICAgIHJnYmEuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgICAgcmdiYS5mb3JtYXQsXG4gICAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgICBmaWx0ZXJpbmdcbiAgICAgICAgKTtcbiAgICAgIGVsc2UgaWYgKHJnYmEpXG4gICAgICAgIGR5ZSA9IHJlc2l6ZURvdWJsZUZCTyhcbiAgICAgICAgICBkeWUsXG4gICAgICAgICAgZHllUmVzLndpZHRoLFxuICAgICAgICAgIGR5ZVJlcy5oZWlnaHQsXG4gICAgICAgICAgcmdiYS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgICByZ2JhLmZvcm1hdCxcbiAgICAgICAgICB0ZXhUeXBlLFxuICAgICAgICAgIGZpbHRlcmluZ1xuICAgICAgICApO1xuXG4gICAgICBpZiAocmcgJiYgIXZlbG9jaXR5KVxuICAgICAgICB2ZWxvY2l0eSA9IGNyZWF0ZURvdWJsZUZCTyhcbiAgICAgICAgICBzaW1SZXMud2lkdGgsXG4gICAgICAgICAgc2ltUmVzLmhlaWdodCxcbiAgICAgICAgICByZy5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgICByZy5mb3JtYXQsXG4gICAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgICBmaWx0ZXJpbmdcbiAgICAgICAgKTtcbiAgICAgIGVsc2UgaWYgKHJnKVxuICAgICAgICB2ZWxvY2l0eSA9IHJlc2l6ZURvdWJsZUZCTyhcbiAgICAgICAgICB2ZWxvY2l0eSxcbiAgICAgICAgICBzaW1SZXMud2lkdGgsXG4gICAgICAgICAgc2ltUmVzLmhlaWdodCxcbiAgICAgICAgICByZy5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgICByZy5mb3JtYXQsXG4gICAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgICBmaWx0ZXJpbmdcbiAgICAgICAgKTtcblxuICAgICAgaWYgKHIpIHtcbiAgICAgICAgZGl2ZXJnZW5jZSA9IGNyZWF0ZUZCTyhcbiAgICAgICAgICBzaW1SZXMud2lkdGgsXG4gICAgICAgICAgc2ltUmVzLmhlaWdodCxcbiAgICAgICAgICByLmludGVybmFsRm9ybWF0LFxuICAgICAgICAgIHIuZm9ybWF0LFxuICAgICAgICAgIHRleFR5cGUsXG4gICAgICAgICAgZ2wuTkVBUkVTVFxuICAgICAgICApO1xuICAgICAgICBjdXJsID0gY3JlYXRlRkJPKFxuICAgICAgICAgIHNpbVJlcy53aWR0aCxcbiAgICAgICAgICBzaW1SZXMuaGVpZ2h0LFxuICAgICAgICAgIHIuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgICAgci5mb3JtYXQsXG4gICAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgICBnbC5ORUFSRVNUXG4gICAgICAgICk7XG4gICAgICAgIHByZXNzdXJlID0gY3JlYXRlRG91YmxlRkJPKFxuICAgICAgICAgIHNpbVJlcy53aWR0aCxcbiAgICAgICAgICBzaW1SZXMuaGVpZ2h0LFxuICAgICAgICAgIHIuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgICAgci5mb3JtYXQsXG4gICAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgICBnbC5ORUFSRVNUXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRkJPKHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKSB7XG4gICAgICBpZiAoIWdsKSB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMIGNvbnRleHQgbm90IGF2YWlsYWJsZScpO1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICBsZXQgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGlmICghdGV4dHVyZSkgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIHRleHR1cmUnKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHBhcmFtKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBwYXJhbSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgMCxcbiAgICAgICAgaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgIHcsXG4gICAgICAgIGgsXG4gICAgICAgIDAsXG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcblxuICAgICAgbGV0IGZibyA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICBpZiAoIWZibykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGZyYW1lYnVmZmVyJyk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZibyk7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICB0ZXh0dXJlLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdywgaCk7XG4gICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcblxuICAgICAgbGV0IHRleGVsU2l6ZVggPSAxLjAgLyB3O1xuICAgICAgbGV0IHRleGVsU2l6ZVkgPSAxLjAgLyBoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dHVyZSxcbiAgICAgICAgZmJvLFxuICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICB0ZXhlbFNpemVYLFxuICAgICAgICB0ZXhlbFNpemVZLFxuICAgICAgICBhdHRhY2goaWQpIHtcbiAgICAgICAgICBpZiAoIWdsKSByZXR1cm4gaWQ7XG4gICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGlkKTtcbiAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURvdWJsZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSkge1xuICAgICAgaWYgKCFnbCkgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBjb250ZXh0IG5vdCBhdmFpbGFibGUnKTtcbiAgICAgIGxldCBmYm8xID0gY3JlYXRlRkJPKHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKTtcbiAgICAgIGxldCBmYm8yID0gY3JlYXRlRkJPKHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3LFxuICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgIHRleGVsU2l6ZVg6IGZibzEudGV4ZWxTaXplWCxcbiAgICAgICAgdGV4ZWxTaXplWTogZmJvMS50ZXhlbFNpemVZLFxuICAgICAgICBnZXQgcmVhZCgpIHtcbiAgICAgICAgICByZXR1cm4gZmJvMTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IHJlYWQodmFsdWUpIHtcbiAgICAgICAgICBmYm8xID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCB3cml0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gZmJvMjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IHdyaXRlKHZhbHVlKSB7XG4gICAgICAgICAgZmJvMiA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzd2FwKCkge1xuICAgICAgICAgIGxldCB0ZW1wID0gZmJvMTtcbiAgICAgICAgICBmYm8xID0gZmJvMjtcbiAgICAgICAgICBmYm8yID0gdGVtcDtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplRkJPKHRhcmdldCwgdywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pIHtcbiAgICAgIGxldCBuZXdGQk8gPSBjcmVhdGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pO1xuICAgICAgY29weVByb2dyYW0uYmluZCgpO1xuICAgICAgZ2wudW5pZm9ybTFpKGNvcHlQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCB0YXJnZXQuYXR0YWNoKDApKTtcbiAgICAgIGJsaXQobmV3RkJPKTtcbiAgICAgIHJldHVybiBuZXdGQk87XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplRG91YmxlRkJPKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdyxcbiAgICAgIGgsXG4gICAgICBpbnRlcm5hbEZvcm1hdCxcbiAgICAgIGZvcm1hdCxcbiAgICAgIHR5cGUsXG4gICAgICBwYXJhbVxuICAgICkge1xuICAgICAgaWYgKHRhcmdldC53aWR0aCA9PT0gdyAmJiB0YXJnZXQuaGVpZ2h0ID09PSBoKSByZXR1cm4gdGFyZ2V0O1xuICAgICAgdGFyZ2V0LnJlYWQgPSByZXNpemVGQk8oXG4gICAgICAgIHRhcmdldC5yZWFkLFxuICAgICAgICB3LFxuICAgICAgICBoLFxuICAgICAgICBpbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBwYXJhbVxuICAgICAgKTtcbiAgICAgIHRhcmdldC53cml0ZSA9IGNyZWF0ZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSk7XG4gICAgICB0YXJnZXQud2lkdGggPSB3O1xuICAgICAgdGFyZ2V0LmhlaWdodCA9IGg7XG4gICAgICB0YXJnZXQudGV4ZWxTaXplWCA9IDEuMCAvIHc7XG4gICAgICB0YXJnZXQudGV4ZWxTaXplWSA9IDEuMCAvIGg7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUtleXdvcmRzKCkge1xuICAgICAgbGV0IGRpc3BsYXlLZXl3b3JkcyA9IFtdO1xuICAgICAgaWYgKGNvbmZpZy5TSEFESU5HKSBkaXNwbGF5S2V5d29yZHMucHVzaChcIlNIQURJTkdcIik7XG4gICAgICBkaXNwbGF5TWF0ZXJpYWwuc2V0S2V5d29yZHMoZGlzcGxheUtleXdvcmRzKTtcbiAgICB9XG5cbiAgICB1cGRhdGVLZXl3b3JkcygpO1xuICAgIGluaXRGcmFtZWJ1ZmZlcnMoKTtcbiAgICBsZXQgbGFzdFVwZGF0ZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBjb2xvclVwZGF0ZVRpbWVyID0gMC4wO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlRnJhbWUoKSB7XG4gICAgICBjb25zdCBkdCA9IGNhbGNEZWx0YVRpbWUoKTtcbiAgICAgIGlmIChyZXNpemVDYW52YXMoKSkgaW5pdEZyYW1lYnVmZmVycygpO1xuICAgICAgdXBkYXRlQ29sb3JzKGR0KTtcbiAgICAgIGFwcGx5SW5wdXRzKCk7XG4gICAgICBzdGVwKGR0KTtcbiAgICAgIHJlbmRlcihudWxsKTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVGcmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY0RlbHRhVGltZSgpIHtcbiAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgbGV0IGR0ID0gKG5vdyAtIGxhc3RVcGRhdGVUaW1lKSAvIDEwMDA7XG4gICAgICBkdCA9IE1hdGgubWluKGR0LCAwLjAxNjY2Nik7XG4gICAgICBsYXN0VXBkYXRlVGltZSA9IG5vdztcbiAgICAgIHJldHVybiBkdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNpemVDYW52YXMoKSB7XG4gICAgICBsZXQgd2lkdGggPSBzY2FsZUJ5UGl4ZWxSYXRpbyhjYW52YXMuY2xpZW50V2lkdGgpO1xuICAgICAgbGV0IGhlaWdodCA9IHNjYWxlQnlQaXhlbFJhdGlvKGNhbnZhcy5jbGllbnRIZWlnaHQpO1xuICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVDb2xvcnMoZHQpIHtcbiAgICAgIGNvbG9yVXBkYXRlVGltZXIgKz0gZHQgKiBjb25maWcuQ09MT1JfVVBEQVRFX1NQRUVEO1xuICAgICAgaWYgKGNvbG9yVXBkYXRlVGltZXIgPj0gMSkge1xuICAgICAgICBjb2xvclVwZGF0ZVRpbWVyID0gd3JhcChjb2xvclVwZGF0ZVRpbWVyLCAwLCAxKTtcbiAgICAgICAgcG9pbnRlcnMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgIHAuY29sb3IgPSBnZW5lcmF0ZUNvbG9yKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5SW5wdXRzKCkge1xuICAgICAgcG9pbnRlcnMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICBpZiAocC5tb3ZlZCkge1xuICAgICAgICAgIHAubW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICBzcGxhdFBvaW50ZXIocCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0ZXAoZHQpIHtcbiAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgICAgLy8gQ3VybFxuICAgICAgY3VybFByb2dyYW0uYmluZCgpO1xuICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICBjdXJsUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWkoY3VybFByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LCB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgwKSk7XG4gICAgICBibGl0KGN1cmwpO1xuXG4gICAgICAvLyBWb3J0aWNpdHlcbiAgICAgIHZvcnRpY2l0eVByb2dyYW0uYmluZCgpO1xuICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICB2b3J0aWNpdHlQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xaShcbiAgICAgICAgdm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksXG4gICAgICAgIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFpKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMudUN1cmwsIGN1cmwuYXR0YWNoKDEpKTtcbiAgICAgIGdsLnVuaWZvcm0xZih2b3J0aWNpdHlQcm9ncmFtLnVuaWZvcm1zLmN1cmwsIGNvbmZpZy5DVVJMKTtcbiAgICAgIGdsLnVuaWZvcm0xZih2b3J0aWNpdHlQcm9ncmFtLnVuaWZvcm1zLmR0LCBkdCk7XG4gICAgICBibGl0KHZlbG9jaXR5LndyaXRlKTtcbiAgICAgIHZlbG9jaXR5LnN3YXAoKTtcblxuICAgICAgLy8gRGl2ZXJnZW5jZVxuICAgICAgZGl2ZXJnZW5jZVByb2dyYW0uYmluZCgpO1xuICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICBkaXZlcmdlbmNlUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWkoXG4gICAgICAgIGRpdmVyZ2VuY2VQcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSxcbiAgICAgICAgdmVsb2NpdHkucmVhZC5hdHRhY2goMClcbiAgICAgICk7XG4gICAgICBibGl0KGRpdmVyZ2VuY2UpO1xuXG4gICAgICAvLyBDbGVhciBwcmVzc3VyZVxuICAgICAgY2xlYXJQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGdsLnVuaWZvcm0xaShjbGVhclByb2dyYW0udW5pZm9ybXMudVRleHR1cmUsIHByZXNzdXJlLnJlYWQuYXR0YWNoKDApKTtcbiAgICAgIGdsLnVuaWZvcm0xZihjbGVhclByb2dyYW0udW5pZm9ybXMudmFsdWUsIGNvbmZpZy5QUkVTU1VSRSk7XG4gICAgICBibGl0KHByZXNzdXJlLndyaXRlKTtcbiAgICAgIHByZXNzdXJlLnN3YXAoKTtcblxuICAgICAgLy8gUHJlc3N1cmVcbiAgICAgIHByZXNzdXJlUHJvZ3JhbS5iaW5kKCk7XG4gICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgIHByZXNzdXJlUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWkocHJlc3N1cmVQcm9ncmFtLnVuaWZvcm1zLnVEaXZlcmdlbmNlLCBkaXZlcmdlbmNlLmF0dGFjaCgwKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZpZy5QUkVTU1VSRV9JVEVSQVRJT05TOyBpKyspIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKFxuICAgICAgICAgIHByZXNzdXJlUHJvZ3JhbS51bmlmb3Jtcy51UHJlc3N1cmUsXG4gICAgICAgICAgcHJlc3N1cmUucmVhZC5hdHRhY2goMSlcbiAgICAgICAgKTtcbiAgICAgICAgYmxpdChwcmVzc3VyZS53cml0ZSk7XG4gICAgICAgIHByZXNzdXJlLnN3YXAoKTtcbiAgICAgIH1cblxuICAgICAgLy8gR3JhZGllbnQgU3VidHJhY3RcbiAgICAgIGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0uYmluZCgpO1xuICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICBncmFkaWVuU3VidHJhY3RQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xaShcbiAgICAgICAgZ3JhZGllblN1YnRyYWN0UHJvZ3JhbS51bmlmb3Jtcy51UHJlc3N1cmUsXG4gICAgICAgIHByZXNzdXJlLnJlYWQuYXR0YWNoKDApXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFpKFxuICAgICAgICBncmFkaWVuU3VidHJhY3RQcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSxcbiAgICAgICAgdmVsb2NpdHkucmVhZC5hdHRhY2goMSlcbiAgICAgICk7XG4gICAgICBibGl0KHZlbG9jaXR5LndyaXRlKTtcbiAgICAgIHZlbG9jaXR5LnN3YXAoKTtcblxuICAgICAgLy8gQWR2ZWN0aW9uXG4gICAgICBhZHZlY3Rpb25Qcm9ncmFtLmJpbmQoKTtcbiAgICAgIGdsLnVuaWZvcm0yZihcbiAgICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgICAgICk7XG4gICAgICBpZiAoIWV4dC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nKVxuICAgICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5keWVUZXhlbFNpemUsXG4gICAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICAgICAgICk7XG4gICAgICBsZXQgdmVsb2NpdHlJZCA9IHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApO1xuICAgICAgZ2wudW5pZm9ybTFpKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LCB2ZWxvY2l0eUlkKTtcbiAgICAgIGdsLnVuaWZvcm0xaShhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnVTb3VyY2UsIHZlbG9jaXR5SWQpO1xuICAgICAgZ2wudW5pZm9ybTFmKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZHQsIGR0KTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5kaXNzaXBhdGlvbixcbiAgICAgICAgY29uZmlnLlZFTE9DSVRZX0RJU1NJUEFUSU9OXG4gICAgICApO1xuICAgICAgYmxpdCh2ZWxvY2l0eS53cml0ZSk7XG4gICAgICB2ZWxvY2l0eS5zd2FwKCk7XG5cbiAgICAgIGlmICghZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcpXG4gICAgICAgIGdsLnVuaWZvcm0yZihcbiAgICAgICAgICBhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmR5ZVRleGVsU2l6ZSxcbiAgICAgICAgICBkeWUudGV4ZWxTaXplWCxcbiAgICAgICAgICBkeWUudGV4ZWxTaXplWVxuICAgICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFpKFxuICAgICAgICBhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSxcbiAgICAgICAgdmVsb2NpdHkucmVhZC5hdHRhY2goMClcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWkoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy51U291cmNlLCBkeWUucmVhZC5hdHRhY2goMSkpO1xuICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICBhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmRpc3NpcGF0aW9uLFxuICAgICAgICBjb25maWcuREVOU0lUWV9ESVNTSVBBVElPTlxuICAgICAgKTtcbiAgICAgIGJsaXQoZHllLndyaXRlKTtcbiAgICAgIGR5ZS5zd2FwKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyKHRhcmdldCkge1xuICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgZHJhd0Rpc3BsYXkodGFyZ2V0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3RGlzcGxheSh0YXJnZXQpIHtcbiAgICAgIGxldCB3aWR0aCA9IHRhcmdldCA9PSBudWxsID8gZ2wuZHJhd2luZ0J1ZmZlcldpZHRoIDogdGFyZ2V0LndpZHRoO1xuICAgICAgbGV0IGhlaWdodCA9IHRhcmdldCA9PSBudWxsID8gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCA6IHRhcmdldC5oZWlnaHQ7XG4gICAgICBkaXNwbGF5TWF0ZXJpYWwuYmluZCgpO1xuICAgICAgaWYgKGNvbmZpZy5TSEFESU5HKVxuICAgICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgICAgZGlzcGxheU1hdGVyaWFsLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICAgICAgICAxLjAgLyB3aWR0aCxcbiAgICAgICAgICAxLjAgLyBoZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xaShkaXNwbGF5TWF0ZXJpYWwudW5pZm9ybXMudVRleHR1cmUsIGR5ZS5yZWFkLmF0dGFjaCgwKSk7XG4gICAgICBibGl0KHRhcmdldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3BsYXRQb2ludGVyKHBvaW50ZXIpIHtcbiAgICAgIGxldCBkeCA9IHBvaW50ZXIuZGVsdGFYICogY29uZmlnLlNQTEFUX0ZPUkNFO1xuICAgICAgbGV0IGR5ID0gcG9pbnRlci5kZWx0YVkgKiBjb25maWcuU1BMQVRfRk9SQ0U7XG4gICAgICBzcGxhdChwb2ludGVyLnRleGNvb3JkWCwgcG9pbnRlci50ZXhjb29yZFksIGR4LCBkeSwgcG9pbnRlci5jb2xvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpY2tTcGxhdChwb2ludGVyKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcbiAgICAgIGNvbG9yLnIgKj0gMTAuMDtcbiAgICAgIGNvbG9yLmcgKj0gMTAuMDtcbiAgICAgIGNvbG9yLmIgKj0gMTAuMDtcbiAgICAgIGxldCBkeCA9IDEwICogKE1hdGgucmFuZG9tKCkgLSAwLjUpO1xuICAgICAgbGV0IGR5ID0gMzAgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSk7XG4gICAgICBzcGxhdChwb2ludGVyLnRleGNvb3JkWCwgcG9pbnRlci50ZXhjb29yZFksIGR4LCBkeSwgY29sb3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNwbGF0KHgsIHksIGR4LCBkeSwgY29sb3IpIHtcbiAgICAgIHNwbGF0UHJvZ3JhbS5iaW5kKCk7XG4gICAgICBnbC51bmlmb3JtMWkoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLnVUYXJnZXQsIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApKTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgc3BsYXRQcm9ncmFtLnVuaWZvcm1zLmFzcGVjdFJhdGlvLFxuICAgICAgICBjYW52YXMud2lkdGggLyBjYW52YXMuaGVpZ2h0XG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTJmKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5wb2ludCwgeCwgeSk7XG4gICAgICBnbC51bmlmb3JtM2Yoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLmNvbG9yLCBkeCwgZHksIDAuMCk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5yYWRpdXMsXG4gICAgICAgIGNvcnJlY3RSYWRpdXMoY29uZmlnLlNQTEFUX1JBRElVUyAvIDEwMC4wKVxuICAgICAgKTtcbiAgICAgIGJsaXQodmVsb2NpdHkud3JpdGUpO1xuICAgICAgdmVsb2NpdHkuc3dhcCgpO1xuXG4gICAgICBnbC51bmlmb3JtMWkoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLnVUYXJnZXQsIGR5ZS5yZWFkLmF0dGFjaCgwKSk7XG4gICAgICBnbC51bmlmb3JtM2Yoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLmNvbG9yLCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgICAgIGJsaXQoZHllLndyaXRlKTtcbiAgICAgIGR5ZS5zd2FwKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29ycmVjdFJhZGl1cyhyYWRpdXMpIHtcbiAgICAgIGxldCBhc3BlY3RSYXRpbyA9IGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHQ7XG4gICAgICBpZiAoYXNwZWN0UmF0aW8gPiAxKSByYWRpdXMgKj0gYXNwZWN0UmF0aW87XG4gICAgICByZXR1cm4gcmFkaXVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXJEb3duRGF0YShwb2ludGVyLCBpZCwgcG9zWCwgcG9zWSkge1xuICAgICAgcG9pbnRlci5pZCA9IGlkO1xuICAgICAgcG9pbnRlci5kb3duID0gdHJ1ZTtcbiAgICAgIHBvaW50ZXIubW92ZWQgPSBmYWxzZTtcbiAgICAgIHBvaW50ZXIudGV4Y29vcmRYID0gcG9zWCAvIGNhbnZhcy53aWR0aDtcbiAgICAgIHBvaW50ZXIudGV4Y29vcmRZID0gMS4wIC0gcG9zWSAvIGNhbnZhcy5oZWlnaHQ7XG4gICAgICBwb2ludGVyLnByZXZUZXhjb29yZFggPSBwb2ludGVyLnRleGNvb3JkWDtcbiAgICAgIHBvaW50ZXIucHJldlRleGNvb3JkWSA9IHBvaW50ZXIudGV4Y29vcmRZO1xuICAgICAgcG9pbnRlci5kZWx0YVggPSAwO1xuICAgICAgcG9pbnRlci5kZWx0YVkgPSAwO1xuICAgICAgcG9pbnRlci5jb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQb2ludGVyTW92ZURhdGEocG9pbnRlciwgcG9zWCwgcG9zWSwgY29sb3IpIHtcbiAgICAgIHBvaW50ZXIucHJldlRleGNvb3JkWCA9IHBvaW50ZXIudGV4Y29vcmRYO1xuICAgICAgcG9pbnRlci5wcmV2VGV4Y29vcmRZID0gcG9pbnRlci50ZXhjb29yZFk7XG4gICAgICBwb2ludGVyLnRleGNvb3JkWCA9IHBvc1ggLyBjYW52YXMud2lkdGg7XG4gICAgICBwb2ludGVyLnRleGNvb3JkWSA9IDEuMCAtIHBvc1kgLyBjYW52YXMuaGVpZ2h0O1xuICAgICAgcG9pbnRlci5kZWx0YVggPSBjb3JyZWN0RGVsdGFYKHBvaW50ZXIudGV4Y29vcmRYIC0gcG9pbnRlci5wcmV2VGV4Y29vcmRYKTtcbiAgICAgIHBvaW50ZXIuZGVsdGFZID0gY29ycmVjdERlbHRhWShwb2ludGVyLnRleGNvb3JkWSAtIHBvaW50ZXIucHJldlRleGNvb3JkWSk7XG4gICAgICBwb2ludGVyLm1vdmVkID1cbiAgICAgICAgTWF0aC5hYnMocG9pbnRlci5kZWx0YVgpID4gMCB8fCBNYXRoLmFicyhwb2ludGVyLmRlbHRhWSkgPiAwO1xuICAgICAgcG9pbnRlci5jb2xvciA9IGNvbG9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXJVcERhdGEocG9pbnRlcikge1xuICAgICAgcG9pbnRlci5kb3duID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29ycmVjdERlbHRhWChkZWx0YSkge1xuICAgICAgbGV0IGFzcGVjdFJhdGlvID0gY2FudmFzLndpZHRoIC8gY2FudmFzLmhlaWdodDtcbiAgICAgIGlmIChhc3BlY3RSYXRpbyA8IDEpIGRlbHRhICo9IGFzcGVjdFJhdGlvO1xuICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvcnJlY3REZWx0YVkoZGVsdGEpIHtcbiAgICAgIGxldCBhc3BlY3RSYXRpbyA9IGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHQ7XG4gICAgICBpZiAoYXNwZWN0UmF0aW8gPiAxKSBkZWx0YSAvPSBhc3BlY3RSYXRpbztcbiAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNvbG9yKCkge1xuICAgICAgbGV0IGMgPSBIU1Z0b1JHQihNYXRoLnJhbmRvbSgpLCAxLjAsIDEuMCk7XG4gICAgICBjLnIgKj0gMC4xNTtcbiAgICAgIGMuZyAqPSAwLjE1O1xuICAgICAgYy5iICo9IDAuMTU7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBIU1Z0b1JHQihoLCBzLCB2KSB7XG4gICAgICBsZXQgciwgZywgYiwgaSwgZiwgcCwgcSwgdDtcbiAgICAgIGkgPSBNYXRoLmZsb29yKGggKiA2KTtcbiAgICAgIGYgPSBoICogNiAtIGk7XG4gICAgICBwID0gdiAqICgxIC0gcyk7XG4gICAgICBxID0gdiAqICgxIC0gZiAqIHMpO1xuICAgICAgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKTtcbiAgICAgIHN3aXRjaCAoaSAlIDYpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHIgPSB2O1xuICAgICAgICAgIGcgPSB0O1xuICAgICAgICAgIGIgPSBwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgciA9IHE7XG4gICAgICAgICAgZyA9IHY7XG4gICAgICAgICAgYiA9IHA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByID0gcDtcbiAgICAgICAgICBnID0gdjtcbiAgICAgICAgICBiID0gdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHIgPSBwO1xuICAgICAgICAgIGcgPSBxO1xuICAgICAgICAgIGIgPSB2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgciA9IHQ7XG4gICAgICAgICAgZyA9IHA7XG4gICAgICAgICAgYiA9IHY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByID0gdjtcbiAgICAgICAgICBnID0gcDtcbiAgICAgICAgICBiID0gcTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHIsIGcsIGIgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgY29uc3QgcmFuZ2UgPSBtYXggLSBtaW47XG4gICAgICBpZiAocmFuZ2UgPT09IDApIHJldHVybiBtaW47XG4gICAgICByZXR1cm4gKCh2YWx1ZSAtIG1pbikgJSByYW5nZSkgKyBtaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKSB7XG4gICAgICBsZXQgYXNwZWN0UmF0aW8gPSBnbC5kcmF3aW5nQnVmZmVyV2lkdGggLyBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xuICAgICAgaWYgKGFzcGVjdFJhdGlvIDwgMSkgYXNwZWN0UmF0aW8gPSAxLjAgLyBhc3BlY3RSYXRpbztcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgucm91bmQocmVzb2x1dGlvbik7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLnJvdW5kKHJlc29sdXRpb24gKiBhc3BlY3RSYXRpbyk7XG4gICAgICBpZiAoZ2wuZHJhd2luZ0J1ZmZlcldpZHRoID4gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodClcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IG1heCwgaGVpZ2h0OiBtaW4gfTtcbiAgICAgIGVsc2UgcmV0dXJuIHsgd2lkdGg6IG1pbiwgaGVpZ2h0OiBtYXggfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZUJ5UGl4ZWxSYXRpbyhpbnB1dCkge1xuICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihpbnB1dCAqIHBpeGVsUmF0aW8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc2hDb2RlKHMpIHtcbiAgICAgIGlmIChzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgICBsZXQgaGFzaCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaGFzaCB8PSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgIGxldCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgICBsZXQgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKGUuY2xpZW50WCk7XG4gICAgICBsZXQgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKGUuY2xpZW50WSk7XG4gICAgICB1cGRhdGVQb2ludGVyRG93bkRhdGEocG9pbnRlciwgLTEsIHBvc1gsIHBvc1kpO1xuICAgICAgY2xpY2tTcGxhdChwb2ludGVyKTtcbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwibW91c2Vtb3ZlXCIsXG4gICAgICBmdW5jdGlvbiBoYW5kbGVGaXJzdE1vdXNlTW92ZShlKSB7XG4gICAgICAgIGxldCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgICAgIGxldCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5jbGllbnRYKTtcbiAgICAgICAgbGV0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFkpO1xuICAgICAgICBsZXQgY29sb3IgPSBnZW5lcmF0ZUNvbG9yKCk7XG4gICAgICAgIHVwZGF0ZUZyYW1lKCk7IC8vIHN0YXJ0IGFuaW1hdGlvbiBsb29wXG4gICAgICAgIHVwZGF0ZVBvaW50ZXJNb3ZlRGF0YShwb2ludGVyLCBwb3NYLCBwb3NZLCBjb2xvcik7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVGaXJzdE1vdXNlTW92ZSk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIChlKSA9PiB7XG4gICAgICBsZXQgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgICAgbGV0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFgpO1xuICAgICAgbGV0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFkpO1xuICAgICAgbGV0IGNvbG9yID0gcG9pbnRlci5jb2xvcjtcbiAgICAgIHVwZGF0ZVBvaW50ZXJNb3ZlRGF0YShwb2ludGVyLCBwb3NYLCBwb3NZLCBjb2xvcik7XG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNoc3RhcnRcIixcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUZpcnN0VG91Y2hTdGFydChlKSB7XG4gICAgICAgIGNvbnN0IHRvdWNoZXMgPSBlLnRhcmdldFRvdWNoZXM7XG4gICAgICAgIGxldCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRYKTtcbiAgICAgICAgICBsZXQgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0uY2xpZW50WSk7XG4gICAgICAgICAgdXBkYXRlRnJhbWUoKTsgLy8gc3RhcnQgYW5pbWF0aW9uIGxvb3BcbiAgICAgICAgICB1cGRhdGVQb2ludGVyRG93bkRhdGEocG9pbnRlciwgdG91Y2hlc1tpXS5pZGVudGlmaWVyLCBwb3NYLCBwb3NZKTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGhhbmRsZUZpcnN0VG91Y2hTdGFydCk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlcztcbiAgICAgIGxldCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFgpO1xuICAgICAgICBsZXQgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0uY2xpZW50WSk7XG4gICAgICAgIHVwZGF0ZVBvaW50ZXJEb3duRGF0YShwb2ludGVyLCB0b3VjaGVzW2ldLmlkZW50aWZpZXIsIHBvc1gsIHBvc1kpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNobW92ZVwiLFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgY29uc3QgdG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlcztcbiAgICAgICAgbGV0IHBvaW50ZXIgPSBwb2ludGVyc1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFgpO1xuICAgICAgICAgIGxldCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRZKTtcbiAgICAgICAgICB1cGRhdGVQb2ludGVyTW92ZURhdGEocG9pbnRlciwgcG9zWCwgcG9zWSwgcG9pbnRlci5jb2xvcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgICk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIChlKSA9PiB7XG4gICAgICBjb25zdCB0b3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcztcbiAgICAgIGxldCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXBkYXRlUG9pbnRlclVwRGF0YShwb2ludGVyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHVwZGF0ZUZyYW1lKCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXG4gICAgU0lNX1JFU09MVVRJT04sXG4gICAgRFlFX1JFU09MVVRJT04sXG4gICAgQ0FQVFVSRV9SRVNPTFVUSU9OLFxuICAgIERFTlNJVFlfRElTU0lQQVRJT04sXG4gICAgVkVMT0NJVFlfRElTU0lQQVRJT04sXG4gICAgUFJFU1NVUkUsXG4gICAgUFJFU1NVUkVfSVRFUkFUSU9OUyxcbiAgICBDVVJMLFxuICAgIFNQTEFUX1JBRElVUyxcbiAgICBTUExBVF9GT1JDRSxcbiAgICBTSEFESU5HLFxuICAgIENPTE9SX1VQREFURV9TUEVFRCxcbiAgICBCQUNLX0NPTE9SLFxuICAgIFRSQU5TUEFSRU5ULFxuICBdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZml4ZWQgdG9wLTAgbGVmdC0wIHotNTAgcG9pbnRlci1ldmVudHMtbm9uZVwiPlxuICAgICAgPGNhbnZhcyByZWY9e2NhbnZhc1JlZn0gaWQ9XCJmbHVpZFwiIGNsYXNzTmFtZT1cInctc2NyZWVuIGgtc2NyZWVuXCIgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZXhwb3J0IHsgU3BsYXNoQ3Vyc29yIH07XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiU3BsYXNoQ3Vyc29yIiwiU0lNX1JFU09MVVRJT04iLCJEWUVfUkVTT0xVVElPTiIsIkNBUFRVUkVfUkVTT0xVVElPTiIsIkRFTlNJVFlfRElTU0lQQVRJT04iLCJWRUxPQ0lUWV9ESVNTSVBBVElPTiIsIlBSRVNTVVJFIiwiUFJFU1NVUkVfSVRFUkFUSU9OUyIsIkNVUkwiLCJTUExBVF9SQURJVVMiLCJTUExBVF9GT1JDRSIsIlNIQURJTkciLCJDT0xPUl9VUERBVEVfU1BFRUQiLCJCQUNLX0NPTE9SIiwiciIsImciLCJiIiwiVFJBTlNQQVJFTlQiLCJjYW52YXNSZWYiLCJjYW52YXMiLCJjdXJyZW50IiwiUG9pbnRlciIsImlkIiwidGV4Y29vcmRYIiwidGV4Y29vcmRZIiwicHJldlRleGNvb3JkWCIsInByZXZUZXhjb29yZFkiLCJkZWx0YVgiLCJkZWx0YVkiLCJkb3duIiwibW92ZWQiLCJjb2xvciIsImNvbmZpZyIsIlBBVVNFRCIsInBvaW50ZXJzIiwiZ2wiLCJleHQiLCJnZXRXZWJHTENvbnRleHQiLCJzdXBwb3J0TGluZWFyRmlsdGVyaW5nIiwicGFyYW1zIiwiYWxwaGEiLCJkZXB0aCIsInN0ZW5jaWwiLCJhbnRpYWxpYXMiLCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXIiLCJnZXRDb250ZXh0IiwiaXNXZWJHTDIiLCJXZWJHTDJSZW5kZXJpbmdDb250ZXh0IiwiaGFsZkZsb2F0IiwiZ2V0RXh0ZW5zaW9uIiwiY2xlYXJDb2xvciIsImhhbGZGbG9hdFRleFR5cGUiLCJIQUxGX0ZMT0FUIiwiSEFMRl9GTE9BVF9PRVMiLCJmb3JtYXRSR0JBIiwiZm9ybWF0UkciLCJmb3JtYXRSIiwiZ2V0U3VwcG9ydGVkRm9ybWF0IiwiUkdCQTE2RiIsIlJHQkEiLCJSRzE2RiIsIlJHIiwidW5kZWZpbmVkIiwiUjE2RiIsIlJFRCIsImludGVybmFsRm9ybWF0IiwiZm9ybWF0IiwidHlwZSIsInN1cHBvcnRSZW5kZXJUZXh0dXJlRm9ybWF0IiwidGV4dHVyZSIsImNyZWF0ZVRleHR1cmUiLCJiaW5kVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJ0ZXhQYXJhbWV0ZXJpIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiTkVBUkVTVCIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsIlRFWFRVUkVfV1JBUF9TIiwiQ0xBTVBfVE9fRURHRSIsIlRFWFRVUkVfV1JBUF9UIiwidGV4SW1hZ2UyRCIsImZibyIsImNyZWF0ZUZyYW1lYnVmZmVyIiwiYmluZEZyYW1lYnVmZmVyIiwiRlJBTUVCVUZGRVIiLCJmcmFtZWJ1ZmZlclRleHR1cmUyRCIsIkNPTE9SX0FUVEFDSE1FTlQwIiwic3RhdHVzIiwiY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyIsIkZSQU1FQlVGRkVSX0NPTVBMRVRFIiwiTWF0ZXJpYWwiLCJzZXRLZXl3b3JkcyIsImtleXdvcmRzIiwiaGFzaCIsImkiLCJsZW5ndGgiLCJoYXNoQ29kZSIsInByb2dyYW0iLCJwcm9ncmFtcyIsImZyYWdtZW50U2hhZGVyIiwiY29tcGlsZVNoYWRlciIsIkZSQUdNRU5UX1NIQURFUiIsImZyYWdtZW50U2hhZGVyU291cmNlIiwiY3JlYXRlUHJvZ3JhbSIsInZlcnRleFNoYWRlciIsImFjdGl2ZVByb2dyYW0iLCJ1bmlmb3JtcyIsImdldFVuaWZvcm1zIiwiYmluZCIsInVzZVByb2dyYW0iLCJjb25zdHJ1Y3RvciIsIlByb2dyYW0iLCJ1bmlmb3JtQ291bnQiLCJnZXRQcm9ncmFtUGFyYW1ldGVyIiwiQUNUSVZFX1VOSUZPUk1TIiwidW5pZm9ybUluZm8iLCJnZXRBY3RpdmVVbmlmb3JtIiwidW5pZm9ybU5hbWUiLCJuYW1lIiwiZ2V0VW5pZm9ybUxvY2F0aW9uIiwic291cmNlIiwiYWRkS2V5d29yZHMiLCJzaGFkZXIiLCJjcmVhdGVTaGFkZXIiLCJzaGFkZXJTb3VyY2UiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsImNvbnNvbGUiLCJ0cmFjZSIsImdldFNoYWRlckluZm9Mb2ciLCJhdHRhY2hTaGFkZXIiLCJsaW5rUHJvZ3JhbSIsIkxJTktfU1RBVFVTIiwiZ2V0UHJvZ3JhbUluZm9Mb2ciLCJrZXl3b3Jkc1N0cmluZyIsImZvckVhY2giLCJrZXl3b3JkIiwiYmFzZVZlcnRleFNoYWRlciIsIlZFUlRFWF9TSEFERVIiLCJjb3B5U2hhZGVyIiwiY2xlYXJTaGFkZXIiLCJkaXNwbGF5U2hhZGVyU291cmNlIiwic3BsYXRTaGFkZXIiLCJhZHZlY3Rpb25TaGFkZXIiLCJkaXZlcmdlbmNlU2hhZGVyIiwiY3VybFNoYWRlciIsInZvcnRpY2l0eVNoYWRlciIsInByZXNzdXJlU2hhZGVyIiwiZ3JhZGllbnRTdWJ0cmFjdFNoYWRlciIsImJsaXQiLCJFcnJvciIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJjcmVhdGVCdWZmZXIiLCJidWZmZXJEYXRhIiwiRmxvYXQzMkFycmF5IiwiU1RBVElDX0RSQVciLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsIlVpbnQxNkFycmF5IiwidmVydGV4QXR0cmliUG9pbnRlciIsIkZMT0FUIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJ0YXJnZXQiLCJjbGVhciIsInZpZXdwb3J0IiwiZHJhd2luZ0J1ZmZlcldpZHRoIiwiZHJhd2luZ0J1ZmZlckhlaWdodCIsIndpZHRoIiwiaGVpZ2h0IiwiQ09MT1JfQlVGRkVSX0JJVCIsImRyYXdFbGVtZW50cyIsIlRSSUFOR0xFUyIsIlVOU0lHTkVEX1NIT1JUIiwiZHllIiwidmVsb2NpdHkiLCJkaXZlcmdlbmNlIiwiY3VybCIsInByZXNzdXJlIiwiY29weVByb2dyYW0iLCJjbGVhclByb2dyYW0iLCJzcGxhdFByb2dyYW0iLCJhZHZlY3Rpb25Qcm9ncmFtIiwiZGl2ZXJnZW5jZVByb2dyYW0iLCJjdXJsUHJvZ3JhbSIsInZvcnRpY2l0eVByb2dyYW0iLCJwcmVzc3VyZVByb2dyYW0iLCJncmFkaWVuU3VidHJhY3RQcm9ncmFtIiwiZGlzcGxheU1hdGVyaWFsIiwiaW5pdEZyYW1lYnVmZmVycyIsInNpbVJlcyIsImdldFJlc29sdXRpb24iLCJkeWVSZXMiLCJ0ZXhUeXBlIiwicmdiYSIsInJnIiwiZmlsdGVyaW5nIiwiTElORUFSIiwiZGlzYWJsZSIsIkJMRU5EIiwiY3JlYXRlRG91YmxlRkJPIiwicmVzaXplRG91YmxlRkJPIiwiY3JlYXRlRkJPIiwidyIsImgiLCJwYXJhbSIsImFjdGl2ZVRleHR1cmUiLCJURVhUVVJFMCIsInRleGVsU2l6ZVgiLCJ0ZXhlbFNpemVZIiwiYXR0YWNoIiwiZmJvMSIsImZibzIiLCJyZWFkIiwidmFsdWUiLCJ3cml0ZSIsInN3YXAiLCJ0ZW1wIiwicmVzaXplRkJPIiwibmV3RkJPIiwidW5pZm9ybTFpIiwidVRleHR1cmUiLCJ1cGRhdGVLZXl3b3JkcyIsImRpc3BsYXlLZXl3b3JkcyIsInB1c2giLCJsYXN0VXBkYXRlVGltZSIsIkRhdGUiLCJub3ciLCJjb2xvclVwZGF0ZVRpbWVyIiwidXBkYXRlRnJhbWUiLCJkdCIsImNhbGNEZWx0YVRpbWUiLCJyZXNpemVDYW52YXMiLCJ1cGRhdGVDb2xvcnMiLCJhcHBseUlucHV0cyIsInN0ZXAiLCJyZW5kZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJNYXRoIiwibWluIiwic2NhbGVCeVBpeGVsUmF0aW8iLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIndyYXAiLCJwIiwiZ2VuZXJhdGVDb2xvciIsInNwbGF0UG9pbnRlciIsInVuaWZvcm0yZiIsInRleGVsU2l6ZSIsInVWZWxvY2l0eSIsInVDdXJsIiwidW5pZm9ybTFmIiwidURpdmVyZ2VuY2UiLCJ1UHJlc3N1cmUiLCJkeWVUZXhlbFNpemUiLCJ2ZWxvY2l0eUlkIiwidVNvdXJjZSIsImRpc3NpcGF0aW9uIiwiYmxlbmRGdW5jIiwiT05FIiwiT05FX01JTlVTX1NSQ19BTFBIQSIsImVuYWJsZSIsImRyYXdEaXNwbGF5IiwicG9pbnRlciIsImR4IiwiZHkiLCJzcGxhdCIsImNsaWNrU3BsYXQiLCJyYW5kb20iLCJ4IiwieSIsInVUYXJnZXQiLCJhc3BlY3RSYXRpbyIsInBvaW50IiwidW5pZm9ybTNmIiwicmFkaXVzIiwiY29ycmVjdFJhZGl1cyIsInVwZGF0ZVBvaW50ZXJEb3duRGF0YSIsInBvc1giLCJwb3NZIiwidXBkYXRlUG9pbnRlck1vdmVEYXRhIiwiY29ycmVjdERlbHRhWCIsImNvcnJlY3REZWx0YVkiLCJhYnMiLCJ1cGRhdGVQb2ludGVyVXBEYXRhIiwiZGVsdGEiLCJjIiwiSFNWdG9SR0IiLCJzIiwidiIsImYiLCJxIiwidCIsImZsb29yIiwibWF4IiwicmFuZ2UiLCJyZXNvbHV0aW9uIiwicm91bmQiLCJpbnB1dCIsInBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwiY2hhckNvZGVBdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiY2xpZW50WCIsImNsaWVudFkiLCJkb2N1bWVudCIsImJvZHkiLCJoYW5kbGVGaXJzdE1vdXNlTW92ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVGaXJzdFRvdWNoU3RhcnQiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImlkZW50aWZpZXIiLCJjaGFuZ2VkVG91Y2hlcyIsImRpdiIsImNsYXNzTmFtZSIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/splash-cursor.tsx\n"));

/***/ })

});