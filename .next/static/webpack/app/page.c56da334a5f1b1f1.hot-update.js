"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/ui/splash-cursor.tsx":
/*!*********************************************!*\
  !*** ./src/components/ui/splash-cursor.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SplashCursor: function() { return /* binding */ SplashCursor; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ SplashCursor auto */ \nvar _s = $RefreshSig$();\n\nfunction SplashCursor(param) {\n    let { // Add whatever props you like for customization\n    SIM_RESOLUTION = 128, DYE_RESOLUTION = 1440, CAPTURE_RESOLUTION = 512, DENSITY_DISSIPATION = 3.5, VELOCITY_DISSIPATION = 2, PRESSURE = 0.1, PRESSURE_ITERATIONS = 20, CURL = 3, SPLAT_RADIUS = 0.2, SPLAT_FORCE = 6000, SHADING = true, COLOR_UPDATE_SPEED = 10, BACK_COLOR = {\n        r: 0.5,\n        g: 0,\n        b: 0\n    }, TRANSPARENT = true } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        class Pointer {\n            constructor(){\n                this.id = -1;\n                this.texcoordX = 0;\n                this.texcoordY = 0;\n                this.prevTexcoordX = 0;\n                this.prevTexcoordY = 0;\n                this.deltaX = 0;\n                this.deltaY = 0;\n                this.down = false;\n                this.moved = false;\n                this.color = [\n                    0,\n                    0,\n                    0\n                ];\n            }\n        }\n        let config = {\n            SIM_RESOLUTION,\n            DYE_RESOLUTION,\n            CAPTURE_RESOLUTION,\n            DENSITY_DISSIPATION,\n            VELOCITY_DISSIPATION,\n            PRESSURE,\n            PRESSURE_ITERATIONS,\n            CURL,\n            SPLAT_RADIUS,\n            SPLAT_FORCE,\n            SHADING,\n            COLOR_UPDATE_SPEED,\n            PAUSED: false,\n            BACK_COLOR,\n            TRANSPARENT\n        };\n        let pointers = [\n            new Pointer()\n        ];\n        const { gl, ext } = getWebGLContext(canvas);\n        if (!ext.supportLinearFiltering) {\n            config.DYE_RESOLUTION = 256;\n            config.SHADING = false;\n        }\n        function getWebGLContext(canvas) {\n            const params = {\n                alpha: true,\n                depth: false,\n                stencil: false,\n                antialias: false,\n                preserveDrawingBuffer: false\n            };\n            let gl = canvas.getContext(\"webgl2\", params);\n            const isWebGL2 = !!gl;\n            if (!isWebGL2) gl = canvas.getContext(\"webgl\", params) || canvas.getContext(\"experimental-webgl\", params);\n            let halfFloat;\n            let supportLinearFiltering;\n            if (isWebGL2) {\n                gl.getExtension(\"EXT_color_buffer_float\");\n                supportLinearFiltering = gl.getExtension(\"OES_texture_float_linear\");\n            } else {\n                halfFloat = gl.getExtension(\"OES_texture_half_float\");\n                supportLinearFiltering = gl.getExtension(\"OES_texture_half_float_linear\");\n            }\n            gl.clearColor(0.0, 0.0, 0.0, 1.0);\n            const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat && halfFloat.HALF_FLOAT_OES;\n            let formatRGBA;\n            let formatRG;\n            let formatR;\n            if (isWebGL2) {\n                formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n                formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n                formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n            } else {\n                formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n                formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n                formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n            }\n            return {\n                gl,\n                ext: {\n                    formatRGBA,\n                    formatRG,\n                    formatR,\n                    halfFloatTexType,\n                    supportLinearFiltering\n                }\n            };\n        }\n        function getSupportedFormat(gl, internalFormat, format, type) {\n            if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n                switch(internalFormat){\n                    case gl.R16F:\n                        return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n                    case gl.RG16F:\n                        return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n                    default:\n                        return null;\n                }\n            }\n            return {\n                internalFormat,\n                format\n            };\n        }\n        function supportRenderTextureFormat(gl, internalFormat, format, type) {\n            const texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n            const fbo = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n            return status === gl.FRAMEBUFFER_COMPLETE;\n        }\n        class Material {\n            setKeywords(keywords) {\n                let hash = 0;\n                for(let i = 0; i < keywords.length; i++)hash += hashCode(keywords[i]);\n                let program = this.programs[hash];\n                if (program == null) {\n                    let fragmentShader = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, keywords);\n                    program = createProgram(this.vertexShader, fragmentShader);\n                    this.programs[hash] = program;\n                }\n                if (program === this.activeProgram) return;\n                this.uniforms = getUniforms(program);\n                this.activeProgram = program;\n            }\n            bind() {\n                gl.useProgram(this.activeProgram);\n            }\n            constructor(vertexShader, fragmentShaderSource){\n                this.vertexShader = vertexShader;\n                this.fragmentShaderSource = fragmentShaderSource;\n                this.programs = [];\n                this.activeProgram = null;\n                this.uniforms = [];\n            }\n        }\n        class Program {\n            bind() {\n                gl.useProgram(this.program);\n            }\n            constructor(vertexShader, fragmentShader){\n                this.uniforms = {};\n                this.program = createProgram(vertexShader, fragmentShader);\n                this.uniforms = getUniforms(this.program);\n            }\n        }\n        function createProgram(vertexShader, fragmentShader) {\n            let program = gl.createProgram();\n            gl.attachShader(program, vertexShader);\n            gl.attachShader(program, fragmentShader);\n            gl.linkProgram(program);\n            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) console.trace(gl.getProgramInfoLog(program));\n            return program;\n        }\n        function getUniforms(program) {\n            let uniforms = [];\n            let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n            for(let i = 0; i < uniformCount; i++){\n                let uniformName = gl.getActiveUniform(program, i).name;\n                uniforms[uniformName] = gl.getUniformLocation(program, uniformName);\n            }\n            return uniforms;\n        }\n        function compileShader(type, source, keywords) {\n            source = addKeywords(source, keywords);\n            const shader = gl.createShader(type);\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) console.trace(gl.getShaderInfoLog(shader));\n            return shader;\n        }\n        function addKeywords(source, keywords) {\n            if (!keywords) return source;\n            let keywordsString = \"\";\n            keywords.forEach((keyword)=>{\n                keywordsString += \"#define \" + keyword + \"\\n\";\n            });\n            return keywordsString + source;\n        }\n        const baseVertexShader = compileShader(gl.VERTEX_SHADER, \"\\n        precision highp float;\\n        attribute vec2 aPosition;\\n        varying vec2 vUv;\\n        varying vec2 vL;\\n        varying vec2 vR;\\n        varying vec2 vT;\\n        varying vec2 vB;\\n        uniform vec2 texelSize;\\n\\n        void main () {\\n            vUv = aPosition * 0.5 + 0.5;\\n            vL = vUv - vec2(texelSize.x, 0.0);\\n            vR = vUv + vec2(texelSize.x, 0.0);\\n            vT = vUv + vec2(0.0, texelSize.y);\\n            vB = vUv - vec2(0.0, texelSize.y);\\n            gl_Position = vec4(aPosition, 0.0, 1.0);\\n        }\\n      \");\n        const copyShader = compileShader(gl.FRAGMENT_SHADER, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        uniform sampler2D uTexture;\\n\\n        void main () {\\n            gl_FragColor = texture2D(uTexture, vUv);\\n        }\\n      \");\n        const clearShader = compileShader(gl.FRAGMENT_SHADER, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        uniform sampler2D uTexture;\\n        uniform float value;\\n\\n        void main () {\\n            gl_FragColor = value * texture2D(uTexture, vUv);\\n        }\\n     \");\n        const displayShaderSource = \"\\n      precision highp float;\\n      precision highp sampler2D;\\n      varying vec2 vUv;\\n      varying vec2 vL;\\n      varying vec2 vR;\\n      varying vec2 vT;\\n      varying vec2 vB;\\n      uniform sampler2D uTexture;\\n      uniform sampler2D uDithering;\\n      uniform vec2 ditherScale;\\n      uniform vec2 texelSize;\\n\\n      vec3 linearToGamma (vec3 color) {\\n          color = max(color, vec3(0));\\n          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\\n      }\\n\\n      void main () {\\n          vec3 c = texture2D(uTexture, vUv).rgb;\\n          #ifdef SHADING\\n              vec3 lc = texture2D(uTexture, vL).rgb;\\n              vec3 rc = texture2D(uTexture, vR).rgb;\\n              vec3 tc = texture2D(uTexture, vT).rgb;\\n              vec3 bc = texture2D(uTexture, vB).rgb;\\n\\n              float dx = length(rc) - length(lc);\\n              float dy = length(tc) - length(bc);\\n\\n              vec3 n = normalize(vec3(dx, dy, length(texelSize)));\\n              vec3 l = vec3(0.0, 0.0, 1.0);\\n\\n              float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\\n              c *= diffuse;\\n          #endif\\n\\n          float a = max(c.r, max(c.g, c.b));\\n          gl_FragColor = vec4(c, a);\\n      }\\n    \";\n        const splatShader = compileShader(gl.FRAGMENT_SHADER, \"\\n        precision highp float;\\n        precision highp sampler2D;\\n        varying vec2 vUv;\\n        uniform sampler2D uTarget;\\n        uniform float aspectRatio;\\n        uniform vec3 color;\\n        uniform vec2 point;\\n        uniform float radius;\\n\\n        void main () {\\n            vec2 p = vUv - point.xy;\\n            p.x *= aspectRatio;\\n            vec3 splat = exp(-dot(p, p) / radius) * color;\\n            vec3 base = texture2D(uTarget, vUv).xyz;\\n            gl_FragColor = vec4(base + splat, 1.0);\\n        }\\n      \");\n        const advectionShader = compileShader(gl.FRAGMENT_SHADER, \"\\n        precision highp float;\\n        precision highp sampler2D;\\n        varying vec2 vUv;\\n        uniform sampler2D uVelocity;\\n        uniform sampler2D uSource;\\n        uniform vec2 texelSize;\\n        uniform vec2 dyeTexelSize;\\n        uniform float dt;\\n        uniform float dissipation;\\n\\n        vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\\n            vec2 st = uv / tsize - 0.5;\\n            vec2 iuv = floor(st);\\n            vec2 fuv = fract(st);\\n\\n            vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\\n            vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\\n            vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\\n            vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\\n\\n            return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\\n        }\\n\\n        void main () {\\n            #ifdef MANUAL_FILTERING\\n                vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\\n                vec4 result = bilerp(uSource, coord, dyeTexelSize);\\n            #else\\n                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\\n                vec4 result = texture2D(uSource, coord);\\n            #endif\\n            float decay = 1.0 + dissipation * dt;\\n            gl_FragColor = result / decay;\\n        }\\n      \", ext.supportLinearFiltering ? null : [\n            \"MANUAL_FILTERING\"\n        ]);\n        const divergenceShader = compileShader(gl.FRAGMENT_SHADER, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        varying highp vec2 vL;\\n        varying highp vec2 vR;\\n        varying highp vec2 vT;\\n        varying highp vec2 vB;\\n        uniform sampler2D uVelocity;\\n\\n        void main () {\\n            float L = texture2D(uVelocity, vL).x;\\n            float R = texture2D(uVelocity, vR).x;\\n            float T = texture2D(uVelocity, vT).y;\\n            float B = texture2D(uVelocity, vB).y;\\n\\n            vec2 C = texture2D(uVelocity, vUv).xy;\\n            if (vL.x < 0.0) { L = -C.x; }\\n            if (vR.x > 1.0) { R = -C.x; }\\n            if (vT.y > 1.0) { T = -C.y; }\\n            if (vB.y < 0.0) { B = -C.y; }\\n\\n            float div = 0.5 * (R - L + T - B);\\n            gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\\n        }\\n      \");\n        const curlShader = compileShader(gl.FRAGMENT_SHADER, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        varying highp vec2 vL;\\n        varying highp vec2 vR;\\n        varying highp vec2 vT;\\n        varying highp vec2 vB;\\n        uniform sampler2D uVelocity;\\n\\n        void main () {\\n            float L = texture2D(uVelocity, vL).y;\\n            float R = texture2D(uVelocity, vR).y;\\n            float T = texture2D(uVelocity, vT).x;\\n            float B = texture2D(uVelocity, vB).x;\\n            float vorticity = R - L - T + B;\\n            gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\\n        }\\n      \");\n        const vorticityShader = compileShader(gl.FRAGMENT_SHADER, \"\\n        precision highp float;\\n        precision highp sampler2D;\\n        varying vec2 vUv;\\n        varying vec2 vL;\\n        varying vec2 vR;\\n        varying vec2 vT;\\n        varying vec2 vB;\\n        uniform sampler2D uVelocity;\\n        uniform sampler2D uCurl;\\n        uniform float curl;\\n        uniform float dt;\\n\\n        void main () {\\n            float L = texture2D(uCurl, vL).x;\\n            float R = texture2D(uCurl, vR).x;\\n            float T = texture2D(uCurl, vT).x;\\n            float B = texture2D(uCurl, vB).x;\\n            float C = texture2D(uCurl, vUv).x;\\n\\n            vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\\n            force /= length(force) + 0.0001;\\n            force *= curl * C;\\n            force.y *= -1.0;\\n\\n            vec2 velocity = texture2D(uVelocity, vUv).xy;\\n            velocity += force * dt;\\n            velocity = min(max(velocity, -1000.0), 1000.0);\\n            gl_FragColor = vec4(velocity, 0.0, 1.0);\\n        }\\n      \");\n        const pressureShader = compileShader(gl.FRAGMENT_SHADER, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        varying highp vec2 vL;\\n        varying highp vec2 vR;\\n        varying highp vec2 vT;\\n        varying highp vec2 vB;\\n        uniform sampler2D uPressure;\\n        uniform sampler2D uDivergence;\\n\\n        void main () {\\n            float L = texture2D(uPressure, vL).x;\\n            float R = texture2D(uPressure, vR).x;\\n            float T = texture2D(uPressure, vT).x;\\n            float B = texture2D(uPressure, vB).x;\\n            float C = texture2D(uPressure, vUv).x;\\n            float divergence = texture2D(uDivergence, vUv).x;\\n            float pressure = (L + R + B + T - divergence) * 0.25;\\n            gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\\n        }\\n      \");\n        const gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, \"\\n        precision mediump float;\\n        precision mediump sampler2D;\\n        varying highp vec2 vUv;\\n        varying highp vec2 vL;\\n        varying highp vec2 vR;\\n        varying highp vec2 vT;\\n        varying highp vec2 vB;\\n        uniform sampler2D uPressure;\\n        uniform sampler2D uVelocity;\\n\\n        void main () {\\n            float L = texture2D(uPressure, vL).x;\\n            float R = texture2D(uPressure, vR).x;\\n            float T = texture2D(uPressure, vT).x;\\n            float B = texture2D(uPressure, vB).x;\\n            vec2 velocity = texture2D(uVelocity, vUv).xy;\\n            velocity.xy -= vec2(R - L, T - B);\\n            gl_FragColor = vec4(velocity, 0.0, 1.0);\\n        }\\n      \");\n        const blit = (()=>{\n            gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n                -1,\n                -1,\n                -1,\n                1,\n                1,\n                1,\n                1,\n                -1\n            ]), gl.STATIC_DRAW);\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([\n                0,\n                1,\n                2,\n                0,\n                2,\n                3\n            ]), gl.STATIC_DRAW);\n            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(0);\n            return function(target) {\n                let clear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n                if (target == null) {\n                    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                } else {\n                    gl.viewport(0, 0, target.width, target.height);\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n                }\n                if (clear) {\n                    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n                    gl.clear(gl.COLOR_BUFFER_BIT);\n                }\n                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n            };\n        })();\n        let dye, velocity, divergence, curl, pressure;\n        const copyProgram = new Program(baseVertexShader, copyShader);\n        const clearProgram = new Program(baseVertexShader, clearShader);\n        const splatProgram = new Program(baseVertexShader, splatShader);\n        const advectionProgram = new Program(baseVertexShader, advectionShader);\n        const divergenceProgram = new Program(baseVertexShader, divergenceShader);\n        const curlProgram = new Program(baseVertexShader, curlShader);\n        const vorticityProgram = new Program(baseVertexShader, vorticityShader);\n        const pressureProgram = new Program(baseVertexShader, pressureShader);\n        const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);\n        const displayMaterial = new Material(baseVertexShader, displayShaderSource);\n        function initFramebuffers() {\n            let simRes = getResolution(config.SIM_RESOLUTION);\n            let dyeRes = getResolution(config.DYE_RESOLUTION);\n            const texType = ext.halfFloatTexType;\n            const rgba = ext.formatRGBA;\n            const rg = ext.formatRG;\n            const r = ext.formatR;\n            const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n            gl.disable(gl.BLEND);\n            if (!dye) dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n            else dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n            if (!velocity) velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n            else velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n            divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n            curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n            pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n        }\n        function createFBO(w, h, internalFormat, format, type, param) {\n            gl.activeTexture(gl.TEXTURE0);\n            let texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n            let fbo = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            gl.viewport(0, 0, w, h);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            let texelSizeX = 1.0 / w;\n            let texelSizeY = 1.0 / h;\n            return {\n                texture,\n                fbo,\n                width: w,\n                height: h,\n                texelSizeX,\n                texelSizeY,\n                attach (id) {\n                    gl.activeTexture(gl.TEXTURE0 + id);\n                    gl.bindTexture(gl.TEXTURE_2D, texture);\n                    return id;\n                }\n            };\n        }\n        function createDoubleFBO(w, h, internalFormat, format, type, param) {\n            let fbo1 = createFBO(w, h, internalFormat, format, type, param);\n            let fbo2 = createFBO(w, h, internalFormat, format, type, param);\n            return {\n                width: w,\n                height: h,\n                texelSizeX: fbo1.texelSizeX,\n                texelSizeY: fbo1.texelSizeY,\n                get read () {\n                    return fbo1;\n                },\n                set read (value){\n                    fbo1 = value;\n                },\n                get write () {\n                    return fbo2;\n                },\n                set write (value){\n                    fbo2 = value;\n                },\n                swap () {\n                    let temp = fbo1;\n                    fbo1 = fbo2;\n                    fbo2 = temp;\n                }\n            };\n        }\n        function resizeFBO(target, w, h, internalFormat, format, type, param) {\n            let newFBO = createFBO(w, h, internalFormat, format, type, param);\n            copyProgram.bind();\n            gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n            blit(newFBO);\n            return newFBO;\n        }\n        function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {\n            if (target.width === w && target.height === h) return target;\n            target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);\n            target.write = createFBO(w, h, internalFormat, format, type, param);\n            target.width = w;\n            target.height = h;\n            target.texelSizeX = 1.0 / w;\n            target.texelSizeY = 1.0 / h;\n            return target;\n        }\n        function updateKeywords() {\n            let displayKeywords = [];\n            if (config.SHADING) displayKeywords.push(\"SHADING\");\n            displayMaterial.setKeywords(displayKeywords);\n        }\n        updateKeywords();\n        initFramebuffers();\n        let lastUpdateTime = Date.now();\n        let colorUpdateTimer = 0.0;\n        function updateFrame() {\n            const dt = calcDeltaTime();\n            if (resizeCanvas()) initFramebuffers();\n            updateColors(dt);\n            applyInputs();\n            step(dt);\n            render(null);\n            requestAnimationFrame(updateFrame);\n        }\n        function calcDeltaTime() {\n            let now = Date.now();\n            let dt = (now - lastUpdateTime) / 1000;\n            dt = Math.min(dt, 0.016666);\n            lastUpdateTime = now;\n            return dt;\n        }\n        function resizeCanvas() {\n            let width = scaleByPixelRatio(canvas.clientWidth);\n            let height = scaleByPixelRatio(canvas.clientHeight);\n            if (canvas.width !== width || canvas.height !== height) {\n                canvas.width = width;\n                canvas.height = height;\n                return true;\n            }\n            return false;\n        }\n        function updateColors(dt) {\n            colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n            if (colorUpdateTimer >= 1) {\n                colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n                pointers.forEach((p)=>{\n                    p.color = generateColor();\n                });\n            }\n        }\n        function applyInputs() {\n            pointers.forEach((p)=>{\n                if (p.moved) {\n                    p.moved = false;\n                    splatPointer(p);\n                }\n            });\n        }\n        function step(dt) {\n            gl.disable(gl.BLEND);\n            // Curl\n            curlProgram.bind();\n            gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n            blit(curl);\n            // Vorticity\n            vorticityProgram.bind();\n            gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n            gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n            gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n            gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n            blit(velocity.write);\n            velocity.swap();\n            // Divergence\n            divergenceProgram.bind();\n            gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n            blit(divergence);\n            // Clear pressure\n            clearProgram.bind();\n            gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n            gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n            blit(pressure.write);\n            pressure.swap();\n            // Pressure\n            pressureProgram.bind();\n            gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n            for(let i = 0; i < config.PRESSURE_ITERATIONS; i++){\n                gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n                blit(pressure.write);\n                pressure.swap();\n            }\n            // Gradient Subtract\n            gradienSubtractProgram.bind();\n            gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));\n            gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));\n            blit(velocity.write);\n            velocity.swap();\n            // Advection\n            advectionProgram.bind();\n            gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);\n            let velocityId = velocity.read.attach(0);\n            gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n            gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n            gl.uniform1f(advectionProgram.uniforms.dt, dt);\n            gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n            blit(velocity.write);\n            velocity.swap();\n            if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);\n            gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n            gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n            gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n            blit(dye.write);\n            dye.swap();\n        }\n        function render(target) {\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n            drawDisplay(target);\n        }\n        function drawDisplay(target) {\n            let width = target == null ? gl.drawingBufferWidth : target.width;\n            let height = target == null ? gl.drawingBufferHeight : target.height;\n            displayMaterial.bind();\n            if (config.SHADING) gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);\n            gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n            blit(target);\n        }\n        function splatPointer(pointer) {\n            let dx = pointer.deltaX * config.SPLAT_FORCE;\n            let dy = pointer.deltaY * config.SPLAT_FORCE;\n            splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n        }\n        function clickSplat(pointer) {\n            const color = generateColor();\n            color.r *= 10.0;\n            color.g *= 10.0;\n            color.b *= 10.0;\n            let dx = 10 * (Math.random() - 0.5);\n            let dy = 30 * (Math.random() - 0.5);\n            splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);\n        }\n        function splat(x, y, dx, dy, color) {\n            splatProgram.bind();\n            gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n            gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n            gl.uniform2f(splatProgram.uniforms.point, x, y);\n            gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);\n            gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));\n            blit(velocity.write);\n            velocity.swap();\n            gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n            gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n            blit(dye.write);\n            dye.swap();\n        }\n        function correctRadius(radius) {\n            let aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio > 1) radius *= aspectRatio;\n            return radius;\n        }\n        function updatePointerDownData(pointer, id, posX, posY) {\n            pointer.id = id;\n            pointer.down = true;\n            pointer.moved = false;\n            pointer.texcoordX = posX / canvas.width;\n            pointer.texcoordY = 1.0 - posY / canvas.height;\n            pointer.prevTexcoordX = pointer.texcoordX;\n            pointer.prevTexcoordY = pointer.texcoordY;\n            pointer.deltaX = 0;\n            pointer.deltaY = 0;\n            pointer.color = generateColor();\n        }\n        function updatePointerMoveData(pointer, posX, posY, color) {\n            pointer.prevTexcoordX = pointer.texcoordX;\n            pointer.prevTexcoordY = pointer.texcoordY;\n            pointer.texcoordX = posX / canvas.width;\n            pointer.texcoordY = 1.0 - posY / canvas.height;\n            pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n            pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n            pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n            pointer.color = color;\n        }\n        function updatePointerUpData(pointer) {\n            pointer.down = false;\n        }\n        function correctDeltaX(delta) {\n            let aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio < 1) delta *= aspectRatio;\n            return delta;\n        }\n        function correctDeltaY(delta) {\n            let aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio > 1) delta /= aspectRatio;\n            return delta;\n        }\n        function generateColor() {\n            let c = HSVtoRGB(Math.random(), 1.0, 1.0);\n            c.r *= 0.15;\n            c.g *= 0.15;\n            c.b *= 0.15;\n            return c;\n        }\n        function HSVtoRGB(h, s, v) {\n            let r, g, b, i, f, p, q, t;\n            i = Math.floor(h * 6);\n            f = h * 6 - i;\n            p = v * (1 - s);\n            q = v * (1 - f * s);\n            t = v * (1 - (1 - f) * s);\n            switch(i % 6){\n                case 0:\n                    r = v;\n                    g = t;\n                    b = p;\n                    break;\n                case 1:\n                    r = q;\n                    g = v;\n                    b = p;\n                    break;\n                case 2:\n                    r = p;\n                    g = v;\n                    b = t;\n                    break;\n                case 3:\n                    r = p;\n                    g = q;\n                    b = v;\n                    break;\n                case 4:\n                    r = t;\n                    g = p;\n                    b = v;\n                    break;\n                case 5:\n                    r = v;\n                    g = p;\n                    b = q;\n                    break;\n                default:\n                    break;\n            }\n            return {\n                r,\n                g,\n                b\n            };\n        }\n        function wrap(value1, min, max) {\n            const range = max - min;\n            if (range === 0) return min;\n            return (value1 - min) % range + min;\n        }\n        function getResolution(resolution) {\n            let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n            if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;\n            const min = Math.round(resolution);\n            const max = Math.round(resolution * aspectRatio);\n            if (gl.drawingBufferWidth > gl.drawingBufferHeight) return {\n                width: max,\n                height: min\n            };\n            else return {\n                width: min,\n                height: max\n            };\n        }\n        function scaleByPixelRatio(input) {\n            const pixelRatio = window.devicePixelRatio || 1;\n            return Math.floor(input * pixelRatio);\n        }\n        function hashCode(s) {\n            if (s.length === 0) return 0;\n            let hash = 0;\n            for(let i = 0; i < s.length; i++){\n                hash = (hash << 5) - hash + s.charCodeAt(i);\n                hash |= 0;\n            }\n            return hash;\n        }\n        window.addEventListener(\"mousedown\", (e)=>{\n            let pointer = pointers[0];\n            let posX = scaleByPixelRatio(e.clientX);\n            let posY = scaleByPixelRatio(e.clientY);\n            updatePointerDownData(pointer, -1, posX, posY);\n            clickSplat(pointer);\n        });\n        document.body.addEventListener(\"mousemove\", function handleFirstMouseMove(e) {\n            let pointer = pointers[0];\n            let posX = scaleByPixelRatio(e.clientX);\n            let posY = scaleByPixelRatio(e.clientY);\n            let color = generateColor();\n            updateFrame(); // start animation loop\n            updatePointerMoveData(pointer, posX, posY, color);\n            document.body.removeEventListener(\"mousemove\", handleFirstMouseMove);\n        });\n        window.addEventListener(\"mousemove\", (e)=>{\n            let pointer = pointers[0];\n            let posX = scaleByPixelRatio(e.clientX);\n            let posY = scaleByPixelRatio(e.clientY);\n            let color = pointer.color;\n            updatePointerMoveData(pointer, posX, posY, color);\n        });\n        document.body.addEventListener(\"touchstart\", function handleFirstTouchStart(e) {\n            const touches = e.targetTouches;\n            let pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                let posX = scaleByPixelRatio(touches[i].clientX);\n                let posY = scaleByPixelRatio(touches[i].clientY);\n                updateFrame(); // start animation loop\n                updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n            }\n            document.body.removeEventListener(\"touchstart\", handleFirstTouchStart);\n        });\n        window.addEventListener(\"touchstart\", (e)=>{\n            const touches = e.targetTouches;\n            let pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                let posX = scaleByPixelRatio(touches[i].clientX);\n                let posY = scaleByPixelRatio(touches[i].clientY);\n                updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n            }\n        });\n        window.addEventListener(\"touchmove\", (e)=>{\n            const touches = e.targetTouches;\n            let pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                let posX = scaleByPixelRatio(touches[i].clientX);\n                let posY = scaleByPixelRatio(touches[i].clientY);\n                updatePointerMoveData(pointer, posX, posY, pointer.color);\n            }\n        }, false);\n        window.addEventListener(\"touchend\", (e)=>{\n            const touches = e.changedTouches;\n            let pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                updatePointerUpData(pointer);\n            }\n        });\n        updateFrame();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        SIM_RESOLUTION,\n        DYE_RESOLUTION,\n        CAPTURE_RESOLUTION,\n        DENSITY_DISSIPATION,\n        VELOCITY_DISSIPATION,\n        PRESSURE,\n        PRESSURE_ITERATIONS,\n        CURL,\n        SPLAT_RADIUS,\n        SPLAT_FORCE,\n        SHADING,\n        COLOR_UPDATE_SPEED,\n        BACK_COLOR,\n        TRANSPARENT\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed top-0 left-0 z-50 pointer-events-none\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n            ref: canvasRef,\n            id: \"fluid\",\n            className: \"w-screen h-screen\"\n        }, void 0, false, {\n            fileName: \"/Users/adamsoto/Desktop/GEOSEO_LandingPage/src/components/ui/splash-cursor.tsx\",\n            lineNumber: 1272,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/adamsoto/Desktop/GEOSEO_LandingPage/src/components/ui/splash-cursor.tsx\",\n        lineNumber: 1271,\n        columnNumber: 5\n    }, this);\n}\n_s(SplashCursor, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = SplashCursor;\n\nvar _c;\n$RefreshReg$(_c, \"SplashCursor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL3NwbGFzaC1jdXJzb3IudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUMwQztBQUUxQyxTQUFTRSxhQUFhLEtBZ0JyQjtRQWhCcUIsRUFDcEIsZ0RBQWdEO0lBQ2hEQyxpQkFBaUIsR0FBRyxFQUNwQkMsaUJBQWlCLElBQUksRUFDckJDLHFCQUFxQixHQUFHLEVBQ3hCQyxzQkFBc0IsR0FBRyxFQUN6QkMsdUJBQXVCLENBQUMsRUFDeEJDLFdBQVcsR0FBRyxFQUNkQyxzQkFBc0IsRUFBRSxFQUN4QkMsT0FBTyxDQUFDLEVBQ1JDLGVBQWUsR0FBRyxFQUNsQkMsY0FBYyxJQUFJLEVBQ2xCQyxVQUFVLElBQUksRUFDZEMscUJBQXFCLEVBQUUsRUFDdkJDLGFBQWE7UUFBRUMsR0FBRztRQUFLQyxHQUFHO1FBQUdDLEdBQUc7SUFBRSxDQUFDLEVBQ25DQyxjQUFjLElBQUksRUFDbkIsR0FoQnFCOztJQWlCcEIsTUFBTUMsWUFBWW5CLDZDQUFNQSxDQUFDO0lBRXpCRCxnREFBU0EsQ0FBQztRQUNSLE1BQU1xQixTQUFTRCxVQUFVRSxPQUFPO1FBQ2hDLElBQUksQ0FBQ0QsUUFBUTtRQUViLE1BQU1FOztxQkFDSkMsS0FBSyxDQUFDO3FCQUNOQyxZQUFZO3FCQUNaQyxZQUFZO3FCQUNaQyxnQkFBZ0I7cUJBQ2hCQyxnQkFBZ0I7cUJBQ2hCQyxTQUFTO3FCQUNUQyxTQUFTO3FCQUNUQyxPQUFPO3FCQUNQQyxRQUFRO3FCQUNSQyxRQUFRO29CQUFDO29CQUFHO29CQUFHO2lCQUFFOztRQUNuQjtRQUVBLElBQUlDLFNBQVM7WUFDWC9CO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FxQixRQUFRO1lBQ1JwQjtZQUNBSTtRQUNGO1FBRUEsSUFBSWlCLFdBQVc7WUFBQyxJQUFJYjtTQUFVO1FBRTlCLE1BQU0sRUFBRWMsRUFB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QztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBSTtLQUNEO0lBRUQscUJBQ0UsOERBQUNzUztRQUFJQyxXQUFVO2tCQUNiLDRFQUFDclM7WUFBT3NTLEtBQUt2UztZQUFXSSxJQUFHO1lBQVFrUyxXQUFVOzs7Ozs7Ozs7OztBQUduRDtHQXZ2Q1N4VDtLQUFBQTtBQXl2Q2UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvc3BsYXNoLWN1cnNvci50c3g/YWFkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5cbmZ1bmN0aW9uIFNwbGFzaEN1cnNvcih7XG4gIC8vIEFkZCB3aGF0ZXZlciBwcm9wcyB5b3UgbGlrZSBmb3IgY3VzdG9taXphdGlvblxuICBTSU1fUkVTT0xVVElPTiA9IDEyOCxcbiAgRFlFX1JFU09MVVRJT04gPSAxNDQwLFxuICBDQVBUVVJFX1JFU09MVVRJT04gPSA1MTIsXG4gIERFTlNJVFlfRElTU0lQQVRJT04gPSAzLjUsXG4gIFZFTE9DSVRZX0RJU1NJUEFUSU9OID0gMixcbiAgUFJFU1NVUkUgPSAwLjEsXG4gIFBSRVNTVVJFX0lURVJBVElPTlMgPSAyMCxcbiAgQ1VSTCA9IDMsXG4gIFNQTEFUX1JBRElVUyA9IDAuMixcbiAgU1BMQVRfRk9SQ0UgPSA2MDAwLFxuICBTSEFESU5HID0gdHJ1ZSxcbiAgQ09MT1JfVVBEQVRFX1NQRUVEID0gMTAsXG4gIEJBQ0tfQ09MT1IgPSB7IHI6IDAuNSwgZzogMCwgYjogMCB9LFxuICBUUkFOU1BBUkVOVCA9IHRydWUsXG59KSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSByZXR1cm47XG5cbiAgICBjbGFzcyBQb2ludGVyIHtcbiAgICAgIGlkID0gLTE7XG4gICAgICB0ZXhjb29yZFggPSAwO1xuICAgICAgdGV4Y29vcmRZID0gMDtcbiAgICAgIHByZXZUZXhjb29yZFggPSAwO1xuICAgICAgcHJldlRleGNvb3JkWSA9IDA7XG4gICAgICBkZWx0YVggPSAwO1xuICAgICAgZGVsdGFZID0gMDtcbiAgICAgIGRvd24gPSBmYWxzZTtcbiAgICAgIG1vdmVkID0gZmFsc2U7XG4gICAgICBjb2xvciA9IFswLCAwLCAwXTtcbiAgICB9XG5cbiAgICBsZXQgY29uZmlnID0ge1xuICAgICAgU0lNX1JFU09MVVRJT04sXG4gICAgICBEWUVfUkVTT0xVVElPTixcbiAgICAgIENBUFRVUkVfUkVTT0xVVElPTixcbiAgICAgIERFTlNJVFlfRElTU0lQQVRJT04sXG4gICAgICBWRUxPQ0lUWV9ESVNTSVBBVElPTixcbiAgICAgIFBSRVNTVVJFLFxuICAgICAgUFJFU1NVUkVfSVRFUkFUSU9OUyxcbiAgICAgIENVUkwsXG4gICAgICBTUExBVF9SQURJVVMsXG4gICAgICBTUExBVF9GT1JDRSxcbiAgICAgIFNIQURJTkcsXG4gICAgICBDT0xPUl9VUERBVEVfU1BFRUQsXG4gICAgICBQQVVTRUQ6IGZhbHNlLFxuICAgICAgQkFDS19DT0xPUixcbiAgICAgIFRSQU5TUEFSRU5ULFxuICAgIH07XG5cbiAgICBsZXQgcG9pbnRlcnMgPSBbbmV3IFBvaW50ZXIoKV07XG5cbiAgICBjb25zdCB7IGdsLCBleHQgfSA9IGdldFdlYkdMQ29udGV4dChjYW52YXMpO1xuICAgIGlmICghZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcpIHtcbiAgICAgIGNvbmZpZy5EWUVfUkVTT0xVVElPTiA9IDI1NjtcbiAgICAgIGNvbmZpZy5TSEFESU5HID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2ViR0xDb250ZXh0KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgYWxwaGE6IHRydWUsXG4gICAgICAgIGRlcHRoOiBmYWxzZSxcbiAgICAgICAgc3RlbmNpbDogZmFsc2UsXG4gICAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgICB9O1xuICAgICAgbGV0IGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgcGFyYW1zKTtcbiAgICAgIGNvbnN0IGlzV2ViR0wyID0gISFnbDtcbiAgICAgIGlmICghaXNXZWJHTDIpXG4gICAgICAgIGdsID1cbiAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIHBhcmFtcykgfHxcbiAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBwYXJhbXMpO1xuICAgICAgbGV0IGhhbGZGbG9hdDtcbiAgICAgIGxldCBzdXBwb3J0TGluZWFyRmlsdGVyaW5nO1xuICAgICAgaWYgKGlzV2ViR0wyKSB7XG4gICAgICAgIGdsLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIik7XG4gICAgICAgIHN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgPSBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYWxmRmxvYXQgPSBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpO1xuICAgICAgICBzdXBwb3J0TGluZWFyRmlsdGVyaW5nID0gZ2wuZ2V0RXh0ZW5zaW9uKFxuICAgICAgICAgIFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXJcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAxLjApO1xuICAgICAgY29uc3QgaGFsZkZsb2F0VGV4VHlwZSA9IGlzV2ViR0wyXG4gICAgICAgID8gZ2wuSEFMRl9GTE9BVFxuICAgICAgICA6IGhhbGZGbG9hdCAmJiBoYWxmRmxvYXQuSEFMRl9GTE9BVF9PRVM7XG4gICAgICBsZXQgZm9ybWF0UkdCQTtcbiAgICAgIGxldCBmb3JtYXRSRztcbiAgICAgIGxldCBmb3JtYXRSO1xuXG4gICAgICBpZiAoaXNXZWJHTDIpIHtcbiAgICAgICAgZm9ybWF0UkdCQSA9IGdldFN1cHBvcnRlZEZvcm1hdChcbiAgICAgICAgICBnbCxcbiAgICAgICAgICBnbC5SR0JBMTZGLFxuICAgICAgICAgIGdsLlJHQkEsXG4gICAgICAgICAgaGFsZkZsb2F0VGV4VHlwZVxuICAgICAgICApO1xuICAgICAgICBmb3JtYXRSRyA9IGdldFN1cHBvcnRlZEZvcm1hdChnbCwgZ2wuUkcxNkYsIGdsLlJHLCBoYWxmRmxvYXRUZXhUeXBlKTtcbiAgICAgICAgZm9ybWF0UiA9IGdldFN1cHBvcnRlZEZvcm1hdChnbCwgZ2wuUjE2RiwgZ2wuUkVELCBoYWxmRmxvYXRUZXhUeXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1hdFJHQkEgPSBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIGdsLlJHQkEsIGdsLlJHQkEsIGhhbGZGbG9hdFRleFR5cGUpO1xuICAgICAgICBmb3JtYXRSRyA9IGdldFN1cHBvcnRlZEZvcm1hdChnbCwgZ2wuUkdCQSwgZ2wuUkdCQSwgaGFsZkZsb2F0VGV4VHlwZSk7XG4gICAgICAgIGZvcm1hdFIgPSBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIGdsLlJHQkEsIGdsLlJHQkEsIGhhbGZGbG9hdFRleFR5cGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBnbCxcbiAgICAgICAgZXh0OiB7XG4gICAgICAgICAgZm9ybWF0UkdCQSxcbiAgICAgICAgICBmb3JtYXRSRyxcbiAgICAgICAgICBmb3JtYXRSLFxuICAgICAgICAgIGhhbGZGbG9hdFRleFR5cGUsXG4gICAgICAgICAgc3VwcG9ydExpbmVhckZpbHRlcmluZyxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3VwcG9ydGVkRm9ybWF0KFxuICAgICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsXG4gICAgICBpbnRlcm5hbEZvcm1hdDogYW55LFxuICAgICAgZm9ybWF0OiBhbnksXG4gICAgICB0eXBlOiBhbnlcbiAgICApIHtcbiAgICAgIGlmICghc3VwcG9ydFJlbmRlclRleHR1cmVGb3JtYXQoZ2wsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUpKSB7XG4gICAgICAgIHN3aXRjaCAoaW50ZXJuYWxGb3JtYXQpIHtcbiAgICAgICAgICBjYXNlIGdsLlIxNkY6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCBnbC5SRzE2RiwgZ2wuUkcsIHR5cGUpO1xuICAgICAgICAgIGNhc2UgZ2wuUkcxNkY6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCBnbC5SR0JBMTZGLCBnbC5SR0JBLCB0eXBlKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGludGVybmFsRm9ybWF0LFxuICAgICAgICBmb3JtYXQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1cHBvcnRSZW5kZXJUZXh0dXJlRm9ybWF0KFxuICAgICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsXG4gICAgICBpbnRlcm5hbEZvcm1hdDogYW55LFxuICAgICAgZm9ybWF0OiBhbnksXG4gICAgICB0eXBlOiBhbnlcbiAgICApIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICAwLFxuICAgICAgICBpbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgNCxcbiAgICAgICAgNCxcbiAgICAgICAgMCxcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgY29uc3QgZmJvID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmJvKTtcbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICBnbC5GUkFNRUJVRkZFUixcbiAgICAgICAgZ2wuQ09MT1JfQVRUQUNITUVOVDAsXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIHRleHR1cmUsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBjb25zdCBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcbiAgICAgIHJldHVybiBzdGF0dXMgPT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFO1xuICAgIH1cblxuICAgIGNsYXNzIE1hdGVyaWFsIHtcbiAgICAgIHZlcnRleFNoYWRlcjogYW55O1xuICAgICAgZnJhZ21lbnRTaGFkZXJTb3VyY2U6IGFueTtcbiAgICAgIHByb2dyYW1zOiBhbnlbXTtcbiAgICAgIGFjdGl2ZVByb2dyYW06IGFueTtcbiAgICAgIHVuaWZvcm1zOiBhbnlbXTtcbiAgICAgIGNvbnN0cnVjdG9yKHZlcnRleFNoYWRlcjogYW55LCBmcmFnbWVudFNoYWRlclNvdXJjZTogYW55KSB7XG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyO1xuICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyU291cmNlID0gZnJhZ21lbnRTaGFkZXJTb3VyY2U7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVQcm9ncmFtID0gbnVsbDtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IFtdO1xuICAgICAgfVxuICAgICAgc2V0S2V5d29yZHMoa2V5d29yZHM6IGFueSkge1xuICAgICAgICBsZXQgaGFzaCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5d29yZHMubGVuZ3RoOyBpKyspIGhhc2ggKz0gaGFzaENvZGUoa2V5d29yZHNbaV0pO1xuICAgICAgICBsZXQgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbXNbaGFzaF07XG4gICAgICAgIGlmIChwcm9ncmFtID09IG51bGwpIHtcbiAgICAgICAgICBsZXQgZnJhZ21lbnRTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFNoYWRlclNvdXJjZSxcbiAgICAgICAgICAgIGtleXdvcmRzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSh0aGlzLnZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgICAgIHRoaXMucHJvZ3JhbXNbaGFzaF0gPSBwcm9ncmFtO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmFtID09PSB0aGlzLmFjdGl2ZVByb2dyYW0pIHJldHVybjtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IGdldFVuaWZvcm1zKHByb2dyYW0pO1xuICAgICAgICB0aGlzLmFjdGl2ZVByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgfVxuICAgICAgYmluZCgpIHtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLmFjdGl2ZVByb2dyYW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIFByb2dyYW0ge1xuICAgICAgdW5pZm9ybXM6IGFueTtcbiAgICAgIHByb2dyYW06IGFueTtcbiAgICAgIGNvbnN0cnVjdG9yKHZlcnRleFNoYWRlcjogYW55LCBmcmFnbWVudFNoYWRlcjogYW55KSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSB7fTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSh2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKTtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IGdldFVuaWZvcm1zKHRoaXMucHJvZ3JhbSk7XG4gICAgICB9XG4gICAgICBiaW5kKCkge1xuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSh2ZXJ0ZXhTaGFkZXI6IGFueSwgZnJhZ21lbnRTaGFkZXI6IGFueSkge1xuICAgICAgbGV0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpXG4gICAgICAgIGNvbnNvbGUudHJhY2UoZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VW5pZm9ybXMocHJvZ3JhbTogYW55KSB7XG4gICAgICBsZXQgdW5pZm9ybXMgPSBbXTtcbiAgICAgIGxldCB1bmlmb3JtQ291bnQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuaWZvcm1Db3VudDsgaSsrKSB7XG4gICAgICAgIGxldCB1bmlmb3JtTmFtZSA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaSkubmFtZTtcbiAgICAgICAgdW5pZm9ybXNbdW5pZm9ybU5hbWVdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmlmb3JtcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21waWxlU2hhZGVyKHR5cGU6IGFueSwgc291cmNlOiBhbnksIGtleXdvcmRzOiBhbnkpIHtcbiAgICAgIHNvdXJjZSA9IGFkZEtleXdvcmRzKHNvdXJjZSwga2V5d29yZHMpO1xuICAgICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcbiAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKVxuICAgICAgICBjb25zb2xlLnRyYWNlKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gICAgICByZXR1cm4gc2hhZGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEtleXdvcmRzKHNvdXJjZTogYW55LCBrZXl3b3JkczogYW55KSB7XG4gICAgICBpZiAoIWtleXdvcmRzKSByZXR1cm4gc291cmNlO1xuICAgICAgbGV0IGtleXdvcmRzU3RyaW5nID0gXCJcIjtcbiAgICAgIGtleXdvcmRzLmZvckVhY2goKGtleXdvcmQ6IGFueSkgPT4ge1xuICAgICAgICBrZXl3b3Jkc1N0cmluZyArPSBcIiNkZWZpbmUgXCIgKyBrZXl3b3JkICsgXCJcXG5cIjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGtleXdvcmRzU3RyaW5nICsgc291cmNlO1xuICAgIH1cblxuICAgIGNvbnN0IGJhc2VWZXJ0ZXhTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wuVkVSVEVYX1NIQURFUixcbiAgICAgIGBcbiAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgICAgICB2YXJ5aW5nIHZlYzIgdlQ7XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2QjtcbiAgICAgICAgdW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgdlV2ID0gYVBvc2l0aW9uICogMC41ICsgMC41O1xuICAgICAgICAgICAgdkwgPSB2VXYgLSB2ZWMyKHRleGVsU2l6ZS54LCAwLjApO1xuICAgICAgICAgICAgdlIgPSB2VXYgKyB2ZWMyKHRleGVsU2l6ZS54LCAwLjApO1xuICAgICAgICAgICAgdlQgPSB2VXYgKyB2ZWMyKDAuMCwgdGV4ZWxTaXplLnkpO1xuICAgICAgICAgICAgdkIgPSB2VXYgLSB2ZWMyKDAuMCwgdGV4ZWxTaXplLnkpO1xuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgICAgICB9XG4gICAgICBgXG4gICAgKTtcblxuICAgIGNvbnN0IGNvcHlTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICAgICAgYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpO1xuICAgICAgICB9XG4gICAgICBgXG4gICAgKTtcblxuICAgIGNvbnN0IGNsZWFyU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdmFsdWU7XG5cbiAgICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZhbHVlICogdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpO1xuICAgICAgICB9XG4gICAgIGBcbiAgICApO1xuXG4gICAgY29uc3QgZGlzcGxheVNoYWRlclNvdXJjZSA9IGBcbiAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgICAgdmFyeWluZyB2ZWMyIHZMO1xuICAgICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgICAgdmFyeWluZyB2ZWMyIHZUO1xuICAgICAgdmFyeWluZyB2ZWMyIHZCO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1RGl0aGVyaW5nO1xuICAgICAgdW5pZm9ybSB2ZWMyIGRpdGhlclNjYWxlO1xuICAgICAgdW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcblxuICAgICAgdmVjMyBsaW5lYXJUb0dhbW1hICh2ZWMzIGNvbG9yKSB7XG4gICAgICAgICAgY29sb3IgPSBtYXgoY29sb3IsIHZlYzMoMCkpO1xuICAgICAgICAgIHJldHVybiBtYXgoMS4wNTUgKiBwb3coY29sb3IsIHZlYzMoMC40MTY2NjY2NjcpKSAtIDAuMDU1LCB2ZWMzKDApKTtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICB2ZWMzIGMgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZVdikucmdiO1xuICAgICAgICAgICNpZmRlZiBTSEFESU5HXG4gICAgICAgICAgICAgIHZlYzMgbGMgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZMKS5yZ2I7XG4gICAgICAgICAgICAgIHZlYzMgcmMgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZSKS5yZ2I7XG4gICAgICAgICAgICAgIHZlYzMgdGMgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUKS5yZ2I7XG4gICAgICAgICAgICAgIHZlYzMgYmMgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZCKS5yZ2I7XG5cbiAgICAgICAgICAgICAgZmxvYXQgZHggPSBsZW5ndGgocmMpIC0gbGVuZ3RoKGxjKTtcbiAgICAgICAgICAgICAgZmxvYXQgZHkgPSBsZW5ndGgodGMpIC0gbGVuZ3RoKGJjKTtcblxuICAgICAgICAgICAgICB2ZWMzIG4gPSBub3JtYWxpemUodmVjMyhkeCwgZHksIGxlbmd0aCh0ZXhlbFNpemUpKSk7XG4gICAgICAgICAgICAgIHZlYzMgbCA9IHZlYzMoMC4wLCAwLjAsIDEuMCk7XG5cbiAgICAgICAgICAgICAgZmxvYXQgZGlmZnVzZSA9IGNsYW1wKGRvdChuLCBsKSArIDAuNywgMC43LCAxLjApO1xuICAgICAgICAgICAgICBjICo9IGRpZmZ1c2U7XG4gICAgICAgICAgI2VuZGlmXG5cbiAgICAgICAgICBmbG9hdCBhID0gbWF4KGMuciwgbWF4KGMuZywgYy5iKSk7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjLCBhKTtcbiAgICAgIH1cbiAgICBgO1xuXG4gICAgY29uc3Qgc3BsYXRTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICAgICAgYFxuICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUYXJnZXQ7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgYXNwZWN0UmF0aW87XG4gICAgICAgIHVuaWZvcm0gdmVjMyBjb2xvcjtcbiAgICAgICAgdW5pZm9ybSB2ZWMyIHBvaW50O1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgdmVjMiBwID0gdlV2IC0gcG9pbnQueHk7XG4gICAgICAgICAgICBwLnggKj0gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB2ZWMzIHNwbGF0ID0gZXhwKC1kb3QocCwgcCkgLyByYWRpdXMpICogY29sb3I7XG4gICAgICAgICAgICB2ZWMzIGJhc2UgPSB0ZXh0dXJlMkQodVRhcmdldCwgdlV2KS54eXo7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGJhc2UgKyBzcGxhdCwgMS4wKTtcbiAgICAgICAgfVxuICAgICAgYFxuICAgICk7XG5cbiAgICBjb25zdCBhZHZlY3Rpb25TaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICAgICAgYFxuICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNvdXJjZTtcbiAgICAgICAgdW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcbiAgICAgICAgdW5pZm9ybSB2ZWMyIGR5ZVRleGVsU2l6ZTtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBkdDtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBkaXNzaXBhdGlvbjtcblxuICAgICAgICB2ZWM0IGJpbGVycCAoc2FtcGxlcjJEIHNhbSwgdmVjMiB1diwgdmVjMiB0c2l6ZSkge1xuICAgICAgICAgICAgdmVjMiBzdCA9IHV2IC8gdHNpemUgLSAwLjU7XG4gICAgICAgICAgICB2ZWMyIGl1diA9IGZsb29yKHN0KTtcbiAgICAgICAgICAgIHZlYzIgZnV2ID0gZnJhY3Qoc3QpO1xuXG4gICAgICAgICAgICB2ZWM0IGEgPSB0ZXh0dXJlMkQoc2FtLCAoaXV2ICsgdmVjMigwLjUsIDAuNSkpICogdHNpemUpO1xuICAgICAgICAgICAgdmVjNCBiID0gdGV4dHVyZTJEKHNhbSwgKGl1diArIHZlYzIoMS41LCAwLjUpKSAqIHRzaXplKTtcbiAgICAgICAgICAgIHZlYzQgYyA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDAuNSwgMS41KSkgKiB0c2l6ZSk7XG4gICAgICAgICAgICB2ZWM0IGQgPSB0ZXh0dXJlMkQoc2FtLCAoaXV2ICsgdmVjMigxLjUsIDEuNSkpICogdHNpemUpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWl4KG1peChhLCBiLCBmdXYueCksIG1peChjLCBkLCBmdXYueCksIGZ1di55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgICAjaWZkZWYgTUFOVUFMX0ZJTFRFUklOR1xuICAgICAgICAgICAgICAgIHZlYzIgY29vcmQgPSB2VXYgLSBkdCAqIGJpbGVycCh1VmVsb2NpdHksIHZVdiwgdGV4ZWxTaXplKS54eSAqIHRleGVsU2l6ZTtcbiAgICAgICAgICAgICAgICB2ZWM0IHJlc3VsdCA9IGJpbGVycCh1U291cmNlLCBjb29yZCwgZHllVGV4ZWxTaXplKTtcbiAgICAgICAgICAgICNlbHNlXG4gICAgICAgICAgICAgICAgdmVjMiBjb29yZCA9IHZVdiAtIGR0ICogdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eSAqIHRleGVsU2l6ZTtcbiAgICAgICAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHRleHR1cmUyRCh1U291cmNlLCBjb29yZCk7XG4gICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAgIGZsb2F0IGRlY2F5ID0gMS4wICsgZGlzc2lwYXRpb24gKiBkdDtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHJlc3VsdCAvIGRlY2F5O1xuICAgICAgICB9XG4gICAgICBgLFxuICAgICAgZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgPyBudWxsIDogW1wiTUFOVUFMX0ZJTFRFUklOR1wiXVxuICAgICk7XG5cbiAgICBjb25zdCBkaXZlcmdlbmNlU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG5cbiAgICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICAgIGZsb2F0IEwgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2TCkueDtcbiAgICAgICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2UikueDtcbiAgICAgICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VCkueTtcbiAgICAgICAgICAgIGZsb2F0IEIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2QikueTtcblxuICAgICAgICAgICAgdmVjMiBDID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eTtcbiAgICAgICAgICAgIGlmICh2TC54IDwgMC4wKSB7IEwgPSAtQy54OyB9XG4gICAgICAgICAgICBpZiAodlIueCA+IDEuMCkgeyBSID0gLUMueDsgfVxuICAgICAgICAgICAgaWYgKHZULnkgPiAxLjApIHsgVCA9IC1DLnk7IH1cbiAgICAgICAgICAgIGlmICh2Qi55IDwgMC4wKSB7IEIgPSAtQy55OyB9XG5cbiAgICAgICAgICAgIGZsb2F0IGRpdiA9IDAuNSAqIChSIC0gTCArIFQgLSBCKTtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZGl2LCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgfVxuICAgICAgYFxuICAgICk7XG5cbiAgICBjb25zdCBjdXJsU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG5cbiAgICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICAgIGZsb2F0IEwgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2TCkueTtcbiAgICAgICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2UikueTtcbiAgICAgICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VCkueDtcbiAgICAgICAgICAgIGZsb2F0IEIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2QikueDtcbiAgICAgICAgICAgIGZsb2F0IHZvcnRpY2l0eSA9IFIgLSBMIC0gVCArIEI7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuNSAqIHZvcnRpY2l0eSwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICAgIH1cbiAgICAgIGBcbiAgICApO1xuXG4gICAgY29uc3Qgdm9ydGljaXR5U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgICAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgICAgIHZhcnlpbmcgdmVjMiB2UjtcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZUO1xuICAgICAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdUN1cmw7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgY3VybDtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBkdDtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1Q3VybCwgdkwpLng7XG4gICAgICAgICAgICBmbG9hdCBSID0gdGV4dHVyZTJEKHVDdXJsLCB2UikueDtcbiAgICAgICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodUN1cmwsIHZUKS54O1xuICAgICAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1Q3VybCwgdkIpLng7XG4gICAgICAgICAgICBmbG9hdCBDID0gdGV4dHVyZTJEKHVDdXJsLCB2VXYpLng7XG5cbiAgICAgICAgICAgIHZlYzIgZm9yY2UgPSAwLjUgKiB2ZWMyKGFicyhUKSAtIGFicyhCKSwgYWJzKFIpIC0gYWJzKEwpKTtcbiAgICAgICAgICAgIGZvcmNlIC89IGxlbmd0aChmb3JjZSkgKyAwLjAwMDE7XG4gICAgICAgICAgICBmb3JjZSAqPSBjdXJsICogQztcbiAgICAgICAgICAgIGZvcmNlLnkgKj0gLTEuMDtcblxuICAgICAgICAgICAgdmVjMiB2ZWxvY2l0eSA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZVdikueHk7XG4gICAgICAgICAgICB2ZWxvY2l0eSArPSBmb3JjZSAqIGR0O1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBtaW4obWF4KHZlbG9jaXR5LCAtMTAwMC4wKSwgMTAwMC4wKTtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVsb2NpdHksIDAuMCwgMS4wKTtcbiAgICAgICAgfVxuICAgICAgYFxuICAgICk7XG5cbiAgICBjb25zdCBwcmVzc3VyZVNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICBgXG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2TDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZSO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlQ7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2QjtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVByZXNzdXJlO1xuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1RGl2ZXJnZW5jZTtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZMKS54O1xuICAgICAgICAgICAgZmxvYXQgUiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZSKS54O1xuICAgICAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZUKS54O1xuICAgICAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZCKS54O1xuICAgICAgICAgICAgZmxvYXQgQyA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZVdikueDtcbiAgICAgICAgICAgIGZsb2F0IGRpdmVyZ2VuY2UgPSB0ZXh0dXJlMkQodURpdmVyZ2VuY2UsIHZVdikueDtcbiAgICAgICAgICAgIGZsb2F0IHByZXNzdXJlID0gKEwgKyBSICsgQiArIFQgLSBkaXZlcmdlbmNlKSAqIDAuMjU7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHByZXNzdXJlLCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgfVxuICAgICAgYFxuICAgICk7XG5cbiAgICBjb25zdCBncmFkaWVudFN1YnRyYWN0U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VDtcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1UHJlc3N1cmU7XG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZMKS54O1xuICAgICAgICAgICAgZmxvYXQgUiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZSKS54O1xuICAgICAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZUKS54O1xuICAgICAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZCKS54O1xuICAgICAgICAgICAgdmVjMiB2ZWxvY2l0eSA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZVdikueHk7XG4gICAgICAgICAgICB2ZWxvY2l0eS54eSAtPSB2ZWMyKFIgLSBMLCBUIC0gQik7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlbG9jaXR5LCAwLjAsIDEuMCk7XG4gICAgICAgIH1cbiAgICAgIGBcbiAgICApO1xuXG4gICAgY29uc3QgYmxpdCA9ICgoKSA9PiB7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShcbiAgICAgICAgZ2wuQVJSQVlfQlVGRkVSLFxuICAgICAgICBuZXcgRmxvYXQzMkFycmF5KFstMSwgLTEsIC0xLCAxLCAxLCAxLCAxLCAtMV0pLFxuICAgICAgICBnbC5TVEFUSUNfRFJBV1xuICAgICAgKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdsLmNyZWF0ZUJ1ZmZlcigpKTtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoXG4gICAgICAgIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLFxuICAgICAgICBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDAsIDIsIDNdKSxcbiAgICAgICAgZ2wuU1RBVElDX0RSQVdcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKDAsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSgwKTtcbiAgICAgIHJldHVybiAodGFyZ2V0LCBjbGVhciA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG4gICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHQpO1xuICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGFyZ2V0LmZibyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsZWFyKSB7XG4gICAgICAgICAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAxLjApO1xuICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICB9XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIGxldCBkeWUsIHZlbG9jaXR5LCBkaXZlcmdlbmNlLCBjdXJsLCBwcmVzc3VyZTtcblxuICAgIGNvbnN0IGNvcHlQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgY29weVNoYWRlcik7XG4gICAgY29uc3QgY2xlYXJQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgY2xlYXJTaGFkZXIpO1xuICAgIGNvbnN0IHNwbGF0UHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIHNwbGF0U2hhZGVyKTtcbiAgICBjb25zdCBhZHZlY3Rpb25Qcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgYWR2ZWN0aW9uU2hhZGVyKTtcbiAgICBjb25zdCBkaXZlcmdlbmNlUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGRpdmVyZ2VuY2VTaGFkZXIpO1xuICAgIGNvbnN0IGN1cmxQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgY3VybFNoYWRlcik7XG4gICAgY29uc3Qgdm9ydGljaXR5UHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIHZvcnRpY2l0eVNoYWRlcik7XG4gICAgY29uc3QgcHJlc3N1cmVQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgcHJlc3N1cmVTaGFkZXIpO1xuICAgIGNvbnN0IGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0gPSBuZXcgUHJvZ3JhbShcbiAgICAgIGJhc2VWZXJ0ZXhTaGFkZXIsXG4gICAgICBncmFkaWVudFN1YnRyYWN0U2hhZGVyXG4gICAgKTtcbiAgICBjb25zdCBkaXNwbGF5TWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoYmFzZVZlcnRleFNoYWRlciwgZGlzcGxheVNoYWRlclNvdXJjZSk7XG5cbiAgICBmdW5jdGlvbiBpbml0RnJhbWVidWZmZXJzKCkge1xuICAgICAgbGV0IHNpbVJlcyA9IGdldFJlc29sdXRpb24oY29uZmlnLlNJTV9SRVNPTFVUSU9OKTtcbiAgICAgIGxldCBkeWVSZXMgPSBnZXRSZXNvbHV0aW9uKGNvbmZpZy5EWUVfUkVTT0xVVElPTik7XG4gICAgICBjb25zdCB0ZXhUeXBlID0gZXh0LmhhbGZGbG9hdFRleFR5cGU7XG4gICAgICBjb25zdCByZ2JhID0gZXh0LmZvcm1hdFJHQkE7XG4gICAgICBjb25zdCByZyA9IGV4dC5mb3JtYXRSRztcbiAgICAgIGNvbnN0IHIgPSBleHQuZm9ybWF0UjtcbiAgICAgIGNvbnN0IGZpbHRlcmluZyA9IGV4dC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVDtcbiAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXG4gICAgICBpZiAoIWR5ZSlcbiAgICAgICAgZHllID0gY3JlYXRlRG91YmxlRkJPKFxuICAgICAgICAgIGR5ZVJlcy53aWR0aCxcbiAgICAgICAgICBkeWVSZXMuaGVpZ2h0LFxuICAgICAgICAgIHJnYmEuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgICAgcmdiYS5mb3JtYXQsXG4gICAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgICBmaWx0ZXJpbmdcbiAgICAgICAgKTtcbiAgICAgIGVsc2VcbiAgICAgICAgZHllID0gcmVzaXplRG91YmxlRkJPKFxuICAgICAgICAgIGR5ZSxcbiAgICAgICAgICBkeWVSZXMud2lkdGgsXG4gICAgICAgICAgZHllUmVzLmhlaWdodCxcbiAgICAgICAgICByZ2JhLmludGVybmFsRm9ybWF0LFxuICAgICAgICAgIHJnYmEuZm9ybWF0LFxuICAgICAgICAgIHRleFR5cGUsXG4gICAgICAgICAgZmlsdGVyaW5nXG4gICAgICAgICk7XG5cbiAgICAgIGlmICghdmVsb2NpdHkpXG4gICAgICAgIHZlbG9jaXR5ID0gY3JlYXRlRG91YmxlRkJPKFxuICAgICAgICAgIHNpbVJlcy53aWR0aCxcbiAgICAgICAgICBzaW1SZXMuaGVpZ2h0LFxuICAgICAgICAgIHJnLmludGVybmFsRm9ybWF0LFxuICAgICAgICAgIHJnLmZvcm1hdCxcbiAgICAgICAgICB0ZXhUeXBlLFxuICAgICAgICAgIGZpbHRlcmluZ1xuICAgICAgICApO1xuICAgICAgZWxzZVxuICAgICAgICB2ZWxvY2l0eSA9IHJlc2l6ZURvdWJsZUZCTyhcbiAgICAgICAgICB2ZWxvY2l0eSxcbiAgICAgICAgICBzaW1SZXMud2lkdGgsXG4gICAgICAgICAgc2ltUmVzLmhlaWdodCxcbiAgICAgICAgICByZy5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgICByZy5mb3JtYXQsXG4gICAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgICBmaWx0ZXJpbmdcbiAgICAgICAgKTtcblxuICAgICAgZGl2ZXJnZW5jZSA9IGNyZWF0ZUZCTyhcbiAgICAgICAgc2ltUmVzLndpZHRoLFxuICAgICAgICBzaW1SZXMuaGVpZ2h0LFxuICAgICAgICByLmludGVybmFsRm9ybWF0LFxuICAgICAgICByLmZvcm1hdCxcbiAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgZ2wuTkVBUkVTVFxuICAgICAgKTtcbiAgICAgIGN1cmwgPSBjcmVhdGVGQk8oXG4gICAgICAgIHNpbVJlcy53aWR0aCxcbiAgICAgICAgc2ltUmVzLmhlaWdodCxcbiAgICAgICAgci5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgci5mb3JtYXQsXG4gICAgICAgIHRleFR5cGUsXG4gICAgICAgIGdsLk5FQVJFU1RcbiAgICAgICk7XG4gICAgICBwcmVzc3VyZSA9IGNyZWF0ZURvdWJsZUZCTyhcbiAgICAgICAgc2ltUmVzLndpZHRoLFxuICAgICAgICBzaW1SZXMuaGVpZ2h0LFxuICAgICAgICByLmludGVybmFsRm9ybWF0LFxuICAgICAgICByLmZvcm1hdCxcbiAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgZ2wuTkVBUkVTVFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgbGV0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBwYXJhbSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgcGFyYW0pO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIDAsXG4gICAgICAgIGludGVybmFsRm9ybWF0LFxuICAgICAgICB3LFxuICAgICAgICBoLFxuICAgICAgICAwLFxuICAgICAgICBmb3JtYXQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG5cbiAgICAgIGxldCBmYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmYm8pO1xuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCxcbiAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgdGV4dHVyZSxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHcsIGgpO1xuICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG5cbiAgICAgIGxldCB0ZXhlbFNpemVYID0gMS4wIC8gdztcbiAgICAgIGxldCB0ZXhlbFNpemVZID0gMS4wIC8gaDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHR1cmUsXG4gICAgICAgIGZibyxcbiAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgdGV4ZWxTaXplWCxcbiAgICAgICAgdGV4ZWxTaXplWSxcbiAgICAgICAgYXR0YWNoKGlkKSB7XG4gICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGlkKTtcbiAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURvdWJsZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSkge1xuICAgICAgbGV0IGZibzEgPSBjcmVhdGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pO1xuICAgICAgbGV0IGZibzIgPSBjcmVhdGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgdGV4ZWxTaXplWDogZmJvMS50ZXhlbFNpemVYLFxuICAgICAgICB0ZXhlbFNpemVZOiBmYm8xLnRleGVsU2l6ZVksXG4gICAgICAgIGdldCByZWFkKCkge1xuICAgICAgICAgIHJldHVybiBmYm8xO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgcmVhZCh2YWx1ZSkge1xuICAgICAgICAgIGZibzEgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHdyaXRlKCkge1xuICAgICAgICAgIHJldHVybiBmYm8yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgd3JpdGUodmFsdWUpIHtcbiAgICAgICAgICBmYm8yID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHN3YXAoKSB7XG4gICAgICAgICAgbGV0IHRlbXAgPSBmYm8xO1xuICAgICAgICAgIGZibzEgPSBmYm8yO1xuICAgICAgICAgIGZibzIgPSB0ZW1wO1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNpemVGQk8odGFyZ2V0LCB3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSkge1xuICAgICAgbGV0IG5ld0ZCTyA9IGNyZWF0ZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSk7XG4gICAgICBjb3B5UHJvZ3JhbS5iaW5kKCk7XG4gICAgICBnbC51bmlmb3JtMWkoY29weVByb2dyYW0udW5pZm9ybXMudVRleHR1cmUsIHRhcmdldC5hdHRhY2goMCkpO1xuICAgICAgYmxpdChuZXdGQk8pO1xuICAgICAgcmV0dXJuIG5ld0ZCTztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNpemVEb3VibGVGQk8oXG4gICAgICB0YXJnZXQsXG4gICAgICB3LFxuICAgICAgaCxcbiAgICAgIGludGVybmFsRm9ybWF0LFxuICAgICAgZm9ybWF0LFxuICAgICAgdHlwZSxcbiAgICAgIHBhcmFtXG4gICAgKSB7XG4gICAgICBpZiAodGFyZ2V0LndpZHRoID09PSB3ICYmIHRhcmdldC5oZWlnaHQgPT09IGgpIHJldHVybiB0YXJnZXQ7XG4gICAgICB0YXJnZXQucmVhZCA9IHJlc2l6ZUZCTyhcbiAgICAgICAgdGFyZ2V0LnJlYWQsXG4gICAgICAgIHcsXG4gICAgICAgIGgsXG4gICAgICAgIGludGVybmFsRm9ybWF0LFxuICAgICAgICBmb3JtYXQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBhcmFtXG4gICAgICApO1xuICAgICAgdGFyZ2V0LndyaXRlID0gY3JlYXRlRkJPKHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKTtcbiAgICAgIHRhcmdldC53aWR0aCA9IHc7XG4gICAgICB0YXJnZXQuaGVpZ2h0ID0gaDtcbiAgICAgIHRhcmdldC50ZXhlbFNpemVYID0gMS4wIC8gdztcbiAgICAgIHRhcmdldC50ZXhlbFNpemVZID0gMS4wIC8gaDtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlS2V5d29yZHMoKSB7XG4gICAgICBsZXQgZGlzcGxheUtleXdvcmRzID0gW107XG4gICAgICBpZiAoY29uZmlnLlNIQURJTkcpIGRpc3BsYXlLZXl3b3Jkcy5wdXNoKFwiU0hBRElOR1wiKTtcbiAgICAgIGRpc3BsYXlNYXRlcmlhbC5zZXRLZXl3b3JkcyhkaXNwbGF5S2V5d29yZHMpO1xuICAgIH1cblxuICAgIHVwZGF0ZUtleXdvcmRzKCk7XG4gICAgaW5pdEZyYW1lYnVmZmVycygpO1xuICAgIGxldCBsYXN0VXBkYXRlVGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGNvbG9yVXBkYXRlVGltZXIgPSAwLjA7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVGcmFtZSgpIHtcbiAgICAgIGNvbnN0IGR0ID0gY2FsY0RlbHRhVGltZSgpO1xuICAgICAgaWYgKHJlc2l6ZUNhbnZhcygpKSBpbml0RnJhbWVidWZmZXJzKCk7XG4gICAgICB1cGRhdGVDb2xvcnMoZHQpO1xuICAgICAgYXBwbHlJbnB1dHMoKTtcbiAgICAgIHN0ZXAoZHQpO1xuICAgICAgcmVuZGVyKG51bGwpO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZUZyYW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjRGVsdGFUaW1lKCkge1xuICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBsZXQgZHQgPSAobm93IC0gbGFzdFVwZGF0ZVRpbWUpIC8gMTAwMDtcbiAgICAgIGR0ID0gTWF0aC5taW4oZHQsIDAuMDE2NjY2KTtcbiAgICAgIGxhc3RVcGRhdGVUaW1lID0gbm93O1xuICAgICAgcmV0dXJuIGR0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZUNhbnZhcygpIHtcbiAgICAgIGxldCB3aWR0aCA9IHNjYWxlQnlQaXhlbFJhdGlvKGNhbnZhcy5jbGllbnRXaWR0aCk7XG4gICAgICBsZXQgaGVpZ2h0ID0gc2NhbGVCeVBpeGVsUmF0aW8oY2FudmFzLmNsaWVudEhlaWdodCk7XG4gICAgICBpZiAoY2FudmFzLndpZHRoICE9PSB3aWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbG9ycyhkdCkge1xuICAgICAgY29sb3JVcGRhdGVUaW1lciArPSBkdCAqIGNvbmZpZy5DT0xPUl9VUERBVEVfU1BFRUQ7XG4gICAgICBpZiAoY29sb3JVcGRhdGVUaW1lciA+PSAxKSB7XG4gICAgICAgIGNvbG9yVXBkYXRlVGltZXIgPSB3cmFwKGNvbG9yVXBkYXRlVGltZXIsIDAsIDEpO1xuICAgICAgICBwb2ludGVycy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgcC5jb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlJbnB1dHMoKSB7XG4gICAgICBwb2ludGVycy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgIGlmIChwLm1vdmVkKSB7XG4gICAgICAgICAgcC5tb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgIHNwbGF0UG9pbnRlcihwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RlcChkdCkge1xuICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gICAgICAvLyBDdXJsXG4gICAgICBjdXJsUHJvZ3JhbS5iaW5kKCk7XG4gICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgIGN1cmxQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xaShjdXJsUHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApKTtcbiAgICAgIGJsaXQoY3VybCk7XG5cbiAgICAgIC8vIFZvcnRpY2l0eVxuICAgICAgdm9ydGljaXR5UHJvZ3JhbS5iaW5kKCk7XG4gICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgIHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFpKFxuICAgICAgICB2b3J0aWNpdHlQcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSxcbiAgICAgICAgdmVsb2NpdHkucmVhZC5hdHRhY2goMClcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWkodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy51Q3VybCwgY3VybC5hdHRhY2goMSkpO1xuICAgICAgZ2wudW5pZm9ybTFmKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMuY3VybCwgY29uZmlnLkNVUkwpO1xuICAgICAgZ2wudW5pZm9ybTFmKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMuZHQsIGR0KTtcbiAgICAgIGJsaXQodmVsb2NpdHkud3JpdGUpO1xuICAgICAgdmVsb2NpdHkuc3dhcCgpO1xuXG4gICAgICAvLyBEaXZlcmdlbmNlXG4gICAgICBkaXZlcmdlbmNlUHJvZ3JhbS5iaW5kKCk7XG4gICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgIGRpdmVyZ2VuY2VQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xaShcbiAgICAgICAgZGl2ZXJnZW5jZVByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LFxuICAgICAgICB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgwKVxuICAgICAgKTtcbiAgICAgIGJsaXQoZGl2ZXJnZW5jZSk7XG5cbiAgICAgIC8vIENsZWFyIHByZXNzdXJlXG4gICAgICBjbGVhclByb2dyYW0uYmluZCgpO1xuICAgICAgZ2wudW5pZm9ybTFpKGNsZWFyUHJvZ3JhbS51bmlmb3Jtcy51VGV4dHVyZSwgcHJlc3N1cmUucmVhZC5hdHRhY2goMCkpO1xuICAgICAgZ2wudW5pZm9ybTFmKGNsZWFyUHJvZ3JhbS51bmlmb3Jtcy52YWx1ZSwgY29uZmlnLlBSRVNTVVJFKTtcbiAgICAgIGJsaXQocHJlc3N1cmUud3JpdGUpO1xuICAgICAgcHJlc3N1cmUuc3dhcCgpO1xuXG4gICAgICAvLyBQcmVzc3VyZVxuICAgICAgcHJlc3N1cmVQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGdsLnVuaWZvcm0yZihcbiAgICAgICAgcHJlc3N1cmVQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xaShwcmVzc3VyZVByb2dyYW0udW5pZm9ybXMudURpdmVyZ2VuY2UsIGRpdmVyZ2VuY2UuYXR0YWNoKDApKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmlnLlBSRVNTVVJFX0lURVJBVElPTlM7IGkrKykge1xuICAgICAgICBnbC51bmlmb3JtMWkoXG4gICAgICAgICAgcHJlc3N1cmVQcm9ncmFtLnVuaWZvcm1zLnVQcmVzc3VyZSxcbiAgICAgICAgICBwcmVzc3VyZS5yZWFkLmF0dGFjaCgxKVxuICAgICAgICApO1xuICAgICAgICBibGl0KHByZXNzdXJlLndyaXRlKTtcbiAgICAgICAgcHJlc3N1cmUuc3dhcCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBHcmFkaWVudCBTdWJ0cmFjdFxuICAgICAgZ3JhZGllblN1YnRyYWN0UHJvZ3JhbS5iaW5kKCk7XG4gICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgIGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFpKFxuICAgICAgICBncmFkaWVuU3VidHJhY3RQcm9ncmFtLnVuaWZvcm1zLnVQcmVzc3VyZSxcbiAgICAgICAgcHJlc3N1cmUucmVhZC5hdHRhY2goMClcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWkoXG4gICAgICAgIGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LFxuICAgICAgICB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgxKVxuICAgICAgKTtcbiAgICAgIGJsaXQodmVsb2NpdHkud3JpdGUpO1xuICAgICAgdmVsb2NpdHkuc3dhcCgpO1xuXG4gICAgICAvLyBBZHZlY3Rpb25cbiAgICAgIGFkdmVjdGlvblByb2dyYW0uYmluZCgpO1xuICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICBhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICAgICAgKTtcbiAgICAgIGlmICghZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcpXG4gICAgICAgIGdsLnVuaWZvcm0yZihcbiAgICAgICAgICBhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmR5ZVRleGVsU2l6ZSxcbiAgICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgICAgICAgKTtcbiAgICAgIGxldCB2ZWxvY2l0eUlkID0gdmVsb2NpdHkucmVhZC5hdHRhY2goMCk7XG4gICAgICBnbC51bmlmb3JtMWkoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksIHZlbG9jaXR5SWQpO1xuICAgICAgZ2wudW5pZm9ybTFpKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVNvdXJjZSwgdmVsb2NpdHlJZCk7XG4gICAgICBnbC51bmlmb3JtMWYoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5kdCwgZHQpO1xuICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICBhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmRpc3NpcGF0aW9uLFxuICAgICAgICBjb25maWcuVkVMT0NJVFlfRElTU0lQQVRJT05cbiAgICAgICk7XG4gICAgICBibGl0KHZlbG9jaXR5LndyaXRlKTtcbiAgICAgIHZlbG9jaXR5LnN3YXAoKTtcblxuICAgICAgaWYgKCFleHQuc3VwcG9ydExpbmVhckZpbHRlcmluZylcbiAgICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZHllVGV4ZWxTaXplLFxuICAgICAgICAgIGR5ZS50ZXhlbFNpemVYLFxuICAgICAgICAgIGR5ZS50ZXhlbFNpemVZXG4gICAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWkoXG4gICAgICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LFxuICAgICAgICB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgwKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xaShhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnVTb3VyY2UsIGR5ZS5yZWFkLmF0dGFjaCgxKSk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZGlzc2lwYXRpb24sXG4gICAgICAgIGNvbmZpZy5ERU5TSVRZX0RJU1NJUEFUSU9OXG4gICAgICApO1xuICAgICAgYmxpdChkeWUud3JpdGUpO1xuICAgICAgZHllLnN3YXAoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXIodGFyZ2V0KSB7XG4gICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICBkcmF3RGlzcGxheSh0YXJnZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdEaXNwbGF5KHRhcmdldCkge1xuICAgICAgbGV0IHdpZHRoID0gdGFyZ2V0ID09IG51bGwgPyBnbC5kcmF3aW5nQnVmZmVyV2lkdGggOiB0YXJnZXQud2lkdGg7XG4gICAgICBsZXQgaGVpZ2h0ID0gdGFyZ2V0ID09IG51bGwgPyBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0IDogdGFyZ2V0LmhlaWdodDtcbiAgICAgIGRpc3BsYXlNYXRlcmlhbC5iaW5kKCk7XG4gICAgICBpZiAoY29uZmlnLlNIQURJTkcpXG4gICAgICAgIGdsLnVuaWZvcm0yZihcbiAgICAgICAgICBkaXNwbGF5TWF0ZXJpYWwudW5pZm9ybXMudGV4ZWxTaXplLFxuICAgICAgICAgIDEuMCAvIHdpZHRoLFxuICAgICAgICAgIDEuMCAvIGhlaWdodFxuICAgICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFpKGRpc3BsYXlNYXRlcmlhbC51bmlmb3Jtcy51VGV4dHVyZSwgZHllLnJlYWQuYXR0YWNoKDApKTtcbiAgICAgIGJsaXQodGFyZ2V0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGxhdFBvaW50ZXIocG9pbnRlcikge1xuICAgICAgbGV0IGR4ID0gcG9pbnRlci5kZWx0YVggKiBjb25maWcuU1BMQVRfRk9SQ0U7XG4gICAgICBsZXQgZHkgPSBwb2ludGVyLmRlbHRhWSAqIGNvbmZpZy5TUExBVF9GT1JDRTtcbiAgICAgIHNwbGF0KHBvaW50ZXIudGV4Y29vcmRYLCBwb2ludGVyLnRleGNvb3JkWSwgZHgsIGR5LCBwb2ludGVyLmNvbG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGlja1NwbGF0KHBvaW50ZXIpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2VuZXJhdGVDb2xvcigpO1xuICAgICAgY29sb3IuciAqPSAxMC4wO1xuICAgICAgY29sb3IuZyAqPSAxMC4wO1xuICAgICAgY29sb3IuYiAqPSAxMC4wO1xuICAgICAgbGV0IGR4ID0gMTAgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSk7XG4gICAgICBsZXQgZHkgPSAzMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KTtcbiAgICAgIHNwbGF0KHBvaW50ZXIudGV4Y29vcmRYLCBwb2ludGVyLnRleGNvb3JkWSwgZHgsIGR5LCBjb2xvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3BsYXQoeCwgeSwgZHgsIGR5LCBjb2xvcikge1xuICAgICAgc3BsYXRQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGdsLnVuaWZvcm0xaShzcGxhdFByb2dyYW0udW5pZm9ybXMudVRhcmdldCwgdmVsb2NpdHkucmVhZC5hdHRhY2goMCkpO1xuICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICBzcGxhdFByb2dyYW0udW5pZm9ybXMuYXNwZWN0UmF0aW8sXG4gICAgICAgIGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHRcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMmYoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLnBvaW50LCB4LCB5KTtcbiAgICAgIGdsLnVuaWZvcm0zZihzcGxhdFByb2dyYW0udW5pZm9ybXMuY29sb3IsIGR4LCBkeSwgMC4wKTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgc3BsYXRQcm9ncmFtLnVuaWZvcm1zLnJhZGl1cyxcbiAgICAgICAgY29ycmVjdFJhZGl1cyhjb25maWcuU1BMQVRfUkFESVVTIC8gMTAwLjApXG4gICAgICApO1xuICAgICAgYmxpdCh2ZWxvY2l0eS53cml0ZSk7XG4gICAgICB2ZWxvY2l0eS5zd2FwKCk7XG5cbiAgICAgIGdsLnVuaWZvcm0xaShzcGxhdFByb2dyYW0udW5pZm9ybXMudVRhcmdldCwgZHllLnJlYWQuYXR0YWNoKDApKTtcbiAgICAgIGdsLnVuaWZvcm0zZihzcGxhdFByb2dyYW0udW5pZm9ybXMuY29sb3IsIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICAgICAgYmxpdChkeWUud3JpdGUpO1xuICAgICAgZHllLnN3YXAoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3JyZWN0UmFkaXVzKHJhZGl1cykge1xuICAgICAgbGV0IGFzcGVjdFJhdGlvID0gY2FudmFzLndpZHRoIC8gY2FudmFzLmhlaWdodDtcbiAgICAgIGlmIChhc3BlY3RSYXRpbyA+IDEpIHJhZGl1cyAqPSBhc3BlY3RSYXRpbztcbiAgICAgIHJldHVybiByYWRpdXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9pbnRlckRvd25EYXRhKHBvaW50ZXIsIGlkLCBwb3NYLCBwb3NZKSB7XG4gICAgICBwb2ludGVyLmlkID0gaWQ7XG4gICAgICBwb2ludGVyLmRvd24gPSB0cnVlO1xuICAgICAgcG9pbnRlci5tb3ZlZCA9IGZhbHNlO1xuICAgICAgcG9pbnRlci50ZXhjb29yZFggPSBwb3NYIC8gY2FudmFzLndpZHRoO1xuICAgICAgcG9pbnRlci50ZXhjb29yZFkgPSAxLjAgLSBwb3NZIC8gY2FudmFzLmhlaWdodDtcbiAgICAgIHBvaW50ZXIucHJldlRleGNvb3JkWCA9IHBvaW50ZXIudGV4Y29vcmRYO1xuICAgICAgcG9pbnRlci5wcmV2VGV4Y29vcmRZID0gcG9pbnRlci50ZXhjb29yZFk7XG4gICAgICBwb2ludGVyLmRlbHRhWCA9IDA7XG4gICAgICBwb2ludGVyLmRlbHRhWSA9IDA7XG4gICAgICBwb2ludGVyLmNvbG9yID0gZ2VuZXJhdGVDb2xvcigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXJNb3ZlRGF0YShwb2ludGVyLCBwb3NYLCBwb3NZLCBjb2xvcikge1xuICAgICAgcG9pbnRlci5wcmV2VGV4Y29vcmRYID0gcG9pbnRlci50ZXhjb29yZFg7XG4gICAgICBwb2ludGVyLnByZXZUZXhjb29yZFkgPSBwb2ludGVyLnRleGNvb3JkWTtcbiAgICAgIHBvaW50ZXIudGV4Y29vcmRYID0gcG9zWCAvIGNhbnZhcy53aWR0aDtcbiAgICAgIHBvaW50ZXIudGV4Y29vcmRZID0gMS4wIC0gcG9zWSAvIGNhbnZhcy5oZWlnaHQ7XG4gICAgICBwb2ludGVyLmRlbHRhWCA9IGNvcnJlY3REZWx0YVgocG9pbnRlci50ZXhjb29yZFggLSBwb2ludGVyLnByZXZUZXhjb29yZFgpO1xuICAgICAgcG9pbnRlci5kZWx0YVkgPSBjb3JyZWN0RGVsdGFZKHBvaW50ZXIudGV4Y29vcmRZIC0gcG9pbnRlci5wcmV2VGV4Y29vcmRZKTtcbiAgICAgIHBvaW50ZXIubW92ZWQgPVxuICAgICAgICBNYXRoLmFicyhwb2ludGVyLmRlbHRhWCkgPiAwIHx8IE1hdGguYWJzKHBvaW50ZXIuZGVsdGFZKSA+IDA7XG4gICAgICBwb2ludGVyLmNvbG9yID0gY29sb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9pbnRlclVwRGF0YShwb2ludGVyKSB7XG4gICAgICBwb2ludGVyLmRvd24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3JyZWN0RGVsdGFYKGRlbHRhKSB7XG4gICAgICBsZXQgYXNwZWN0UmF0aW8gPSBjYW52YXMud2lkdGggLyBjYW52YXMuaGVpZ2h0O1xuICAgICAgaWYgKGFzcGVjdFJhdGlvIDwgMSkgZGVsdGEgKj0gYXNwZWN0UmF0aW87XG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29ycmVjdERlbHRhWShkZWx0YSkge1xuICAgICAgbGV0IGFzcGVjdFJhdGlvID0gY2FudmFzLndpZHRoIC8gY2FudmFzLmhlaWdodDtcbiAgICAgIGlmIChhc3BlY3RSYXRpbyA+IDEpIGRlbHRhIC89IGFzcGVjdFJhdGlvO1xuICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ29sb3IoKSB7XG4gICAgICBsZXQgYyA9IEhTVnRvUkdCKE1hdGgucmFuZG9tKCksIDEuMCwgMS4wKTtcbiAgICAgIGMuciAqPSAwLjE1O1xuICAgICAgYy5nICo9IDAuMTU7XG4gICAgICBjLmIgKj0gMC4xNTtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEhTVnRvUkdCKGgsIHMsIHYpIHtcbiAgICAgIGxldCByLCBnLCBiLCBpLCBmLCBwLCBxLCB0O1xuICAgICAgaSA9IE1hdGguZmxvb3IoaCAqIDYpO1xuICAgICAgZiA9IGggKiA2IC0gaTtcbiAgICAgIHAgPSB2ICogKDEgLSBzKTtcbiAgICAgIHEgPSB2ICogKDEgLSBmICogcyk7XG4gICAgICB0ID0gdiAqICgxIC0gKDEgLSBmKSAqIHMpO1xuICAgICAgc3dpdGNoIChpICUgNikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgciA9IHY7XG4gICAgICAgICAgZyA9IHQ7XG4gICAgICAgICAgYiA9IHA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByID0gcTtcbiAgICAgICAgICBnID0gdjtcbiAgICAgICAgICBiID0gcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHIgPSBwO1xuICAgICAgICAgIGcgPSB2O1xuICAgICAgICAgIGIgPSB0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgciA9IHA7XG4gICAgICAgICAgZyA9IHE7XG4gICAgICAgICAgYiA9IHY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByID0gdDtcbiAgICAgICAgICBnID0gcDtcbiAgICAgICAgICBiID0gdjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHIgPSB2O1xuICAgICAgICAgIGcgPSBwO1xuICAgICAgICAgIGIgPSBxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgciwgZywgYiB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICBjb25zdCByYW5nZSA9IG1heCAtIG1pbjtcbiAgICAgIGlmIChyYW5nZSA9PT0gMCkgcmV0dXJuIG1pbjtcbiAgICAgIHJldHVybiAoKHZhbHVlIC0gbWluKSAlIHJhbmdlKSArIG1pbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICAgIGxldCBhc3BlY3RSYXRpbyA9IGdsLmRyYXdpbmdCdWZmZXJXaWR0aCAvIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQ7XG4gICAgICBpZiAoYXNwZWN0UmF0aW8gPCAxKSBhc3BlY3RSYXRpbyA9IDEuMCAvIGFzcGVjdFJhdGlvO1xuICAgICAgY29uc3QgbWluID0gTWF0aC5yb3VuZChyZXNvbHV0aW9uKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgucm91bmQocmVzb2x1dGlvbiAqIGFzcGVjdFJhdGlvKTtcbiAgICAgIGlmIChnbC5kcmF3aW5nQnVmZmVyV2lkdGggPiBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KVxuICAgICAgICByZXR1cm4geyB3aWR0aDogbWF4LCBoZWlnaHQ6IG1pbiB9O1xuICAgICAgZWxzZSByZXR1cm4geyB3aWR0aDogbWluLCBoZWlnaHQ6IG1heCB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYWxlQnlQaXhlbFJhdGlvKGlucHV0KSB7XG4gICAgICBjb25zdCBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGlucHV0ICogcGl4ZWxSYXRpbyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzaENvZGUocykge1xuICAgICAgaWYgKHMubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgICAgIGxldCBoYXNoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBoYXNoIHw9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZSkgPT4ge1xuICAgICAgbGV0IHBvaW50ZXIgPSBwb2ludGVyc1swXTtcbiAgICAgIGxldCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5jbGllbnRYKTtcbiAgICAgIGxldCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5jbGllbnRZKTtcbiAgICAgIHVwZGF0ZVBvaW50ZXJEb3duRGF0YShwb2ludGVyLCAtMSwgcG9zWCwgcG9zWSk7XG4gICAgICBjbGlja1NwbGF0KHBvaW50ZXIpO1xuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJtb3VzZW1vdmVcIixcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUZpcnN0TW91c2VNb3ZlKGUpIHtcbiAgICAgICAgbGV0IHBvaW50ZXIgPSBwb2ludGVyc1swXTtcbiAgICAgICAgbGV0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFgpO1xuICAgICAgICBsZXQgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKGUuY2xpZW50WSk7XG4gICAgICAgIGxldCBjb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcbiAgICAgICAgdXBkYXRlRnJhbWUoKTsgLy8gc3RhcnQgYW5pbWF0aW9uIGxvb3BcbiAgICAgICAgdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1ksIGNvbG9yKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZUZpcnN0TW91c2VNb3ZlKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgKGUpID0+IHtcbiAgICAgIGxldCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgICBsZXQgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKGUuY2xpZW50WCk7XG4gICAgICBsZXQgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKGUuY2xpZW50WSk7XG4gICAgICBsZXQgY29sb3IgPSBwb2ludGVyLmNvbG9yO1xuICAgICAgdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1ksIGNvbG9yKTtcbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgZnVuY3Rpb24gaGFuZGxlRmlyc3RUb3VjaFN0YXJ0KGUpIHtcbiAgICAgICAgY29uc3QgdG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlcztcbiAgICAgICAgbGV0IHBvaW50ZXIgPSBwb2ludGVyc1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFgpO1xuICAgICAgICAgIGxldCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRZKTtcbiAgICAgICAgICB1cGRhdGVGcmFtZSgpOyAvLyBzdGFydCBhbmltYXRpb24gbG9vcFxuICAgICAgICAgIHVwZGF0ZVBvaW50ZXJEb3duRGF0YShwb2ludGVyLCB0b3VjaGVzW2ldLmlkZW50aWZpZXIsIHBvc1gsIHBvc1kpO1xuICAgICAgICB9XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgaGFuZGxlRmlyc3RUb3VjaFN0YXJ0KTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIChlKSA9PiB7XG4gICAgICBjb25zdCB0b3VjaGVzID0gZS50YXJnZXRUb3VjaGVzO1xuICAgICAgbGV0IHBvaW50ZXIgPSBwb2ludGVyc1swXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0uY2xpZW50WCk7XG4gICAgICAgIGxldCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRZKTtcbiAgICAgICAgdXBkYXRlUG9pbnRlckRvd25EYXRhKHBvaW50ZXIsIHRvdWNoZXNbaV0uaWRlbnRpZmllciwgcG9zWCwgcG9zWSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBjb25zdCB0b3VjaGVzID0gZS50YXJnZXRUb3VjaGVzO1xuICAgICAgICBsZXQgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0uY2xpZW50WCk7XG4gICAgICAgICAgbGV0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFkpO1xuICAgICAgICAgIHVwZGF0ZVBvaW50ZXJNb3ZlRGF0YShwb2ludGVyLCBwb3NYLCBwb3NZLCBwb2ludGVyLmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHRvdWNoZXMgPSBlLmNoYW5nZWRUb3VjaGVzO1xuICAgICAgbGV0IHBvaW50ZXIgPSBwb2ludGVyc1swXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGVQb2ludGVyVXBEYXRhKHBvaW50ZXIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdXBkYXRlRnJhbWUoKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtcbiAgICBTSU1fUkVTT0xVVElPTixcbiAgICBEWUVfUkVTT0xVVElPTixcbiAgICBDQVBUVVJFX1JFU09MVVRJT04sXG4gICAgREVOU0lUWV9ESVNTSVBBVElPTixcbiAgICBWRUxPQ0lUWV9ESVNTSVBBVElPTixcbiAgICBQUkVTU1VSRSxcbiAgICBQUkVTU1VSRV9JVEVSQVRJT05TLFxuICAgIENVUkwsXG4gICAgU1BMQVRfUkFESVVTLFxuICAgIFNQTEFUX0ZPUkNFLFxuICAgIFNIQURJTkcsXG4gICAgQ09MT1JfVVBEQVRFX1NQRUVELFxuICAgIEJBQ0tfQ09MT1IsXG4gICAgVFJBTlNQQVJFTlQsXG4gIF0pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmaXhlZCB0b3AtMCBsZWZ0LTAgei01MCBwb2ludGVyLWV2ZW50cy1ub25lXCI+XG4gICAgICA8Y2FudmFzIHJlZj17Y2FudmFzUmVmfSBpZD1cImZsdWlkXCIgY2xhc3NOYW1lPVwidy1zY3JlZW4gaC1zY3JlZW5cIiAvPlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5leHBvcnQgeyBTcGxhc2hDdXJzb3IgfTtcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJTcGxhc2hDdXJzb3IiLCJTSU1fUkVTT0xVVElPTiIsIkRZRV9SRVNPTFVUSU9OIiwiQ0FQVFVSRV9SRVNPTFVUSU9OIiwiREVOU0lUWV9ESVNTSVBBVElPTiIsIlZFTE9DSVRZX0RJU1NJUEFUSU9OIiwiUFJFU1NVUkUiLCJQUkVTU1VSRV9JVEVSQVRJT05TIiwiQ1VSTCIsIlNQTEFUX1JBRElVUyIsIlNQTEFUX0ZPUkNFIiwiU0hBRElORyIsIkNPTE9SX1VQREFURV9TUEVFRCIsIkJBQ0tfQ09MT1IiLCJyIiwiZyIsImIiLCJUUkFOU1BBUkVOVCIsImNhbnZhc1JlZiIsImNhbnZhcyIsImN1cnJlbnQiLCJQb2ludGVyIiwiaWQiLCJ0ZXhjb29yZFgiLCJ0ZXhjb29yZFkiLCJwcmV2VGV4Y29vcmRYIiwicHJldlRleGNvb3JkWSIsImRlbHRhWCIsImRlbHRhWSIsImRvd24iLCJtb3ZlZCIsImNvbG9yIiwiY29uZmlnIiwiUEFVU0VEIiwicG9pbnRlcnMiLCJnbCIsImV4dCIsImdldFdlYkdMQ29udGV4dCIsInN1cHBvcnRMaW5lYXJGaWx0ZXJpbmciLCJwYXJhbXMiLCJhbHBoYSIsImRlcHRoIiwic3RlbmNpbCIsImFudGlhbGlhcyIsInByZXNlcnZlRHJhd2luZ0J1ZmZlciIsImdldENvbnRleHQiLCJpc1dlYkdMMiIsImhhbGZGbG9hdCIsImdldEV4dGVuc2lvbiIsImNsZWFyQ29sb3IiLCJoYWxmRmxvYXRUZXhUeXBlIiwiSEFMRl9GTE9BVCIsIkhBTEZfRkxPQVRfT0VTIiwiZm9ybWF0UkdCQSIsImZvcm1hdFJHIiwiZm9ybWF0UiIsImdldFN1cHBvcnRlZEZvcm1hdCIsIlJHQkExNkYiLCJSR0JBIiwiUkcxNkYiLCJSRyIsIlIxNkYiLCJSRUQiLCJpbnRlcm5hbEZvcm1hdCIsImZvcm1hdCIsInR5cGUiLCJzdXBwb3J0UmVuZGVyVGV4dHVyZUZvcm1hdCIsInRleHR1cmUiLCJjcmVhdGVUZXh0dXJlIiwiYmluZFRleHR1cmUiLCJURVhUVVJFXzJEIiwidGV4UGFyYW1ldGVyaSIsIlRFWFRVUkVfTUlOX0ZJTFRFUiIsIk5FQVJFU1QiLCJURVhUVVJFX01BR19GSUxURVIiLCJURVhUVVJFX1dSQVBfUyIsIkNMQU1QX1RPX0VER0UiLCJURVhUVVJFX1dSQVBfVCIsInRleEltYWdlMkQiLCJmYm8iLCJjcmVhdGVGcmFtZWJ1ZmZlciIsImJpbmRGcmFtZWJ1ZmZlciIsIkZSQU1FQlVGRkVSIiwiZnJhbWVidWZmZXJUZXh0dXJlMkQiLCJDT0xPUl9BVFRBQ0hNRU5UMCIsInN0YXR1cyIsImNoZWNrRnJhbWVidWZmZXJTdGF0dXMiLCJGUkFNRUJVRkZFUl9DT01QTEVURSIsIk1hdGVyaWFsIiwic2V0S2V5d29yZHMiLCJrZXl3b3JkcyIsImhhc2giLCJpIiwibGVuZ3RoIiwiaGFzaENvZGUiLCJwcm9ncmFtIiwicHJvZ3JhbXMiLCJmcmFnbWVudFNoYWRlciIsImNvbXBpbGVTaGFkZXIiLCJGUkFHTUVOVF9TSEFERVIiLCJmcmFnbWVudFNoYWRlclNvdXJjZSIsImNyZWF0ZVByb2dyYW0iLCJ2ZXJ0ZXhTaGFkZXIiLCJhY3RpdmVQcm9ncmFtIiwidW5pZm9ybXMiLCJnZXRVbmlmb3JtcyIsImJpbmQiLCJ1c2VQcm9ncmFtIiwiY29uc3RydWN0b3IiLCJQcm9ncmFtIiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJnZXRQcm9ncmFtUGFyYW1ldGVyIiwiTElOS19TVEFUVVMiLCJjb25zb2xlIiwidHJhY2UiLCJnZXRQcm9ncmFtSW5mb0xvZyIsInVuaWZvcm1Db3VudCIsIkFDVElWRV9VTklGT1JNUyIsInVuaWZvcm1OYW1lIiwiZ2V0QWN0aXZlVW5pZm9ybSIsIm5hbWUiLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJzb3VyY2UiLCJhZGRLZXl3b3JkcyIsInNoYWRlciIsImNyZWF0ZVNoYWRlciIsInNoYWRlclNvdXJjZSIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiZ2V0U2hhZGVySW5mb0xvZyIsImtleXdvcmRzU3RyaW5nIiwiZm9yRWFjaCIsImtleXdvcmQiLCJiYXNlVmVydGV4U2hhZGVyIiwiVkVSVEVYX1NIQURFUiIsImNvcHlTaGFkZXIiLCJjbGVhclNoYWRlciIsImRpc3BsYXlTaGFkZXJTb3VyY2UiLCJzcGxhdFNoYWRlciIsImFkdmVjdGlvblNoYWRlciIsImRpdmVyZ2VuY2VTaGFkZXIiLCJjdXJsU2hhZGVyIiwidm9ydGljaXR5U2hhZGVyIiwicHJlc3N1cmVTaGFkZXIiLCJncmFkaWVudFN1YnRyYWN0U2hhZGVyIiwiYmxpdCIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJjcmVhdGVCdWZmZXIiLCJidWZmZXJEYXRhIiwiRmxvYXQzMkFycmF5IiwiU1RBVElDX0RSQVciLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsIlVpbnQxNkFycmF5IiwidmVydGV4QXR0cmliUG9pbnRlciIsIkZMT0FUIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJ0YXJnZXQiLCJjbGVhciIsInZpZXdwb3J0IiwiZHJhd2luZ0J1ZmZlcldpZHRoIiwiZHJhd2luZ0J1ZmZlckhlaWdodCIsIndpZHRoIiwiaGVpZ2h0IiwiQ09MT1JfQlVGRkVSX0JJVCIsImRyYXdFbGVtZW50cyIsIlRSSUFOR0xFUyIsIlVOU0lHTkVEX1NIT1JUIiwiZHllIiwidmVsb2NpdHkiLCJkaXZlcmdlbmNlIiwiY3VybCIsInByZXNzdXJlIiwiY29weVByb2dyYW0iLCJjbGVhclByb2dyYW0iLCJzcGxhdFByb2dyYW0iLCJhZHZlY3Rpb25Qcm9ncmFtIiwiZGl2ZXJnZW5jZVByb2dyYW0iLCJjdXJsUHJvZ3JhbSIsInZvcnRpY2l0eVByb2dyYW0iLCJwcmVzc3VyZVByb2dyYW0iLCJncmFkaWVuU3VidHJhY3RQcm9ncmFtIiwiZGlzcGxheU1hdGVyaWFsIiwiaW5pdEZyYW1lYnVmZmVycyIsInNpbVJlcyIsImdldFJlc29sdXRpb24iLCJkeWVSZXMiLCJ0ZXhUeXBlIiwicmdiYSIsInJnIiwiZmlsdGVyaW5nIiwiTElORUFSIiwiZGlzYWJsZSIsIkJMRU5EIiwiY3JlYXRlRG91YmxlRkJPIiwicmVzaXplRG91YmxlRkJPIiwiY3JlYXRlRkJPIiwidyIsImgiLCJwYXJhbSIsImFjdGl2ZVRleHR1cmUiLCJURVhUVVJFMCIsInRleGVsU2l6ZVgiLCJ0ZXhlbFNpemVZIiwiYXR0YWNoIiwiZmJvMSIsImZibzIiLCJyZWFkIiwidmFsdWUiLCJ3cml0ZSIsInN3YXAiLCJ0ZW1wIiwicmVzaXplRkJPIiwibmV3RkJPIiwidW5pZm9ybTFpIiwidVRleHR1cmUiLCJ1cGRhdGVLZXl3b3JkcyIsImRpc3BsYXlLZXl3b3JkcyIsInB1c2giLCJsYXN0VXBkYXRlVGltZSIsIkRhdGUiLCJub3ciLCJjb2xvclVwZGF0ZVRpbWVyIiwidXBkYXRlRnJhbWUiLCJkdCIsImNhbGNEZWx0YVRpbWUiLCJyZXNpemVDYW52YXMiLCJ1cGRhdGVDb2xvcnMiLCJhcHBseUlucHV0cyIsInN0ZXAiLCJyZW5kZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJNYXRoIiwibWluIiwic2NhbGVCeVBpeGVsUmF0aW8iLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIndyYXAiLCJwIiwiZ2VuZXJhdGVDb2xvciIsInNwbGF0UG9pbnRlciIsInVuaWZvcm0yZiIsInRleGVsU2l6ZSIsInVWZWxvY2l0eSIsInVDdXJsIiwidW5pZm9ybTFmIiwidURpdmVyZ2VuY2UiLCJ1UHJlc3N1cmUiLCJkeWVUZXhlbFNpemUiLCJ2ZWxvY2l0eUlkIiwidVNvdXJjZSIsImRpc3NpcGF0aW9uIiwiYmxlbmRGdW5jIiwiT05FIiwiT05FX01JTlVTX1NSQ19BTFBIQSIsImVuYWJsZSIsImRyYXdEaXNwbGF5IiwicG9pbnRlciIsImR4IiwiZHkiLCJzcGxhdCIsImNsaWNrU3BsYXQiLCJyYW5kb20iLCJ4IiwieSIsInVUYXJnZXQiLCJhc3BlY3RSYXRpbyIsInBvaW50IiwidW5pZm9ybTNmIiwicmFkaXVzIiwiY29ycmVjdFJhZGl1cyIsInVwZGF0ZVBvaW50ZXJEb3duRGF0YSIsInBvc1giLCJwb3NZIiwidXBkYXRlUG9pbnRlck1vdmVEYXRhIiwiY29ycmVjdERlbHRhWCIsImNvcnJlY3REZWx0YVkiLCJhYnMiLCJ1cGRhdGVQb2ludGVyVXBEYXRhIiwiZGVsdGEiLCJjIiwiSFNWdG9SR0IiLCJzIiwidiIsImYiLCJxIiwidCIsImZsb29yIiwibWF4IiwicmFuZ2UiLCJyZXNvbHV0aW9uIiwicm91bmQiLCJpbnB1dCIsInBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwiY2hhckNvZGVBdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiY2xpZW50WCIsImNsaWVudFkiLCJkb2N1bWVudCIsImJvZHkiLCJoYW5kbGVGaXJzdE1vdXNlTW92ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVGaXJzdFRvdWNoU3RhcnQiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImlkZW50aWZpZXIiLCJjaGFuZ2VkVG91Y2hlcyIsImRpdiIsImNsYXNzTmFtZSIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/splash-cursor.tsx\n"));

/***/ })

});